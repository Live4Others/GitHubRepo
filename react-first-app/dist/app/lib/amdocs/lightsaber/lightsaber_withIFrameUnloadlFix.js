/**
Set of common <em>Utility</em> methods.

@class Lightsaber.Core.Utils
@namespace Lightsaber.Core
@module Lightsaber.Core
@extends Object

@since 9.0.0

@requires underscore
@requires backbone
@requires knockout
@requires knockout.mapping
@requires jquery

@examples Lightsaber.Core.Utils

@static
**/
define('src/core/util/Utils',[
	'jquery', 
	'underscore', 
	'backbone', 
	'knockout', 
	'knockout.mapping'
], function($, _, Backbone, KO, KOMapping) {

	

	var namedParam    = /:\w+/g;
	var splatParam    = /\*\w+/g;
	var escapeRegExp  = /[-[\]{}()+?.,\\^$|#\s]/g;
	
	var getDate = (function(){
		var dateFunc;
	    var D= new Date('2014-01-01T00:00:00+00:00');
	    if(true || !D || +D!== 1388534400000){
	        return function(s){
	            var day, tz,
	            rx=/^(\d{4}\-\d\d\-\d\d([tT ][\d:\.]*)?)([zZ]|([+\-])(\d\d):(\d\d))?$/,
	            p= rx.exec(s) || [];
	            if(p[1]){
	                day= p[1].split(/\D/);
	                for(var i= 0, L= day.length; i<L; i++){
	                    day[i]= parseInt(day[i], 10) || 0;
	                };
	                day[1]-= 1;
	                day= new Date(Date.UTC.apply(Date, day));
	                if(!day.getDate()) return NaN;
	                if(p[5]){
	                    tz= (parseInt(p[5], 10)*60);
	                    if(p[6]) tz+= parseInt(p[6], 10);
	                    if(p[4]== '+') tz*= -1;
	                    if(tz) day.setUTCMinutes(day.getUTCMinutes()+ tz);
	                }
	                return day;
	            }
	            return new Date(s);
	        }
	    }
	    else{
	    	return function(s) {
	    		return new Date(s);
	    	}
	    }
	})();

	var Utils = {

		/**
		Performs the initial configuration of the object with a set of options.

		@method configure
		@param {Object} target target object that should be configured 
		@param {Object} options configuration options 
		@param {Array of String} directProps array of property names that should be directly attached to the target object 
		**/
		configure : function(target, options, directProps) {
			if (this.options) options = _.extend({}, this.options, options);
			for (var i = 0, len = directProps.length; i < len; i++) {
				var attr = directProps[i];
				if ( !_.isUndefined(options[attr])) {
					target[attr] = options[attr];
				};
			}
			target.options = options;
		},

		/**
		Generate a pseudo-random GUID by concatenating pseudo-random hexadecimals.

		@method guid
		@return {String} pseudo-random GUID
		**/
		guid: function() {
			// Generate four random hex digits.
			var S4 = function S4() {
				return (((1+Math.random())*0x10000)|0).toString(16).substring(1);
			};

		   return (S4()+S4()+"-"+S4()+"-"+S4()+"-"+S4()+"-"+S4()+S4()+S4());
		},

		/**
		@private
		**/
		checkConfig: function(confAttrs, conf) {
			for(var i in confAttrs) {
				if (_.isUndefined(conf[confAttrs[i]])) {
					throw "attribute '" + confAttrs[i] + "' was not found for validation '" + conf.check + "'";
				}
			}
		},

		/**
		Returns value associated with provided object path
		
		@method getValueByPath
		@param {Object} object The object to which the path applies
		@param {String} path The object path		
		@return {...} value associated with the path
		@example

		```javascript
		var object = {
			date: '1776, July 4th',
			item: {
				id: 0,
				name: 'Item1'
			},
			numbers: [1,2,3,4]
		}
		var utils = new Utils();

		console.log(utils.getValueByPath(object,'item.name')); // output: 'Item1'
		console.log(utils.getValueByPath(object,'date')); // output: '1776, July 4th'
		console.log(utils.getValueByPath(object,'numbers[1]')); // output: '2'
		```
		**/
		getValueByPath: function(object, path, wrapped) {
            var frags, frag, unwrapped, result;
            
            if(!path || !(typeof path === 'string')) {
                return;
            }
		  	
		  	path = path.replace(/\[(\w+)\]/g, '.$1');
		  	path = path.replace(/^\./, '');
            frags = path.split('.');

		  	while (frags.length) {
                frag = frags.shift();

                if(KO.isObservable(object)) {
                    unwrapped = KO.unwrap(object);
                    // unwrapped = object.peek();
                } else {
                    unwrapped = object;
                }

                if (typeof(unwrapped) === 'object' && (frag in unwrapped)) {
                    object = unwrapped[frag];   
		    	} else {
		      		return undefined;
		    	}
		  	}

		  	if(wrapped) {
		  		result = object;
		  	} else {
		  		if(_.isObject(object)) {
		  			result = KOMapping.toJS(object);
			  	} else {
			  		result = KO.unwrap(object);
			  		// result = object.peek();
			  	}
			}
		  	
		  	return result;
		},

        _getValueByPropPath: function(object, path, prop, wrapped) {
            var frags, frag, unwrapped, result;
            
            if(!path || !(typeof path === 'string')) {
                return;
            }
            
            path = path.replace(/\[(\w+)\]/g, '.$1');
            path = path.replace(/^\./, '');
            frags = path.split('.');

            while (frags.length) {
                frag = frags.shift();

                if(KO.isObservable(object)) {
                    unwrapped = KO.unwrap(object);
                } else {
                    unwrapped = object;
                }

                if (typeof(unwrapped) === 'object') {
                    if(_.isArray(unwrapped)) {
                        for (var i = 0; i < unwrapped.length; i++) {
                            if(_.has(unwrapped[i], prop) && unwrapped[i][prop] === frag) {
                                object = unwrapped[i]; 
                                break;
                            }
                        };
                    } else if(_.has(unwrapped, frag)) {
                        object = unwrapped[frag];                           
                    } else {
                        return undefined;                        
                    }
                } else {
                    return undefined;
                }
            }

            if(wrapped) {
                result = object;
            } else {
                if(_.isObject(object)) {
                    result = KOMapping.toJS(object);
                } else {
                    result = KO.unwrap(object);
                }
            }
            
            return result;
        },

		setOrInitValueByPath: function(object, path, value, initOnly) {
            var current = object;
            var pathParts, prop, result;

            if(path) {
                pathParts = path.split('.');

                for (var i = 0, length = pathParts.length; i < length; i++) {
                    prop = pathParts[i];

                    if(i === (length - 1)) {
	                    if(!initOnly) {
	                    	if(KO.isObservable(current[prop])) {
                        		current[prop](value);      	                    		
	                    	} else {
                                if(_.isObject(current[prop])) {
                                    current[prop] = _.extend({}, current[prop], value);   
                                } else {
                        		  current[prop] = value;      	                    		                                    
                                }
	                    	}
                        	break;      	
                        } else {
                        	if(_.isUndefined(current[prop])) {
                        		current[prop] = value;   
                        		break;         	            		
                        	} else {
                                if(_.isArray(current[prop])) {
                                    current[prop] = _.extend([], value, current[prop]); 
                                } else if(_.isObject(current[prop])) {
                        		    current[prop] = _.extend({}, value, current[prop]);   
                        		}
                        	}
                        }

                        result = current[prop];
                    } else {
                    	if(_.isUndefined(current[prop])) {
                    	    current[prop] = {};
                    	}
                    }

                    current = current[prop];
                }
            }

            return result;
		},

		setValueByPath: function(object, path, value, mapping) {
            var current = object;
            var pathParts, prop;

            if(path) {
            	pathParts = path.split('.');

            	for (var i = 0, length = pathParts.length; i < length; i++) {
            		prop = pathParts[i];

            		if(i === (length - 1)) {
            			if(KO.isObservable(current)) {
            				current()[prop] = value;
            			} else if(KO.isObservable(current[prop])) {
                            if(KO.isObservable(value)) {
                                current[prop] = value;  
                            } else {
            			     current[prop](value);                                                                   
                            }
            			} else {
            			    current[prop] = value;                                      
            			}

            			break;      
            		} else {
            			if(KO.isObservable(current)) {
            				current = current()[prop];
            			} else if(_.isUndefined(current[prop])) {
            			    current[prop] = {};
            			} else {
            			    current = current[prop];                                    
            			}
            		}
            	}
            }
		},

        safeUnwrap: function(observable) {
        	var data;
        	var computed = KO.computed(function() {
        	    data = KOMapping.toJS(observable);
        	});

        	computed.dispose();

        	return data;
        },

		/**
		@private
		**/
		_normalizeVmKey: function(key) {
			var parts = key.split(':');
			if (parts.length === 2) {
				return ['subViewModels', parts[0].replace(/\./g, '.subViewModels.'), parts[1]].join('.');
			}
			return key;
		},

		asLiteral: function(value) {
			var result = value;
			var converted;

			if(_.isObject(value)) {
				result = value;
				this._objectPropsAsLiterals(result);
			} else {
				if(value !== true && value !== false && value !== '') {                
				    converted = Number(value);

				    if(!_.isNaN(converted)) {
				        result = converted;
				    }
				}				
			}

			return result;
		},

		_objectPropsAsLiterals: function(object) {
			var Utils = this;

			_.each(object, function(value, key) {
				if(_.isObject(value)) {
					Utils._objectPropsAsLiterals(value)
				} else {
					object[key] = Utils.asLiteral(value);
				}
			});
		},

		/**
		@private
		**/
		getFieldValue: function(field, conf, attrs, model) {
			var fieldName = conf[field];
			var val = attrs[fieldName];
			if (_.isUndefined(val) && conf.invar ) {
				val = model.get(fieldName);
			}
			return val;
		},

		/**
		Returns a date object 

		@method getDate
		@param {any} a date value to be parsed
		@return {object} date object
		**/
		getDate: getDate,

		/**
		Main extension method used by **all** *UXF* classes.

		@method extend
		@param {Object} protoProps new class' prototype properties and methods
		@param {Object} classProps new class' properties and methods
		@returns {...} the new class' constructor function
		**/
		extend: function(protoProps, classProps) {
			protoProps = _.clone(protoProps || {});
			classProps = _.clone(classProps || {});

			_.each(protoProps, function(method, name) {
				if (// can be wrapped with _super()
					_.isFunction(method) && this.prototype[name] &&
					// wrap only when _super() is used and method is not already wrapped 
					isUsingSuper.test(method) && method != wrapperSourceCode
					) {
					protoProps[name] = wrapWithSuper(method, this.prototype, name);
				}
			}, this);


			// uncomment this section if want to handle empty / undefined publicMethods as make all public
			/*var actions = [];

			if (!protoProps['publicMethods'] ||  protoProps['publicMethods'].length === 0) {
				var funcs = _.functions(protoProps);
				for (var i = 0;  i < funcs.length ; i++ ){
				      var key = funcs[i];
				      if (key.substring(0,1) !== '_' && key !== '$' && key !== 'constructor') {
				      	actions.push(key);
				      }
				}
			}
			
			
            
			var parent = this;
			while(parent) {
		        if (parent.prototype && 
		           (!parent.prototype.hasOwnProperty('publicMethods') || !parent.prototype.publicMethods || parent.prototype.publicMethods.length === 0)) { // if ctor.publicMethods is not defined
            		var funcs = _.functions(parent.prototype);
				    for (var i = 0;  i < funcs.length ; i++ ){
				      var key = funcs[i];
				      if (!parent.prototype.hasOwnProperty(key)) continue;
				      if (key.substring(0,1) !== '_' && key !== '$' && key !== 'constructor') {
				      	actions.push(key);
				      }
				    }
				    
            	} // get the next parent in line
            	if (parent._super) { 
            		parent = parent._super;
            	} else {
            		parent = undefined;
            	}
        	}

        	protoProps['publicMethods'] =  _.union(protoProps['publicMethods'] || [] , actions); //$.extend(true, [], protoProps['publicMethods'] || [] , actions); */
            this.mergeProperties = this.mergeProperties ? this.mergeProperties : {};
            _.extend(this.mergeProperties, { optionsMap : 'merge'}) ;

			if (this.mergeProperties) {
				_.each(this.mergeProperties, function(value, name) {
					if (_.isArray(this.prototype[name]) || _.isArray(protoProps[name]) ) { // this will make sure publicMethods are a merged array
						protoProps[name] = _.union(this.prototype[name] || [], protoProps[name] || [] ); //$.extend(true, [], this.prototype[name] || [], protoProps[name] || []);
					} else {
					protoProps[name] = $.extend(true, {}, this.prototype[name] || {}, protoProps[name] || {});
					}
				}, this);
				classProps.mergeProperties = _.extend({}, classProps.mergeProperties || {}, this.mergeProperties);
			}

        	var child = backboneExtend.call(this, protoProps, classProps);
			if (child.postExtend)
				child.postExtend();
			child._super = this;

        
			return child;
		},
		
		/**
		Translates route (as used by {{#crossLink "Lightsaber.Core.Router/navigate:method"}}{{/crossLink}}) to regex for 
		usage in detection of the route later on.

		@method routeToRegExp
		@private
		**/
		routeToRegExp: function(route) {
        	route = route.replace(escapeRegExp, '\\$&').replace(namedParam, '([^\/]+)').replace(splatParam, '(.*?)');
        	return new RegExp('^' + route + '$');
        },

        /**
		Clones the data.
		
		> **Note** that `data` must be a **JSON-serializable object**.

		@method clone
		@param {Object} data data to be cloned
		@param {Boolean} shallow whether the clone should be shallow (like *Underscore* `clone` method)
		**/
        clone: function(data, shallow) {
        	return shallow ? _.clone(data) : JSON.parse(JSON.stringify(data));
        },
        
        /**
		Extracts path parameters from the provided route (as used by {{#crossLink "Lightsaber.Core.Router/navigate:method"}}{{/crossLink}}).

		@method extractParameters
		@private
		**/
        extractParameters: function(route, fragment) {
        	return route.exec(fragment).slice(1);
        },
		
		/**
		Main creation method used by **all** *UXF* classes.

		> **Note** that this method is intended to be injected into other classes prototypes and **should not be called** with
		> `Lightsaber.Core.Utils` as its context. 
		> 
		> Calls to `create` method are always made in `this` context - 
		> which is possible since all *UXF* components have the `create` method.

		This is the recommended way of creating **all** *UXF* classes:

		```javascript
		this.create('view1', Lightsaber.Core.View, {
			el: $root,
			viewModel: viewModel
		});
		```

		@method create
		@param {String} id ID to be give to the instance (for various references)
		@param {...} component contructor function of the component
		@param {Object} data data parameter to the component's constructor
		@param {Object} config config parameter to the component's constructor
		@returns {...} the new class' instance
		**/
		create : function(ID, component, data, config) {
			var configs = [], i, j, len, newConfig, method, proto,
				isModel = component === Backbone.Model ||
						component.prototype instanceof Backbone.Model ||
						component === Backbone.Collection ||
						component.prototype instanceof Backbone.Collection,
                isView = component === Backbone.View ||
                        component.prototype instanceof Backbone.View;

			
			if (!isModel) {
				config = data;
			}
			
			configs.push(Utils.getMappedOptions(this, ID, component, data));

			if (this.hasOwnProperty('cust') && this.cust[ID]) {
				configs.push(this.cust[ID]);
			}
			proto = this.constructor.prototype;

			while (true) {

				if (proto.hasOwnProperty('cust') && proto.cust[ID]) {
					configs.push(proto.cust[ID]);
				}
				
				// go up through prototypes chain
				if (!proto.constructor._super) {
					break;
				}
				proto = proto.constructor._super.prototype;
				
			}
			if (config) {
				configs.push(config);
			}

			newConfig = {};
			for (i = configs.length-1; i >= 0; --i) {
				config = configs[i];
				
				if (_.isFunction(config)) {
					newConfig = config.call(this, newConfig);
					continue;
				}
				
				if (!_.isArray(config)) {
					config = [{ 'merge': config }];
				}
				for (j = 0, len = config.length; j < len; ++j) {
					if (_.isFunction(config[j])) {
						newConfig = config[j].call(this, newConfig);
					}
					else {
						for (method in config[j]) {
							switch(method) {
							case 'component':
								component = config[j][method];
								break;
							case 'merge':
								$.extend(true, newConfig, config[j][method]);
								break;
							case 'override_top':
								$.extend(newConfig, config[j][method]);
								break;
							case 'override':
								newConfig = $.extend({}, config[j][method]);
								break;
							case 'delete':
								deleteProperties(newConfig, config[j][method]);
								break;
							}
						}
					}
				}
			}

			var created;
            var options = _.extend(newConfig, {___parent: this, ___id: ID});
            if(isModel) {
                created = new component(data, options);
            }
            else {
                if (isView) {
                    var processUnderscore = true;
                    if (this.options.___processUnderscore === false ||
                        this.getConfig('processUnderscore') === false) {
                        processUnderscore = false;
                    }
                    created = new component(_.extend(options, {___processUnderscore: processUnderscore}));
                }
                else if (component.isViewModel && requirejs.appContext){
                    var getVmNamespaceIdFn = Utils._getVmGroupId(this);
                    created = requirejs.appContext.createVM(component, options, getVmNamespaceIdFn(component));
                }
                else {
                    created = new component(options);
                }
                Utils.mapMethods(created);
               	this.___children = this.___children || [];
                this.___children.push(created);
                this.___children.hash = this.___children.hash || {};
                this.___children.hash[ID] = created;
            }

            return created;
		},
		
		/** 
		Default comparator for sorting collection data (called by `Backbone.Collection.sort` method).

		Supported data types: string, number.
		Supported sort order: asc, desc.

		@method collectionComparator
		@param {Lightsaber.Core.Model} model model that should be used 
		**/
		collectionComparator : function(model) {
			function isNumber(num) {
				return parseFloat(num).toString() == num;
			};
			if (this.sortOrder=='asc') {
				return model.get(this.sortName);
			} else {
				var str = model.get(this.sortName);
				if(isNumber(str)) {
					return -str;
				}
				else {
					str = str.toLowerCase();
					str = str.split("");
					str = _.map(str, function(letter) {
						return String.fromCharCode(-(letter.charCodeAt(0)));
					});
					return str;
				}
			}
		},

		_base64Chars: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
		_base64regex: /[^A-Za-z0-9\+\/\=]/g,

		/** 
		Encodes a string in `base64` encoding.

		@method decode64
		@param {String} data to be encoded
		**/
		decode64: function(input) {
			var output = new Array( Math.ceil(0.75*input.length));
			var chr1, chr2, chr3;
			var enc1, enc2, enc3, enc4;
			var p = 0, i = 0;

			if (this._base64regex.exec(input)) 
				throw "invalid base64 characters in text input" + input;

			do {
				enc1 = this._base64Chars.indexOf(input.charAt(i++));
				enc2 = this._base64Chars.indexOf(input.charAt(i++));
				enc3 = this._base64Chars.indexOf(input.charAt(i++));
				enc4 = this._base64Chars.indexOf(input.charAt(i++));

				chr1 = (enc1 << 2) | (enc2 >> 4);
				chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
				chr3 = ((enc3 & 3) << 6) | enc4;

				output[p++] = chr1;
				(enc3 != 64) && (output[p++] = chr2);
				(enc4 != 64) && (output[p++] = chr3);

			} while (i < input.length);

			output.length = p;
			return output;
		},
		
		//IE8 has a bug with JSON.stringify implementation. 
		//Use below version of stringify method only when you need IE8 support
		stringify : function(objectToBeStringified) {
				return this.stringifyForIE8(objectToBeStringified);
		},
		
		stringifyForIE8: function(o) {
			if ( o === null ) {
				return 'null';
			}
	
			var type = typeof o;
	
			if ( type === 'undefined' ) {
				return undefined;
			}
			if ( type === 'number' || type === 'boolean' ) {
				return '' + o;
			}
			if ( type === 'string') {
				return $.quoteString( o );
			}
			if ( type === 'object' ) {
				if ( typeof o.toJSON === 'function' ) {
					return $.toJSON( o.toJSON() );
				}
				if ( o.constructor === Date ) {
					var	month = o.getUTCMonth() + 1,
						day = o.getUTCDate(),
						year = o.getUTCFullYear(),
						hours = o.getUTCHours(),
						minutes = o.getUTCMinutes(),
						seconds = o.getUTCSeconds(),
						milli = o.getUTCMilliseconds();
	
					if ( month < 10 ) {
						month = '0' + month;
					}
					if ( day < 10 ) {
						day = '0' + day;
					}
					if ( hours < 10 ) {
						hours = '0' + hours;
					}
					if ( minutes < 10 ) {
						minutes = '0' + minutes;
					}
					if ( seconds < 10 ) {
						seconds = '0' + seconds;
					}
					if ( milli < 100 ) {
						milli = '0' + milli;
					}
					if ( milli < 10 ) {
						milli = '0' + milli;
					}
					return '"' + year + '-' + month + '-' + day + 'T' +
						hours + ':' + minutes + ':' + seconds +
						'.' + milli + 'Z"';
				}
				if ( o.constructor === Array ) {
					var ret = [];
					for ( var i = 0; i < o.length; i++ ) {
						ret.push( $.toJSON( o[i] ) || 'null' );
					}
					return '[' + ret.join(',') + ']';
				}
				var	name,
					val,
					pairs = [];
				// Below 'For..in' loop had problem in IE8. So, it was replaced with regular For loop
				// for ( var k in o ) {
				for (var k = 0; k < o.length; k++){
					type = typeof k;
					if ( type === 'number' ) {
						name = '"' + k + '"';
					} else if (type === 'string') {
						name = $.quoteString(k);
					} else {
						// Keys must be numerical or string. Skip others
						continue;
					}
					type = typeof o[k];
	
					if ( type === 'function' || type === 'undefined' ) {
						// Invalid values like these return undefined
						// from toJSON, however those object members
						// shouldn't be included in the JSON string at all.
						continue;
					}
					val = $.toJSON( o[k] );
					pairs.push( name + ':' + val );
				}
				return '{' + pairs.join( ',' ) + '}';
			}
		}
	};
	
	
	/**
	Copy of original Backbone extend().
	@private
	**/
	var backboneExtend = Backbone.View.extend;
	/**
	 * Wraps method so that it can use this._super() to call method of super-class.
	 * @param {Function} method Method that uses _super()
	 * @param {Object} parentPrototype Prototype of parent class.
	 * @param {String} parentMethodName Name of the method.
	 * @returns A wrapped method
	 * @private
	 */
	var wrapWithSuper = function(method, parentPrototype, parentMethodName) {
		var wrapper = function() {
			var backup = this._super, ret;
			this._super = parentPrototype[parentMethodName];
			ret = method.apply(this, arguments);
			this._super = backup;
			return ret;
		};
		_.extend(wrapper, method);
		wrapper.prototype = method.prototype;
		return wrapper;
	};
	
	/**
	Check if we can use Function.prototype.toString() method to determine if _super is used in function.
	@private
	**/
	var canDecompile = /sometext/.test(function() { var sometext; });
	var isUsingSuper = canDecompile ? /\b_super\b/ : /.*/;
	var wrapperSourceCode = canDecompile ? wrapWithSuper(function() {}).toString() : '$';
	
	var deleteProperties = function(obj, properties) {
		for (var prop in properties) {
			if (!(prop in obj)) continue;
			if (_.isObject(properties[prop]) && _.isObject(obj[prop])) {
				deleteProperties(obj[prop], properties[prop]);
			} else {
				delete obj[prop];
			}
		}
	};

	/**
	@private
	**/
	Utils.getMappedOptions = function getMappedOptions(object, path, component, data, options) {

		if ( _.isUndefined(options) ) {
			options = {};
		}

		if ( _.isUndefined(object) ) {
			return options;
		}

		if ('optionsMap' in object) {			
			var augmentedOptions = {};
			var mapping = object.optionsMap[path];
			if ( ! _.isUndefined(mapping) ) {
				for(var prop in mapping) {
					if(object[prop]) {
						augmentedOptions[prop] = augmentedOptions[prop] || {};
						var value;
						for(var subprop in mapping[prop]) {
							
							var mappingVal = mapping[prop][subprop];
							value = undefined;
							
							if (prop === 'config') {
								value = Utils.getValueByPath(object.getConfig(), mappingVal, true);
							}
							
							if ( _.isUndefined(value) ) {
								if ( _.isObject(mappingVal) ) {
									value = mappingVal.value;
								}
								else if ( !_.isUndefined(object[prop][mappingVal]) ) {
									value = object[prop][mappingVal];
								}
								else if ( !_.isUndefined(Utils.getValueByPath(data[prop], subprop) ) ) {
									value = Utils.getValueByPath(data[prop], subprop);
								}
								else if ( !_.isUndefined(Utils.getValueByPath(component.prototype[prop], subprop)) ) {
									value = Utils.getValueByPath(component.prototype[prop], subprop);
								}
							}

							if ( !_.isUndefined(value) ) {
								augmentedOptions[prop][subprop] = value;
							}
						}
					} else {
						var data = mapping[prop];
						var newData = {};
						if (_.isObject(data) && !_.isUndefined(data.value) &&  _.keys(data).length === 1) {
							newData = data.value;
						} else {
							_.each(data,function(item,key) {
								newData[key] = item.value;
							});
						}
						augmentedOptions[prop] = newData;
					}
				}
				$.extend(options, augmentedOptions);
			}
		}
		if ( _.isUndefined(object.___id) ) {
			return options;
		}
		
		return getMappedOptions(object.___parent, object.___id + (path ? '.' + path : ''), component, data, options);
	};
    /**
     @private
     **/
    Utils._getVmGroupId = function (currObj){
        if ( _.isUndefined(currObj) ) {
            return function(){};
	}
        if ('getGroupId' in currObj){
            return currObj.getGroupId.bind(currObj);
        }
        return Utils._getVmGroupId(currObj.___parent);
    };

	/**
	@private
	**/
	var mapMethods = function mapMethods(targetObject, sourceObject, path) {
		if (!targetObject) {
			return;
		}
		if (targetObject.actionMap) {
			var viewActionMapping = targetObject.actionMap[path];
			if (viewActionMapping) {
				for (var action in viewActionMapping) {
					targetObject[viewActionMapping[action]] = _.bind(sourceObject[action], sourceObject);
				}
			}
		} else {
			path = targetObject.___id + (path ? '.' + path : '');
			mapMethods(targetObject.___parent, sourceObject, path);
		}
	};

	/**
	@private
	**/
	Utils.mapMethods = function(object) {
		mapMethods(object,object);
	};

	/**
	@private
	**/
	Utils.isEventSupported = (function() {
	    function isEventSupported(eventName) {
	    	var data = eventName.split(':');
	    	var el = document.createElement(data[0] || 'div');
		    eventName = 'on' + data[1];
		    var isSupported = (eventName in el);
		    if (!isSupported) {
		    	el.setAttribute(eventName, 'return;');
		        isSupported = typeof el[eventName] == 'function';
		    }
		    el = null;
		    return isSupported;
	    }
	    return isEventSupported;
	 })();

	/*
	Factory methods essential for creating hierarchical components
	*/
	Utils.Factory = {
		
		create: Utils.create,

		getChildById: function(childId) {
			return this.___children.hash[childId];
		}

	};

	/*
	Common component methods
	*/
	Utils.Common = {

        getPropertyByPrecedence: function(name, defaultValue) {
            /*
            precedence: 
            1. this.options[name]
            2. this[name]
            3. defaultValue 
            */
            var property = defaultValue;
            if( !_.isUndefined(this.options[name]) ) {
                property = this.options[name];
            }
            else if(!_.isUndefined(this[name])) {
                property = this[name];
            }
            return property;
        }		

	};

    Utils.FileUpload = {

        getXhrOptions:function(data, options){
            var fileObj = this._getFileObj(options,data);
            var formData = this._buildFormDataObj(fileObj,data);
            return _.extend({data: formData,contentType: false},options);
        },
        submitDataAsForm:function(data, options){
            var self = this;
            var jqXHR = {
                readyState: 0,
                getResponseHeader: function( key ) { return null; },
                getAllResponseHeaders: function() { return  null; },
                setRequestHeader: function( name, value ) { return this; },
                overrideMimeType: function( type ) { return this;},
                statusCode: function( map ) { return this; },
                abort: function( statusText ) { return this;}
            };
            // Attach deferreds
            var deferred = jQuery.Deferred(),
                completeDeferred = jQuery.Callbacks("once memory");
            deferred.promise( jqXHR ).complete = completeDeferred.add;
            jqXHR.success = jqXHR.done;


            var inputElem = $(this._getFileObj(options,data));
            var iframeId = inputElem.attr("id") + "_iframe";
            var iframeElm = this._createIframe(iframeId);
            var formElm = this._createForm(iframeId,inputElem,data,options);
            iframeElm.bind('load', function() {
                try {
                    var response = self._getIframeContentAsJSON(iframeId);
                    options.success(response,200,jqXHR);
                    deferred.resolveWith(this, [ response ]);
                }catch(e){
                    if (e.number === -2146828218)//"Permission denied"
                    {
                        options.error({});
                    }
                }
                formElm.remove();
                iframeElm.remove();
            });


            formElm.submit();
            return jqXHR;
        },
        /**
         * Check if the current browser support FormData object
         * @private
         * @methodOf Lightsaber.Core.Model
         * @method isFormDataSupported
         *
         */
        isFormDataSupported:function(){
            return  window.FormData;
        },
        /**
         * Check if the received object is a FormData object.
         * @private
         * @methodOf Lightsaber.Core.Model
         * @method isFormDataObj
         * @param {object} object
         */
        _isFormDataObj:function(obj){
            return this.isFormDataSupported() && obj instanceof FormData;
        },
        /**
         * Check if the received tag is an input file element.
         * @private
         * @methodOf Lightsaber.Core.Model
         * @method _isFormDataElm
         * @param {object} tag
         */
        _isFormDataElm:function(tag){
            return tag && tag.tagName &&  tag.tagName.toLowerCase() === "input" && tag.type && tag.type.toLowerCase() === "file";
        },
        /**
         * Extract the file object from the options.file attributes and if not there create from the data object.
         * @private
         * @methodOf Lightsaber.Core.Model
         * @method _getFileObj
         * @param {object} options
         * @param {object} data
         * @return {FormData/Array} The created FormData object or array of file input elements if FormData is nut supported.
         */
        _getFileObj:function(options,data){
            var fileObj = options.file;
            if (!fileObj){
                var self = this;
                $.each(data, function(key,value){
                    if (self._isFormDataObj(value)){//If we have a FormData object then someone has created it before and we don't need to parse the data properties
                        fileObj = value;
                        return false;
                    }
                    else if (self._isFormDataElm(value)){//We need to create the FormData object based on the input file elements. For IE 8/9 we create an array of input elements.
                        var inputElm = value;
                        if (self.isFormDataSupported()){
                            if (!fileObj){
                                fileObj = new FormData();
                            }
                            for (var i = 0; i < inputElm.files.length; i++) {
                                var file = inputElm.files[i];
                                fileObj.append(inputElm.name,file,file.name);
                            }
                        }
                        else{
                            if (!fileObj){
                                fileObj = new Array();
                            }
                            fileObj.push(inputElm);
                        }
                    }
                    return true;
                });
            }
            return fileObj;
        },
        /**
         * Check if we have a file object to save.
         * We switch to file save mode if one of the following options is true
         * 1) One of the model objects is of FormData object or an html input file tag.
         * 2) options.file has a FormData or an html input file tag.
         * If options.file is equal to false we don't switch to submit file mode.
         * @private
         * @methodOf Lightsaber.Core.Model
         * @method hasFileToSubmit
         * @param {object} data
         * @param {object} options
         */
        hasFileToSubmit:function(data , options){
            options = _.extend({},options);

            if (options.file === false){
                return false;
            }

            var fileMode = this._isFormDataObj(options.file) || this._isFormDataElm(options.file);
            var self = this;
            $.each(data, function(key,value){
                if (self._isFormDataObj(value) ||  self._isFormDataElm(value)){
                    fileMode = true;
                    return false;
                }
                return true;
            });
            return fileMode;
        },
        /**
         * Build a FormData object based on the received params.
         * @private
         * @methodOf Lightsaber.Core.Model
         * @method _buildFormDataObj
         * @param {object} file A FormData or a html input file tag
         * @param {object} data Key value object with extra information that need to be added to the FormData object
         * @return {FormData} The created FormData object.
         */
        _buildFormDataObj:function(formData,data){
            if (!this.isFormDataSupported() || !this._isFormDataObj(formData)){
                return null;
            }

            var addinputElmToFormDataObj = function(formData,inputElm){
                for (var i = 0; i < inputElm.files.length; i++) {
                    var file = inputElm.files[i];
                    formData.append(inputElm.name,file,file.name);
                }
            };

            var self = this;
            //Add to the FormData object all other key value params.
            $.each(data,function(key,value){
                if (!self._isFormDataElm(value) && !self._isFormDataObj(value)){
                    formData.append(key,value);
                }
            });
            return formData;
        },
        /**
         * Create an ifrmae and return a jquery element.
         * @private
         * @methodOf Lightsaber.Core.Model
         * @method _createIframe
         * @param {object} iframeId The new iframe id
         * @return {object} jQuery iframe element
         */
        _createIframe:function(iframeId){
            var iframeElm = $('<iframe id="'+iframeId+'" name="'+iframeId+'" style="display:none;">');
            iframeElm.appendTo($('body'));

            return iframeElm;
        },
        /**
         * Create a form to submit the file information.
         * @private
         * @methodOf Lightsaber.Core.Model
         * @method _createForm
         * @param {object} iframeId The iframe id
         * @param {object} inputElem a single or an array of jQuery input file element
         * @param {object} data Key value object with extra information that need to be added to the FormData object
         * @return {object} jQuery form element
         */
        _createForm:function(iframeId,inputElem,data,options){

            var formElm = $('<form method="post" enctype="multipart/form-data" action="'+options.url+'" target="'+iframeId+'" style="display:none;"></form>');
            formElm.appendTo($('body'));

            var clonedInputElm = inputElem.clone();
            inputElem.replaceWith(clonedInputElm);
            formElm.append(inputElem);
            //Add to the form element all other key value params.
            var self = this;
            $.each(data,function(key,value){
                if (!self._isFormDataElm(value)){
                    formElm.append('<input type="hidden" name="'+ key +'" value="'+ value +'" />');
                }
            });

            //Add security params.
            if (options.headers){
                $.each(options.headers,function(key,value){
                    formElm.append('<input type="hidden" name="'+ key +'" value="'+ value +'" />');
                });
            }

            return formElm;
        },
        /**
         * Convert the iframe content to a JSON object.
         * @private
         * @methodOf Lightsaber.Core.Model
         * @method _getIframeContentAsJSON
         * @param {object} iframeId The iframe id
         * @return {object} JSON object
         */
        _getIframeContentAsJSON:function(iframeId){
            var iframe = document.getElementById(iframeId);
            var doc = iframe.contentDocument ? iframe.contentDocument: iframe.contentWindow.document;
            var jsonResponse = null;
            var innerHTML = doc.body.innerHTML;
            //plain text response may be wrapped in <pre> tag
            if (doc.body.firstChild && doc.body.firstChild.nodeName.toLowerCase() == 'pre') {
                innerHTML = doc.body.firstChild.firstChild.nodeValue;
            }

            try {
                jsonResponse = JSON.parse(innerHTML);
            } catch(err){
                jsonResponse = {};
            }
            return jsonResponse;
        }
    };

    /**
     * A simple history stack,
     * @returns {{push: push, next: next, prev: prev, move: move}}
     * @constructor
     */
    Utils.HistoryStack = function(){
        var _historyArr = [];
        var _index=-1;
        return {
            push: function(data){
                if (_index < _historyArr.length-1){
                    _historyArr = _.first(_historyArr,_index);
                }
                _historyArr.push(data);
                _index = _historyArr.length-1;
            },
            next: function(){
                return this.move(1);
            },
            prev: function(){
                return this.move(-1);
            },
            move: function(amount){
                var idx = _index + amount;
                if (idx < 0 || idx >= _historyArr.length){
                    return undefined;
                }
                _index = idx;
                return _historyArr[_index];
            },
            peek: function(amount){
                var idx = _index + amount;
                if (idx < 0 || idx >= _historyArr.length){
                    return undefined;
                }
                return _historyArr[idx];
            }
        };
    };

    Utils.KO = {
        getCustomExtendedContextObservable: function(userDefinedObservable, extendedObservableFn, argsThreshold){
        	if( typeof(argsThreshold) === 'undefined')
        		argsThreshold = 2;

            var observable = function () {
                if (arguments.length >= argsThreshold){
                    return extendedObservableFn.apply(this,arguments);
                }
                else{
                    if (KO.isObservable(userDefinedObservable)){
                        if (arguments.length === 1){
                            return userDefinedObservable(arguments[0]);
                        }
                        return userDefinedObservable();
                    }
                    return userDefinedObservable;
                }
            };
            KO.utils.extend(observable, KO.observable['fn']);
            return observable;
        }
    };
	return Utils;
});



/**
Base <em>ResourceBundle</em> component.

*ResourceBundle* relies on *RequireJS* i18n plugin and it functionality to deliver the defined *bundles* (of which there 
can be several).

The *bundles* should be defined in the following folder structure (aside from `nls` the rest is customizable):

```
myBundles/nls/aBundle
myBundles/nls/root/aBundle
myBundles/nls/fr-fr/aBundle
myBundles/nls/en-us/aBundle
```

where root bundle **file** is optional, as long as the main bundle contains `root` object that serves as the root bundle.

Each bundle defines the values like this:

```javascript
define({
    'root': {
        'title': 'Hello, {0}!' 
        ...
    },
    'fr-fr': true
});
```

For more information on defining bundles, see [RequireJS documentation](http://requirejs.org/docs/api.html#i18n).

Now that bundles are defined, the *ResourceBundle* may be defined like this (this code is assumed to be in the application bootstrap
section):

```javascript
requirejs({locale: 'fr-fr'}, ['i18n!myBundles/nls/aBundle'], function(aBundle) {                
    var resourceBundle = new Lightsaber.Core.ResourceBundle({
        defaultBundle: aBundle
    }, 'defaultBundle');
});
```

and now the defined *ResourceBundle* can be passed to a *ViewModel* to use with a *View*:

```javascript
var viewModel = new Lightsaber.Core.ViewModel({
    config: {
        resourceBundle: resourceBundle
    }
});

new Lightsaber.Core.View({
    el: $root,
    viewModel: viewModel,
    config: {
        template: resources.template
    }
});
```

@class Lightsaber.Core.ResourceBundle
@namespace Lightsaber.Core
@module Lightsaber.Core
@extends Object

@since 9.0.0

@requires underscore
@requires Lightsaber.Core.Utils

@examples Lightsaber.Core.View

@constructor
**/
define('src/core/resourceBundle/ResourceBundle',[
	'underscore',
	'src/core/util/Utils'
], function(_, Utils) {

	

	var ResourceBundle = function(availableBundles, currentBundle) {
		this.availableBundles = availableBundles;
		currentBundle && (this.currentBundle = this.availableBundles[currentBundle]);
	};

	_.extend(ResourceBundle, {
		
		extend: Utils.extend
	});

	_.extend(ResourceBundle.prototype, {

		/**
		Given a string and an array of arguments, generate the string with the arguments value inserted to it.

		The following:

		```javascript
		_generateFinalString('Hello, {1} and {0}', ['Ran', 'Rama']);
		```

		would output:

		```
		Hello, Rama and Ran
		```

		@method _generateFinalString
		@protected 
		@param {String} str string use as base
		@param {Array} args array of strings to insert into placeholder inside `str`
		**/
		_generateFinalString: function(str, args) {
			var newStr = str;
			for(var i=0; i<args.length; i++) {
				newStr = newStr.replace("{" + String(i) +"}",args[i])	
			}
			
			return newStr;
		},
		
		/**
		Returns string specified by `key` from *ResourceBundle* specified by `bundleStr` with `args` inserted into numbered parameters
		@method getString
		@protected 
		@param {String} key string use as base
		@param {Array} args array of strings to insert into placeholder inside `key`
		@param {String} bundleStr name of the bundle (as it was defined on the *ResourceBundle*) to retrieve the `key` from
		**/
		getString: function(key, args, bundleStr) {
			var bundle = bundleStr ? this.availableBundles[bundleStr] : this.currentBundle;
			if (!bundle) {
				throw new Error("Current bundle is not defined");
			}
			var str = bundle[key];
			if (str && args) {
				str = this._generateFinalString(str, args);
			}
			return str;
		},

		getKeys: function(bunsleStr) {
			var bundle = bundleStr ? this.availableBundles[bundleStr] : this.currentBundle;
			if (!bundle) {
				throw new Error("Current bundle is not defined");
			}
			return _.keys(bundle);
		},

		getValues: function(bunsleStr) {
			var bundle = bundleStr ? this.availableBundles[bundleStr] : this.currentBundle;
			if (!bundle) {
				throw new Error("Current bundle is not defined");
			}
			return _.values(bundle);
		},
        
        create: Utils.create
	});
	

	return ResourceBundle;
});



/**
Base Core <em>Data Source</em> component. Is overridden by all other *DataSource* components.

The *DataSource* component is not intended to be instantiated directly, rather used as a base by extending 
*DataSource* components - for example: {{#crossLink "Lightsaber.Core.RESTDataSource"}}{{/crossLink}}.

The main purpose of a *DataSource* is to abstract away specific details of *Model* - *BE System* integration, like *REST Server*
or *Local Storage* - using *CRUD* interface. It is connected (embedded) to 
{{#crossLink "Lightsaber.Core.DataSource"}}{{/crossLink}}.

@class Lightsaber.Core.DataSource
@namespace Lightsaber.Core
@module Lightsaber.Core
@extends Object

@since 9.0.0
@access protected

@requires underscore
@requires backbone
@requires Lightsaber.Core.Utils

@examples Lightsaber.Core.Model

@constructor
@param {Object} [options] configuration object
**/
define('src/core/dataSource/DataSource',[
    'underscore',
    'backbone',
    'src/core/util/Utils'
], function(_, Backbone, Utils) {

    

    var DataSource = function(options) {
        var context = this;

        /**
        Main synchronization method that redirects to Model's one.

        @method sync
        @param {String} method CRUD method
        @param {Model} model model that the data source is applied to
        @param {Object} options contains callbacks and additional parameters
        @return {...} result of the Model's `sync` method
        **/
        this.sync = this.sync || function(method, model, options) {
            return context[method].call(context, model, options);
        };
        _.bindAll(this, 'mapModel');
        this.initialize(options);
    };

    /**
    Creation method.

    @method create
    @param {Model} model model that the data source is applied to
    @param {Object} options contains callbacks and additional parameters
    @return {...} result of the Model's `sync` method
    **/
    /**
    Read method.

    @method read
    @param {Model} model model that the data source is applied to
    @param {Object} options contains callbacks and additional parameters
    @return {...} result of the Model's `sync` method
    **/
    /**
    Update method.

    @method update
    @param {Model} model model that the data source is applied to
    @param {Object} options contains callbacks and additional parameters
    @return {...} result of the Model's `sync` method
    **/
    /**
    Deletion method.

    @method delete
    @param {Model} model model that the data source is applied to
    @param {Object} options contains callbacks and additional parameters
    @return {...} result of the Model's `sync` method
    **/
    var defaultCRUD = {};
    _.each(["create", "read", "update", "delete"], function(method) {
        defaultCRUD[method] = function(model, options) {
            return Backbone.sync.call(this, method, model, options);
        };
    });

    _.extend(DataSource, {      
        extend: Utils.extend
    });

    _.extend(DataSource.prototype, Backbone.Events, defaultCRUD, {

        /**
        No-op.

        Main-entry method.

        @method initialize
        @protected
        **/
        initialize: function(options){},
            
        /**
        Returns the {{#crossLink "Lightsaber.Core.DataSource/sync:method"}}{{/crossLink}} method of the *DataSource*.

        @method getSync
        @return {Function} {{#crossLink "Lightsaber.Core.DataSource/sync:method"}}{{/crossLink}} method of the *DataSource*
        **/
        getSync: function() {
            return this.sync;
        },
        
        /**
        Default opitions for {{#crossLink "Lightsaber.Core.DataSource/prepareOptions:method"}}{{/crossLink}} method.

        @property {Object} defaults
        @default `{}`

        **/
        defaults: {},

        /**
        Prepares configuration options to pass to {{#crossLink "Lightsaber.Core.Model/setDataSource:method"}}{{/crossLink}} method
        of the *Model*.

        By default configuration options contain the reference to 
        {{#crossLink "Lightsaber.Core.DataSource/mapModel:method"}}{{/crossLink}} method and whatever 
        is contained in {{#crossLink "Lightsaber.Core.DataSource/defaults:property"}}{{/crossLink}} property.
        
        @method prepareOptions
        @param {Object} options configuration options to be passed to {{#crossLink "Lightsaber.Core.Model/setDataSource:method"}}{{/crossLink}} method of the *Model*
        @return {Ojbect} prepared options
        **/
        prepareOptions: function(options) {
            return _.extend({}, { mapModel: this.mapModel }, this.defaults, options || {});
        },
        
        /**
        Mapping of the attributes that is used by {{#crossLink "Lightsaber.Core.DataSource/mapModel:method"}}{{/crossLink}} method.
        
        Default mapping says to swaps values of `id` and `orig_id` attributes. The following example defines that
        the value of `middle` attribute should be moved to `center` attribute and `left` and `right` attributes should
        be swapped:

        ```json
        {
            middle: 'center',
            right: 'left',
            left: 'right'
        }
        ```

        @property {Object} attrMap
        @protected
        @default `{id: 'orig_id', orig_id: 'id'}`
        **/
        attrMap: {id: 'orig_id', orig_id: 'id'},

        /**
        Modifies model when it switches *DataSource*.

        By default it maps model attribute values to other attributes according to mapping defined in {{#crossLink "Lightsaber.Core.DataSource/attrMap:property"}}{{/crossLink}} property.

        Note that {{#crossLink "Lightsaber.Core.DataSource/prepareOptions:method"}}{{/crossLink}} method should be used to provide
        this method as option to {{#crossLink "Lightsaber.Core.Model/setDataSource:method"}}{{/crossLink}} method.
        
        @method mapModel
        @param {Lightsaber.Core.Model} model
        **/
        mapModel: function(model) {
            var oldAttrs = {}, newAttrs = {}, value;
            for (var name in this.attrMap) {
                if (model.has(name)) {
                    newAttrs[this.attrMap[name]] = model.get(name);
                    oldAttrs[name] = undefined;
                }
            }
            model.set(oldAttrs, { silent: true, unset: true });
            model.set(newAttrs/*, { silent: true }*/);
        },

        /**
        Returns the properties of the *DataSource*.

        @method getProperties
        @return {Object} *DataSource* properties with default value of
        ___
        ```javascript
        { 
            supportsPagination: false,
            supportsSorting: false,
            supportsFiltering: false 
        }
        ```
        **/
        getProperties: function() {
            return { supportsPagination: false,
                supportsSorting: false,
                supportsFiltering: false };
        },

        create: Utils.create
    });

    return DataSource;
});



define('src/core/util/StorageUtil',[
	'jquery', 
	'underscore'
], function($, _) {
	
	
	
	/**
	UXF <em>Local Storage</em> component.

	Can be retrieved for usage with: 

	```javascript
	var LocalStorage = Lightsaber.Core.StorageUtil.getStorage('local');
	```

	@class LocalStorage
	@extends Object

	@since 9.0.0

	@static
	**/
	var LocalStorage = {
		
		/**
		Retrieves value from *Storage* by the provided `key`

		@method get
		@param {String} key key
		@return {...} value that corresponds to the provided `key`
		**/
		get: function(key) {
			return deserialize( this._s[key] );
		},

		/**
		Stores the provided `value` under the provided `key`.

		@methodOf Lightsaber.Core.StorageUtil
		@name set
		@param {String} key key
		@param {Object} value value to store
		**/
		set: function(key, value) {
			this._s[key] = serialize(value);
		},

		/**
		Deletes a single or multiple keys.

		@method deleteKey
		@param {Array|String|undefined} [key] key(s) to be deleted
		 
		* undefined - all keys are deleted
		* Array - all keys in the array are deleted
		* String - specific key is deleted
		**/
		deleteKey: function(key) {
			if (!key)
				key = this.getKeys();
			else if (!_.isArray(key))
				key = [key];
			
			_.each( key, function(k) {
				this._s.removeItem(k);
			}, this);
		},
		
		/**
		Returns an array of all keys in the *Storage*.

		@method getKeys
		@returns {Array} all keys in the *Storage*
		**/
		getKeys: function() {
			return _.keys(this._s);
		},

		/**
		Returns the type of the *Storage*.
		@method getStorageType
		@returns {String} returns `'local'`
		**/
		getStorageType: function() {
			return 'local';
		}, 
		
		/**
		@private
		**/
		_isAvailable: function() {
			return typeof(Storage)!=="undefined";
		}, 
		
		_s: window.localStorage
	};
	
	/**
	UXF <em>Session Storage</em> component.

	Can be retrieved for usage with: 

	```javascript
	var SessionStorage = Lightsaber.Core.StorageUtil.getStorage('session');
	```

	@class SessionStorage
	@extends LocalStorage

	@since 9.0.0

	@static
	**/
	var SessionStorage = _.defaults({

		/**
		Returns the type of the storage.
		@method getStorageType
		@returns {String} returns `'session'`
		**/
		getStorageType: function() {
			return 'session';
		}, 

		_s: window.sessionStorage

	}, LocalStorage );

	/**
	UXF <em>Memory Storage</em> component.

	Can be retrieved for usage with: 

	```javascript
	var SessionStorage = Lightsaber.Core.StorageUtil.getStorage('memory');
	```

	@class Memory
	@extends LocalStorage

	@since 9.0.0

	@static
	**/
	var Memory = _.defaults({

		/**
		Returns the type of the storage.
		@method getStorageType
		@returns {String} returns `'memory'`
		**/
		getStorageType: function() {
			return 'memory';
		},
		
		/**
		@private
		**/
		_isAvailable: function() {
			return true;
		},
		
		_s: {}

	}, LocalStorage );

	/**
	UXF <em>Session Cookie</em> component.

	Can be retrieved for usage with: 

	```javascript
	var SessionStorage = Lightsaber.Core.StorageUtil.getStorage('securedSessionCookie');
	```

	@class SessionCookie
	@extends Object

	@since 9.0.0

	@static
	**/
	var SessionCookie = {

		/**
		Retrieves value from *Storage* by the provided `key`

		@method get
		@param {String} key key
		@return {...} value that corresponds to the provided `key`
		**/
		get: function(key) {
			return deserialize( getCookie( key, this.isPersistent) );
		},

		/**
		Stores the provided `value` under the provided `key`.

		@methodOf Lightsaber.Core.StorageUtil
		@name set
		@param {String} key key
		@param {Object} value value to store
		**/
		set: function(key, value) {
			setCookie( key, serialize(value), this.isPersistent );
		},

		/**
		Deletes the provided `key` from *Storage*.

		@method deleteKey
		@param {Array|String|undefined} [key] key(s) to be deleted
		 
		* undefined - all keys are deleted
		* Array - all keys in the array are deleted
		* String - specific key is deleted
		**/
		deleteKey: function(key) {
			deleteCookie( key, this.isPersistent );
		},
		
		/**
		Returns an array of all keys in the *Storage*.

		@method getKeys
		@returns {Array} all keys in the storage
		**/
		getKeys: function() {
			return getCookiesKeys( this.isPersistent);
		},

		/**
		Returns the type of the *Storage*.

		@method getStorageType
		@returns {String} returns `'securedSessionCookie'`
		**/
		getStorageType: function() {
			return 'securedSessionCookie';
		}, 
		
		_isAvailable: function() {
			return true;
		}
	};

	/**
	UXF <em>Persistent Cookie</em> component.

	Can be retrieved for usage with: 

	```javascript
	var SessionStorage = Lightsaber.Core.StorageUtil.getStorage('securedPersistentCookie');
	```

	@class PersistentCookie
	@extends SessionCookie

	@since 9.0.0

	@static
	**/
	var PersistentCookie = _.defaults({
		/**
		Indicates wether the *Storage* is persistent.

		@property [isPersistent=true]
		**/
		isPersistent: true, 
		
		/**
		Returns the type of the *Storage*.

		@method getStorageType
		@returns {String} returns `'securedPersistentCookie'`
		**/
		getStorageType: function() {
			return 'securedPersistentCookie';
		}
	}, SessionCookie);
	
	/**
	Base <em>StorageUtil</em> component.

	Provides a set of convinience methods over persistent local browser storage: *Local*, *Session*,
	*Session Cookies* or *Persistent Cookies*.

	In order to use one of the storage types {{#crossLink "Lightsaber.Core.StorageUtil/getStorage:method"}}{{/crossLink}} is used:

	```javascript
	var SessionStorage = Lightsaber.Core.StorageUtil.getStorage('session');
	```

	The available types of storage are:

	* {{#crossLink "LocalStorage"}}{{/crossLink}}
	* {{#crossLink "SessionStorage"}}{{/crossLink}}
	* {{#crossLink "Memory"}}{{/crossLink}}
	* {{#crossLink "SessionCookie"}}{{/crossLink}}
	* {{#crossLink "PersistentCookie"}}{{/crossLink}}

	@class Lightsaber.Core.StorageUtil
	@namespace Lightsaber.Core
	@module Lightsaber.Core
	@extends Object

	@since 9.0.0

	@requires jquery
	@requires underscore

	@examples Lightsaber.Core.Utils

	@static
	**/
	var StorageUtil = {
			
		/**
		Defines logical names for types of storage.

		@private
		**/
		_storageObjects: {
			memory: { storage: Memory },
			session: { storage: SessionStorage },
			local: { storage: LocalStorage },
			securedSessionCookie: { storage: SessionCookie },
			securedPersistentCookie: { storage: PersistentCookie }
		},
		
		/**
		
		*Storage Utils* factory method.

		@method getStorage
		@param {String} storageType one of `'session'`, `'local'`, `'securedSessionCookie'`, `'securedPersistentCookie'`, `'memory'`
		@param {Object} [options] retrieval options
		@param {Object} [options.fallback] indicates which storage to use as fallback for cases of failure upon retrieval
		**/
		getStorage: function( storageType, options ) {
			if ( !_.isString(storageType) ) {
				options = storageType;
				storageType = 'session';
			}
			var fallbackType = options && options.fallback || 'memory';
			
			if (!this._storageObjects[storageType])
				throw 'Storage type ' + storageType + ' is not supported';
			
			if ( _.isUndefined( this._storageObjects[storageType].isAvailable ) )
				this._storageObjects[storageType].isAvailable = this._storageObjects[storageType].storage._isAvailable();

			if ( this._storageObjects[storageType].isAvailable )
				return this._storageObjects[storageType].storage;
			else 
				return this.getStorage( fallbackType );
		},
		
		/**
		@private
		**/
		setTestingMode: function( testingMode ) {
			this.testingMode = testingMode;
		},
		
		/**
		For backward compatibility only.

		@deprecated
		@private
		**/
		get: function(key) {
			return this.getStorage().get(key);
		},

		/**
		For backward compatibility only.

		@deprecated
		@private
		**/
		set: function(key, value) {
			return this.getStorage().set(key, value);
		},

		/**
		For backward compatibility only.

		@deprecated
		@private
		**/
		deleteKey: function(key) {
			return this.getStorage().deleteKey(key);
		},

		/**
		For backward compatibility only.

		@deprecated
		@private
		**/
		getKeys: function() {
			return this.getStorage().getKeys();
		},
		
		/**
		For backward compatibility only.

		@deprecated
		@private
		**/
		getStorageType: function() {
			return this.getStorage().getStorageType();
		}
	};

	/**
	@private
	**/
	var serialize = function(value) {
		value = JSON.stringify(value);
		return value;
	};

	/**
	private
	**/
	var deserialize = function(value) {
		if (value === 'undefined')
			value = undefined;
		else if ( _.isString(value) )
			value = JSON.parse( value );
		
		return value;
	};

	/**
	@private
	**/
	var setCookie = function( name, value, isPersistent )	{
		var cookie = (isPersistent?'p':'s') + name + "=" + escape( value );
		if ( isPersistent ) {
			var expires = new Date ();
			expires.setFullYear( expires.getFullYear() + 1 );
			cookie += ";expires=" + expires.toUTCString();
		}
		if (!StorageUtil.testingMode)
			cookie += ";secure";

		document.cookie = cookie;
	};

	/**
	@private
	**/
	var getCookie = function( name, isPersistent ) {
		var results = document.cookie.match ( '(?:^|;) *' + (isPersistent?'p':'s') + name + '=([^;]*)(?:;|$)' );

		if ( results )
			return ( unescape ( results[1] ) );
	};
	
	/**
	@private
	**/
	var getCookiesKeys = function( isPersistent ) {
		var regex = isPersistent? (/\bp[^;=\s]+(?:(?==))/g) : (/\bs[^;=\s]+(?:(?==))/g) ;
		var keys = _.map( document.cookie.match( regex ), function(k) {
			return k.slice(1);
		});
		
		return keys;
	};
	
	/**
	@private
	**/
	var deleteCookie = function( name, isPersistent )	{
		var date = new Date(0).toUTCString();
		if (!name)
			name = getCookiesKeys(isPersistent);
		else if (!_.isArray(name))
			name = [name];
		
		_.each( name, function(n) {
			document.cookie = (isPersistent?'p':'s') + n + "=; expires=" + date;
		});
	};

	return StorageUtil;

});

/**
<em>Local Storage Detached Data Source</em> component. Provides <em>Local Storage</em> abstraction for <em>Models</em>.

```javascript
var storage = new Lightsaber.Core.LocalStorageDataSource();
var model = new Lightsaber.Core.Model();
model.setDataSource(storage);
```

@class Lightsaber.Core.LocalStorageDataSource
@namespace Lightsaber.Core
@module Lightsaber.Core
@extends Lightsaber.Core.DetachedDataSource

@since 9.0.0

@requires jquery
@requires Lightsaber.Core.StorageUtils
@requires Lightsaber.Core.DataSource
@requires Lightsaber.Core.Utils

@examples Lightsaber.Core.Model

@constructor
@param {Object} [options] configuration object
**/
define('src/core/dataSource/LocalStorageDataSource',[ 
	'jquery', 
	'src/core/util/StorageUtil', 
	'src/core/dataSource/DataSource', 
	'src/core/util/Utils' 
], function($, StorageUtil, DataSource, Utils)		{

	var LocalStorageDataSource = DataSource.extend({
		
		_delimiter : '/',
		_pathRegEx : /^[/][\w-_.~/]*$/,

		/**
		This method creates and saves a new value in the local storage.

		@method create 
		@param {Lightsaber.Core.Model} model model to be saved
		@param {Object} options main configuration parameter       	
		@param {Function} [options.success] `success` callback
		@param {Function} [options.error] `error` callback
		@param {String} [options.url] url
		@param {String} [options.id] id
		@return {Boolean} whether the operation was successfull
		**/
		create : function(model, options) {
			var url = (options && options.url) || getValue( model, 'url');

			if (!url || !this._pathRegEx.test(url))	{
				if (_.isFunction( options.error ))
					options.error( 'URL is mandatory and restricted to URL scheme');
				return failed;
			}

			var id = model.id || options.id || Utils.guid();
			if (!model.id)
				model.set( model.idAttribute, id);

			this._addToUrl( url, id);
			var modelData = model.toJSON();
			this.storage.set( url + this._delimiter + id, modelData);
			
			if (_.isFunction( options.success ))
				options.success( modelData, 'OK' );
			return succeeded;
		},

		/**
		Returns the value for a given `id`, or its children as array if `id` is `null`/`undefined`/empty.
		
		@method read 
		@param {Lightsaber.Core.Model} model model to be read
		@param {Object} options main configuration parameter       	
		@param {Function} [options.success] `success` callback
		@param {Function} [options.error] `error` callback
		@param {String} [options.url] url
		@param {String} [options.id] id
		@return {Boolean} whether the operation was successfull
		**/
		read : function(model, options)	{
			var returnedValue = succeeded;
			var url = (options && options.url) || getValue( model, 'url');

			var result, errorMsg;
			if (url && this._pathRegEx.test(url))	{
				
				if ( !options.id && !model.id) 
					result = this._readAll(url);
				else {
					var key = model.id? url: url + this._delimiter + options.id;
					result = this.storage.get(key);							
				}
				
				if (!result)
					errorMsg = 'not found';
			}
			else 
				errorMsg = 'URL is mandatory and restricted to URL scheme';


			if (errorMsg) {
				if (_.isFunction( options.error ))
					options.error( errorMsg);
				returnedValue = failed;
			}
			else
				if (_.isFunction( options.success ))
					options.success( result, 'OK');
			
			return returnedValue;
		},

		/**
		Overrides an existing model with a newer one. If the model does not exist, it will
		create a new one.
		
		@method update 
		@param {Lightsaber.Core.Model} model model to be updated
		@param {Object} options main configuration parameter       	
		@param {Function} [options.success] `success` callback
		@param {Function} [options.error] `error` callback
		@return {Boolean} whether the operation was successfull
		**/
		update : function(model, options)	{
			var url = (options && options.url) || getValue( model, 'url');

			if (!url || !this._pathRegEx.test(url))	{
				if (_.isFunction( options.error ))
					options.error( 'URL is mandatory and restricted to URL scheme' );
				return failed;
			}

			var modelData = model.toJSON();
			this.storage.set( url, modelData);
			
			if (_.isFunction( options.success ))
				options.success( modelData, 'OK');
			return succeeded;
		},

		/**
		Deletes the model from  *Local Storage*.
		
		@method delete 
		@param {Lightsaber.Core.Model} model model to be deleted
		@param {Object} options main configuration parameter       	
		@param {Function} [options.success] `success` callback
		@param {Function} [options.error] `error` callback
		@return {Boolean} whether the operation was successfull
		**/
		'delete' : function( model, options )	{
			var url = (options && options.url) || getValue( model, 'url');
			
			if (url && this._pathRegEx.test(url)) {
				
				var index = url.lastIndexOf(this._delimiter);
				var parentUrl = url.substring(0, index);
				var parentId = url.substring(index+1);
				var parent = this.storage.get(parentUrl);
				
				if (!parent.children[parentId] && options && _.isFunction(options.error)) {
					options.error( 'not found');
					return failed;
				}
				delete parent.children[parentId]
				this.storage.set(parentUrl, parent);
				
				this.storage.deleteKey(url);
				if (options && _.isFunction(options.success)) {
					options.success();
				}
				return succeeded;
			}
			else
				return failed;
		},

		/**
		Returns the number of items of under a specific namespace in *Local Storage*.
		
		@method localStorageSize 
		@param {String} namespaceKey url of namespace to measure
		@returns {Number} number of items
		 */
		localStorageSize: function( namespaceKey)	{
			var storage = this.storage.get(namespaceKey);
			return storage && storage.children && _.size( storage.children );
		},
		
		/**
		This function ensures the url exists and adds the id to it
		
		@private
		@param {String} url full url to build
		@param {String} id id to add
		 */
		_addToUrl : function(url, id) {
			if (!url)
				url = this._delimiter;
			
			var node = this.storage.get(url);

			if (!node) {
				if (url !== this._delimiter) { 
					var index = url.lastIndexOf(this._delimiter);
					var parentUrl = url.substring(0, index);
					var parentId = url.substring(index+1);
					this._addToUrl( parentUrl, parentId);
				}
				node = { children: {} }; 
			}
			else if (!node.children) {
				node.children = {};
			}
			
			if (!node.children[id]) {
				node.children[id] = true;
				this.storage.set(url, node);
			}
		},

		/**
		@private
		This function returns the children of the url
		
		@returns {Array} An Array with all the model's attributes.
		 */
		_readAll: function( url ) {
			var results = null;
			var node = this.storage.get( url );

			if (node && node.children && !_.isEmpty(node.children) ) {
				results = [];
				for ( var id in node.children) {
					var son = this.storage.get( url + this._delimiter + id );
					if (son) {
						delete son.children;
						results.push(son);
					}
				}
			}
			
			return results;
		}


	});

	/**
	@private
	**/
	var getValue = function(object, prop) {
		if (!(object && object[prop])) return null;
		return _.isFunction(object[prop]) ? object[prop]() : object[prop];
	};
	
	/**
	@private
	**/
	var failed = $.Deferred().reject().promise();

	/**
	@private
	**/
	var succeeded = $.Deferred().resolve().promise();
	
	_.each( [failed, succeeded], function(e) {
		_.extend( e, {abort:function(){}, readyState:4} );
	});

	LocalStorageDataSource.prototype.storage = StorageUtil.getStorage('local');
	return LocalStorageDataSource;
});
/**
Core <em>Validator</em> component, that defines a set of built-validations. 

@class Lightsaber.Core.Validator
@namespace Lightsaber.Core
@module Lightsaber.Core
@extends Object

@since 9.0.0

@requires Lightsaber.Core.Utils
@requires Lightsaber.Core.Configuration
@requires Lightsaber.Core.DateFormatter

@constructor
**/
define('src/core/model/Validator',['underscore', 'backbone', 'src/core/util/Utils'],   function(_, Backbone, Utils) {

    

    
    var Validator = function() {
    };

    
    /**
    Checks if a *Model*'s attribute is defined.

    @method defined
    @param {String} conf configuration parameter.
    @param {String} conf.fieldName name of the attribute to check
    **/
    Validator.prototype.defined = function(conf, attrs, model) {
        this.checkConf(['fieldName'], conf);
        var val = this.getFieldValue('fieldName', conf, attrs, model);
        if (_.isUndefined(val)) {
            return this.makeErrorObject( conf, "value for '" + conf.fieldName + "' should be defined", conf.fieldName, val);
        }
    };

    /**
    Checks if a model's attribute is not empty; Can be used for Object, String and Array.
    @method notEmpty
    @param {String}  conf.fieldName  The name of the attribute to check.
    **/
    Validator.prototype.notEmpty = function(conf, attrs, model) {
        this.checkConf(['fieldName'], conf);
        var val = this.getFieldValue('fieldName', conf, attrs, model);
        if (_.isEmpty(val)) {
            return this.makeErrorObject( conf, "value for '" + conf.fieldName + "' should not be empty", conf.fieldName, val);
        }
    };

    /**
    Checks if a model's attribute is of a specified type.
    @method type
    @param {String}  conf.fieldName    The name of the attribute to check.
    @param {String}  conf.type         One of the following: number, string, boolean, function or object
    **/
    Validator.prototype.type = function(conf, attrs, model) {
        this.checkConf(['fieldName', 'type'], conf);
        var val = this.getFieldValue('fieldName', conf, attrs, model);
        var type = typeof(val);
        if ( !_.isUndefined(val) && type !== conf.type) {
            return this.makeErrorObject( conf, conf.fieldName + "'s type should be " + conf.type + ', was ' + type, conf.fieldName, val);
        }
    };

    /**
    Checks if a model's attribute is less than another attribute, if exist.

    @method lessThan
    @param {String}  conf.field1Name   The name of a number attribute.
    @param {String}  conf.field2Name   The name of a number attribute.
    **/
    Validator.prototype.lessThan = function(conf, attrs, model) {
        this.checkConf(['field1Name', 'field2Name'], conf);
        var val1 = this.getFieldValue('field1Name', conf, attrs, model);
        if ( _.isUndefined(val1) ) {
            return;
        }
        var num1 = Number(val1);
        if (isNaN(num1)) {
            return this.makeErrorObject( conf, conf.field1Name + '('+val1+')' + ' should be a number', conf.field1Name, val1);
        }
        var val2 = this.getFieldValue('field2Name', conf, attrs, model);
        if ( _.isUndefined(val2) ) {
            return;
        }
        var num2 = Number(val2);
        if (isNaN(num2)) {
            return this.makeErrorObject( conf, conf.field2Name + '('+val2+')' + ' should be a number', conf.field2Name, val2);
        }
        if (num1 >= num2) {
            return this.makeErrorObject( conf, conf.field1Name + '('+num1+')' + ' should be less than ' + conf.field2Name + '('+num2+')', conf.field1Name, val1, conf.field2Name, val2);
        }
    };
    
    /**
    Checks if the length of a model's string attribute is less than a given number, if exist.

    
    @method minLength
    @param {String}  conf.fieldName  The name of a string attribute.
    @param {Number}  conf.min        The min value
    @deprecated since version 9.1.0, use Validator.prototype.length funtion instead
    **/
    Validator.prototype.minLength = function( conf, attrs, model) {
        this.checkConf(['fieldName', 'min'], conf);
        var val = this.getFieldValue('fieldName', conf, attrs, model);
        if ( _.isUndefined(val) )
                                        return;
        if ( !_.isString(val)  ||  val.length < conf.min ) {
                                        return this.makeErrorObject( conf, conf.fieldName + "'s length should not be less than " + conf.min + ', was >' + val + '<', conf.fieldName, val);
        }
    };

    /**
    Checks if the length of a model's string attribute is within a specified range, if exist.

    @method length
    @param {String}  conf.fieldName  The name of a string attribute.
    @param {Number}  [conf.max]        The max length
    @param {Number}  [conf.min]        The min length
    **/
    Validator.prototype.length = function( conf, attrs, model) {
                    this.checkConf(['fieldName'], conf);
                    var val = this.getFieldValue('fieldName', conf, attrs, model);
                    if ( _.isUndefined(val) )
                            return;
                        
                    if ( !_.isString(val) ) {
                        return this.makeErrorObject( conf, conf.fieldName + " should be a string", conf.fieldName, val);
                    }
                    else if ( val.length > conf.max ) {
                        return this.makeErrorObject( conf, conf.fieldName + "'s length should not be longer than " + conf.max + ', was >' + val + '<', conf.fieldName, val);
                    }
                    if ( val.length < conf.min ) {
                        return this.makeErrorObject( conf, conf.fieldName + "'s length should not be shorter than " + conf.min + ', was >' + val + '<', conf.fieldName, val);
                    }
    };

    /**
    Checks if the length of a model's string attribute is less or equal to a given number, if exist.

    @method maxLength
    @param {String}  conf.fieldName  The name of a string attribute.
    @param {Number}  conf.max        The max value
    @deprecated since version 9.1.0, use Validator.prototype.length funtion instead
    **/
    Validator.prototype.maxLength = function( conf, attrs, model) {
                    this.checkConf(['fieldName', 'max'], conf);
                    var val = this.getFieldValue('fieldName', conf, attrs, model);
                    if ( _.isUndefined(val) )
                            return;
                        
                    if ( !_.isString(val)  ||  val.length > conf.max ) {
                        return this.makeErrorObject( conf, conf.fieldName + "'s length should not be longer than " + conf.max + ', was >' + val + '<', conf.fieldName, val);
                    }
    };

    /**
    Checks if a model's number attribute is at least a given number, if exist.
    @method min
    @param {String}  conf.fieldName  The name of a number attribute.
    @param {Number}  conf.min        The min value
    **/
    Validator.prototype.min = function( conf, attrs, model) {
                    this.checkConf(['fieldName', 'min'], conf);
                    var val = this.getFieldValue('fieldName', conf, attrs, model);
                    if ( _.isUndefined(val) )
                            return;
                        
                    if ( isNaN(val) || val < conf.min) {
                        return this.makeErrorObject( conf, conf.fieldName + " should be at least " + conf.min + ', was >' + val + '<', conf.fieldName, val);
                    }
    };

    /**
    Checks if a model's number attribute is less than a given number, if exist.

    @method max
    @param {String}  conf.fieldName  The name of a number attribute.
    @param {Number}  conf.max        The max value
    **/
    Validator.prototype.max = function( conf, attrs, model) {
                    this.checkConf(['fieldName', 'max'], conf);
                    var val = this.getFieldValue('fieldName', conf, attrs, model);
                    if ( _.isUndefined(val) )
                            return;

                    if ( isNaN(val) || val > conf.max) {
                        return this.makeErrorObject( conf, conf.fieldName + " should be at most " + conf.max + ', was >' + val + '<', conf.fieldName, val);
                    }
    };
    
    /**
    Checks if a model's string attribute conforms to a regular expression pattern.

    @method regExp
    @param {String}              conf.fieldName      The name of a string attribute.
    @param {String or RegExp}    conf.pattern        The regular expression or backslash escaped string
    @param {boolean}             [conf.not]          If true then the validation fails when the pattern matches
    @param {String}              [conf.modifiers]    In case the pattern is a string, the regular expression's modifiers
    **/
    Validator.prototype.regExp = function( conf, attrs, model) {
        this.checkConf(['fieldName', 'pattern'], conf);
        var val = this.getFieldValue('fieldName', conf, attrs, model);
        if ( ! (conf.pattern instanceof RegExp) ) 
            conf.pattern = new RegExp( conf.pattern, conf.modifiers);

        if ( !conf.pattern.test( val ) == !conf.not ) {
            return this.makeErrorObject( conf, conf.fieldName + ' does not match "' + conf.pattern.source + '"', conf.fieldName, val);
        }
    };

    
    /**
    Negates the result of another validation.

    @method not
    @param {String}  conf.op  A validation to negate.
    @param {Array}  [conf.fieldNames]  the involved fields' names
    **/
    Validator.prototype.not = function( conf, attrs, model) {
        this.checkConf(['op'], conf);
        var val = this[conf.op.check]( conf.op, attrs, model );

        return val? undefined : this.makeErrorObject.apply( this, this.makeArgs(conf, 'NOT has failed', attrs));
    };

    /**
    Boolean AND between two other validations.

    @method and
    @param {String}  conf.op1  A validation.
    @param {String}  conf.op2  A validation.
    @param {Array}  [conf.fieldNames]  the involved fields' names
    **/
    Validator.prototype.and = function( conf, attrs, model) {
        this.checkConf(['op1','op2'], conf);
        var val1 = this[conf.op1.check]( conf.op1, attrs, model );
        var val2 = this[conf.op2.check]( conf.op2, attrs, model );

        return (!val1 && !val2)? undefined : this.makeErrorObject.apply( this, this.makeArgs(conf, 'AND has failed', attrs));
    };


    /**
    Boolean OR between two other validations.

    @method or
    @param {String}  conf.op1  A validation.
    @param {String}  conf.op2  A validation.
    @param {Array}  [conf.fieldNames]  the involved fields' names
    **/
    Validator.prototype.or = function( conf, attrs, model) {
        this.checkConf(['op1','op2'], conf);
        var val1 = this[conf.op1.check]( conf.op1, attrs, model );
        var val2 = this[conf.op2.check]( conf.op2, attrs, model );

        return (!val1 || !val2)? undefined : this.makeErrorObject.apply( this, this.makeArgs(conf, 'OR has failed', attrs));
    };
    
    /** @private **/
    Validator.prototype.checkConf = function( confAttrs, conf) {
            for( var i in confAttrs) {
                    if (_.isUndefined(conf[confAttrs[i]])) {
                            throw "configuration attribute '" + confAttrs[i] + "' was not found for validation '" + conf.check + "'";
                    }
            }
    };

    /** @private **/
    Validator.prototype.getFieldValue = function(field, conf, attrs, model) {
        var fieldName = conf[field];
        var segs = fieldName.split('.');
        return _.reduce( segs, function(memo, seg) { return memo? memo[seg]: undefined; }, attrs );
    };

    /** @private **/
    Validator.prototype.makeArgs = function( conf, errorMsg, attrs) {
        var args = [ conf, errorMsg ];
        var f;
        for (f in conf.fieldNames) {
            args.push( conf.fieldNames[f]);
            args.push(attrs[conf.fieldNames[f]]);
        }
        return args;
    };

    /** 
    @private
    @deprecated since 9.00
    **/
    Validator.prototype.makeError = function( errorCode, errorMsg, fieldName, value) {
        var attrs = {};
        for (var i = 2; i < arguments.length; i+=2) {
            attrs[ arguments[i] ] =  arguments[i+1];
        }
        return { source: 'validation', status: 'lightsaber.core.'+errorCode ,statusText: errorMsg, attrs: attrs};
    };

    /** @private **/
    Validator.prototype.makeErrorObject = function( conf, errorMsg, fieldName, value) {
        var attrs = {};
        for (var i = 2; i < arguments.length; i+=2) {
            attrs[ arguments[i] ] =  arguments[i+1];
        }
        var status = conf.status? conf.status: 'lightsaber.core.'+conf.check;
        return { source: 'validation', status:status ,statusText: errorMsg, attrs: attrs, conf: conf};
    };

    Validator.extend = Utils.extend;
    return Validator;
});

/**
Global <em>ErrorHandler</em> component.

The global error handler that is called whenever an error occurs during a model's CRUD operation for 
which no ad-hoc error handler was specified.

Out of the box implementation is empty and can be replaced by applications. In that handler the application
should be registered since **application is dependent on the handler**.

@class Lightsaber.Core.ErrorHandler
@namespace Lightsaber.Core
@module Lightsaber.Core
@extends Object

@since 9.0.0

@requires underscore
@requires backbone
@requires Lighstaber.Core.Utils

@constructor
**/
define('src/core/model/ErrorHandler',[
    'underscore', 
    'backbone', 
    'src/core/util/Utils'], function(_, Backbone, Utils) {

    

    var ErrorHandler  = function() {};
    
    /**
    Handles the error.
    
    @method handleError
    @param {Model} model *Model's* name
    @param {Object} response  response as it was passed to a *Model's* handler methods
    @param {Object} [options] object that was passed to the CRUD method
    **/
    ErrorHandler.handleError = function( model, response, options) {
    	ErrorHandler.lastResponse = response;
    };

    ErrorHandler.extend = Utils.extend;
    ErrorHandler.prototype.create = Utils.create;

    return ErrorHandler;
});

/**
 The Lightsaber's Model class extends Backbone.Model. <br/>
 Adds the following features: declarative validation,
 structured model and detachable data source.

 ## Example

 ```html
 var Data = Model.extend({
            LSKey:'Data',
            defaults: {  first:'hello', second:'world' },
            validations: [  {check:'maxLength', fieldName:'second',
                             max:5, invar:true} ]
});
 var data = new Data( {third:'now'}, {
        url:'employee'
} );
 ```

 @class Lightsaber.Core.Model
 @namespace Lightsaber.Core
 @module Lightsaber.Core
 @extends Backbone.Model

 @since 9.0.0

 @requires jquery
 @requires underscore
 @requires backbone
 @requires Validator
 @requires ErrorHandler
 @requires Utils


 **/

define('src/core/model/Model',['jquery',
        'underscore',
        'backbone',
        'src/core/model/Validator',
        'src/core/model/ErrorHandler',
        'src/core/util/Utils'],
  function($,_, Backbone, Validator, ErrorHandler, Utils) {


  var Model = Backbone.Model.extend({


	  _validate: function( attrs, options) {
	      if ( !this.validate || this.validations && !this.validator) return true;
	      
	      attrs = _.extend({}, this.attributes, attrs);
	      var error = this.validate(attrs, options);
	      if (!error) return true;
	      if (options && options.error) {
	          options.error(this, error, options);
	      } else if (!options.silent) {
	          this.trigger('error', this, error, options);
	          this.trigger('invalid', this, error, _.extend(options || {}, {validationError: error}));
	          if (error.errors) {
		          for (var i=0; i<error.errors.length; i++) {
		        	  for (var fieldName in error.errors[i].attrs)
		        		  this.trigger('error:' + fieldName, this, error.errors[i], options);
		          }	        	  
	          }
	      }
	      return false;
	  },
	      
	  /**
	   * Validates the model. Collecting all failed checks defined in the validations array property.
	   * @methodOf Lightsaber.Core.Model#
	   * @name validate
	   * @param {Object}      attrs                The properties to check
	   * @param {Object}      [options.api]        The Model's API validate is called from. Possible 
	   *                                           values are: 'set', 'isValid', 'getInstance', 'save'            
	   */
	  validate: function( attrs, options) {
        var returnedValue, errors = [], warnings = [];
        
        if (this.validations) {
            
            for (var i in this.validations) {
            	if ( ! this._ensureCheck( this.validations[i], attrs, options) )
            		continue;

                var val = this.validator[this.validations[i].check].call( this.validator, this.validations[i], attrs, this);
                val && (this._isWarning( options, this.validations[i])? warnings.push(val) : errors.push(val));   		
            }
    		options && delete options.api;
            
    		if (errors.length) {
    			returnedValue = { source:'validation', status:'error', statusText:'operation has failed', errors:errors, warnings:warnings };
    		}
    		else if (warnings.length) {
    			var warning = { source:'validation', status:'warning', statusText:'operation has succeeded with warnings', warnings:warnings };
    			
    		    if (options && options.warning) {
    		        options.warning(this, warning, options);
    		    } else {
    		    	options._warningWasFound = true;
    		    	this.trigger( 'warning', this, warning, options);
  	          		for (var j=0; j<warnings.length; j++) {
  	          			for (var fieldName in warnings[j].attrs)
  	          				this.trigger('warning:' + fieldName, this, warnings[j], options);
  	          		}
    		    }
    		}
    		
        }
        return returnedValue;
    },

    _ensureCheck: function( conf, attrs, options) {
      //set empty options if undefined
      options = options || {};

    	if ( conf.onlyIf && !conf.onlyIf.call(attrs) )
    		return false;
    	
    	var checkAttr = conf.check;
    	if (!checkAttr)
    		throw "'check' attribute was not found on validation: " + JSON.stringify( conf );

    	var check = this.validator[checkAttr];
    	if (!_.isFunction(check))
    		throw "the specified 'check' (" + checkAttr + ') is not a function';

    	var validateSetOnly = options.hasOwnProperty('validateSetOnly')? options.validateSetOnly: this.options.validateSetOnly;
    	var ensuredCheck = options.api != 'set' || !validateSetOnly;

    	if (!ensuredCheck) {
    		var fieldNames = conf.fieldName && [conf.fieldName] || conf.fieldNames || [];
    		ensuredCheck = fieldNames.length == 0;

    		var i = 0;
    		while ( i < fieldNames.length && !ensuredCheck ) {
    			var fieldName = fieldNames[i++];
    			ensuredCheck = attrs.hasOwnProperty(fieldName);

    			if (!ensuredCheck) {
    				var segs = fieldName.split('.');
    				ensuredCheck = segs.length>1 && _.reduce( segs, function(memo, seg) { return memo? memo[seg]: undefined; }, attrs );
    			}

    		}
    	}
    	return ensuredCheck;
    },
    
    _isWarning: function( options, conf) {
    	var isWarning = false;    	
    	var api = options && options.api;
    	
    	
    	if (conf.warn)
    		isWarning =  api? ( conf.warn[api]  ||  _.isUndefined(conf.warn[api]) && conf.warn.all ) : conf.warn.all;

    	return isWarning;
    },

    /**
     * Sets the model's attribute. See Backbone's documentation. In addition handle structured models.
     * @methodOf Lightsaber.Core.Model#
     * @method set
     */
    set: function(key, value, options) {
        var attrs;
        if (_.isObject(key) || key == null) {
            attrs = key;
            options = value;
        } else {
            attrs = {};
            attrs[key] = value;
        }
        attrs && delete attrs.__EmptyObject__;
        
        if ( !options || options.api !== 'set')
        	options = _.defaults( {api:'set'}, options );

        var ok = Backbone.Model.prototype.set.call(this, attrs, options);
        if (!ok)
            return ok;
        
        var self = this;
        _.each( attrs, function(avalue, akey){
        	if  (avalue && self.isBindable(avalue)) {
        		avalue.on( 'all', function( eventName, obj, val) {
        			if ( self !== obj) {
        				eventName = self.adjustEventName(eventName, akey);
        				self.trigger( eventName, obj, val);
        			}
        		});
        	}        	
        });
                
        return ok;
    },

    /**
     * Sets a data source. This allows to switch data source for the model on the fly.
     * @methodOf Lightsaber.Core.Model#
     * @method setDataSource
     * @param {Object}      dataSource                An object having a getSync() method
     * @param {Object}      [options]                 The options to use
     * @param {Function}      [options.mapModel]      Receives a model. For modifying a model
     * @param {String}        [options.idAttribute]   The new id attribute
     */
    setDataSource: function( dataSource, options) {
    		this.dataSource = dataSource;
            this.setSync( dataSource.getSync(), options);
    },

    
    /**
     * Returns the last data source that was set
     * @methodOf Lightsaber.Core.Model#
     * @method getDataSource
     * @returns {DataSource}
     */
    getDataSource: function() {
		return this.dataSource;
    },
    
    
    /**
     * Initializes the instance. Is usually called from the constructor
     * @methodOf Lightsaber.Core.Model#
     * @method initialize
     * @param {Object}      [attributes]          The initial attributes of the created instance
     * @param {Object}      [options]           The options to use
     * @param {String}        [options.url]     The Model URL
     */
    initialize: function( attributes, options) {
        options = _.defaults( {}, options, this.options, {api:'init'});
        
        if ( options.url ) {
            this.urlRoot = options.url;
            delete this.url;
        }

        if (this.validations) {
        	this.validator = new Validator();
            for (var i in this.validations) {
            	var warn = this.validations[i].warn || {};
            	_.defaults( warn, { set:true, save:false } );
            	this.validations[i].warn = warn;
            }
        }

        if (options.errorHandler) { // set instance error handler hides global handler
        	this.errorHandler = options.errorHandler;
        }
        
        this.options = _.pick(options, 'autoSnapshot', 'deepAutoSnapshot', 'validateSetOnly');
    },

    /**
     * Gets the model's attribute. See Backbone's documentation.
     * @methodOf Lightsaber.Core.Model#
     * @method get
     * @param {String} [key] The name of the attribute. If not passed then all attributes are returned.
     */
	get: function (attribute){
		if(attribute){
			return Backbone.Model.prototype.get.call(this, attribute);
		}
		return this.attributes;
	},

	/**
	 * Can be used to validate specific flows by setting options.api
     * @methodOf Lightsaber.Core.Model#
     * @method isValid
	 */
	isValid: function ( options ){
	    return this._validate( undefined, _.extend( {api:'isValid'}, options ) );
	},

	/**
	 * Fetch model
	 */
    fetch: function(options) {
        options = options ? _.clone(options) : {};
        if (options.parse === void 0) options.parse = true;
        var model = this;
        var success = options.success;
        options.success = function(resp) {
          if (!model.set(model.parse(resp, options), options)) return false;
          if (success) success(model, resp, options);
          model.trigger('sync', model, resp, options);
        };
        Backbone.wrapError(this, options);
        return this.sync('read', this, options);
      },

  /**
   * Saves the model's attribute. See Backbone's documentation. <br/>
   * Extend the backbone save model by :
   * <ol>
   *     <li>Do not persist invalid models.</li>
   *     <li>After a successful server-side save, the client is updated with the server-side state.</li>
   *     <li>When the data include file object (FormData or input file tag) save as a multipart.</li>
   * </ol>
   * @method save
   * @param {String} attributes Set a hash of attributes (one or many) on the model. If any of the attributes change the model's state
   * @param {Object} options A config object.<br/>
   * Extend the backbone options by adding:<br/>
   * <ul>
   *     <li>file: Hold the flie (FormData or input file tag) that need to be saved. if equal to false do not save as multipart.</li>
   * </ul>
   * @return {Object} Returns a jqXHR if validation is successful and false otherwise
   */
    save: function(key, val, options) {
        var attrs, method, xhr, attributes = this.attributes;

        // Handle both `"key", value` and `{key: value}` -style arguments.
        if (key == null || typeof key === 'object') {
          attrs = key;
          options = val;
        } else {
          (attrs = {})[key] = val;
        }

        if ( !options || options.api !== 'save')
			options = _.defaults( {api:'save'}, options );

        // If we're not waiting and attributes exist, save acts as `set(attr).save(null, opts)`.
        if (attrs && (!options || !options.wait) && !this.set(attrs, options)) return false;

        options = _.extend({validate: true}, options);

        // Do not persist invalid models.
        if (!this._validate(attrs, options)) return false;

        // Set temporary attributes if `{wait: true}`.
        if (attrs && options.wait) {
          this.attributes = _.extend({}, attributes, attrs);
        }

        // After a successful server-side save, the client is (optionally)
        // updated with the server-side state.
        if (options.parse === void 0) options.parse = true;
        var model = this;
        var success = options.success;
        options.success = function(resp) {
          // Ensure attributes are restored during synchronous saves.
          model.attributes = attributes;
          var serverAttrs = model.parse(resp, options);
          if (options.wait) serverAttrs = _.extend(attrs || {}, serverAttrs);
          if (_.isObject(serverAttrs) && !model.set(serverAttrs, options)) {
            return false;
          }
          if (success) success(model, resp, options);
          model.trigger('sync', model, resp, options);
        };
        Backbone.wrapError(this, options);

        method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');
        if (method === 'patch') options.attrs = attrs;
        xhr = this.sync(method, this, options);

        // Restore attributes.
        if (attrs && options.wait) this.attributes = attributes;

        return xhr;
      },

  	/**
  	 * Destroy model
  	 */
    destroy: function(options) {
        options = options ? _.clone(options) : {};
        var model = this;
        var success = options.success;

        var destroy = function() {
            model.trigger('destroy', model, model.collection, options);
        };

        options.success = function(resp) {
            if (options.wait || model.isNew()) destroy();
            if (success) success(model, resp, options);
            if (!model.isNew()) model.trigger('sync', model, resp, options);
        };

        if (this.isNew()) {
            options.success();
            return false;
        }
        Backbone.wrapError(this, options);

        var xhr = this.sync('delete', this, options);
        if (!options.wait) destroy();
        return xhr;
    },

    /**
     * Takes a snapshot of the model's attributes. See also revertToSnapshot 
     * @methodOf Lightsaber.Core.Model#
     * @method takeSnapshot
     * @param {boolean} [deep] True for deep copy.
     */
	takeSnapshot: function (deep) {
		this._snapshotAttributes = deep? $.extend( true, {}, this.attributes): $.extend( {}, this.attributes);
	},
	
    /**
     * Reverts the model's attributes to the last snapshot.
     * @methodOf Lightsaber.Core.Model#
     * @method revertToSnapshot
     * @param {boolean} [silent] True for silent.
     */
	revertToSnapshot: function (silent) {
		var options = {silent: silent};
		this.clear(options);
		this.set( this._snapshotAttributes, options);
	},
	

    /** @private */
	setSync: function( sync, options) {

		if (!sync || !_.isFunction(sync)) {
			throw "setSync: sync should be a function";
		}

		var self = this;

		this.sync = function( method, model, options) {
			if ( this.currentErrorHandler !== this.errorHandler) {
				if (this.currentErrorHandler)
					this.off( 'error', this.currentErrorHandler );

				this.currentErrorHandler = this.errorHandler;
				this.on ( 'error', this.currentErrorHandler );
			}

			options = _.defaults( {}, options , this.options );
			if (options.autoSnapshot) {
				var success = options.success;
				options.success = function() {
					self.takeSnapshot( options.deepAutoSnapshot );
					success && success.apply( undefined, arguments);
				};
			}

			return sync( method, model, options);
		};

		options = options || {};
		var mapModel = options.mapModel;
		if (mapModel && _.isFunction(mapModel)) {
			mapModel(this);
		}

		var idAttribute = options.idAttribute;
		if (idAttribute && _.isString(idAttribute)) {
			this.idAttribute = idAttribute;
			this.id = Backbone.Model.prototype.get.call(this, idAttribute);
		}
	},

    
    /** @private */
    isBindable: function( model) {
                return model.on && _.isFunction(model.on);
    },
    
    /** @private */
    adjustEventName: function(eventName, a) {
          var idx = eventName.indexOf(':');
          if (idx != -1) {
                 eventName = eventName.substring(0, idx+1) + a + eventName.substring(idx);
          }
          return eventName;
    },
    
	errorHandler: ErrorHandler.handleError, 
	
    /**
     * Reference to <a href="Lightsaber.Core.Utils.html#method_create" class="crosslink">Utils create method</a>
     *
     * @methodOf Lightsaber.Core.Model#
     * @method create
     */
    create: Utils.create
  },
  {
    /** @private */
    postExtend: function() {
		this.pool = {};
    },

    
    /**
	 * Returns a model with the attrs attributes. Checks in the pool for an object with the passed ID. If none is found then
	 *  a new model is created in the pool and returned, else the pool's object is updated and returned.
	 *  If the ID field is not passed, then returns undefined.
     * @methodOf Lightsaber.Core.Model
     * @method getInstance
     * @param {Object} [attrs] the attribute to set
     * @param {Object} [options] the options passed to the set operation
	 */
	getInstance: function( attrs, options) {
		var id = attrs[this.prototype.idAttribute];
		if (id) {
	        if ( !options || options.api !== 'getInstance')
	        	options = _.defaults( {api:'getInstance'}, options );

	        var model = this.findInstance( id );
			if (!model) {
				model = new this( attrs, options);
				this.getPool()[id] = model;
			}
			else
				model.set(attrs, options);
			
			return model;
		}
	},
	
	
	/**
	 * If the pool contains a model with ID then removes that model and returns it, otherwise returns undefined
     * @methodOf Lightsaber.Core.Model
     * @method removeInstance
     * @param {String} id the instance id 
	 */
	removeInstance: function( id ) {
		var model = this.findInstance( id );
		delete this.getPool()[id];
		return model;
	},
	
	
	/**
	 * If the pool contains a model with ID then returns that model, otherwise returns undefined.
     * @methodOf Lightsaber.Core.Model
     * @method findInstance
     * @param {String} id the instance id 
	 */
	findInstance: function( id ) {
		return this.getPool()[id];
	},

	
    /** @private */
	getPool: function() {
		return this.pool? this.pool: (this.pool = {});
	},

	/**
	 * Sets the global default error handler
     * @methodOf Lightsaber.Core.Model
     * @method setGlobalErrorHandler
     * @param {Function} new callback handler 
	 */
	setGlobalErrorHandler: function( handler ) {
		this.prototype.errorHandler = handler;
	},

	/**
	 * Unsets the global default error handler
     * @methodOf Lightsaber.Core.Model
     * @method unsetGlobalErrorHandler
	 */
	unsetGlobalErrorHandler: function( ) {
		delete this.prototype.errorHandler;
	}
  });

  Backbone.wrapError= function( model, options) {
  	var error = options.error;
  	options.error = function(resp) {
  		(!error || !error(model, resp, options)) && model.trigger('error', model, resp, options);
  	};
  };

  Model.extend = Utils.extend;
  
  return Model;

});
/**
Base <em>Configuration</em> component.

The Configuration utility provides a page *global* storage for configuration data. It's an instance of *Model*, 
so the application can register to get change notifications or connect it to a data source. 

The Core *Configuration* is initialized with the data in the `lightsaber.configData.json` module.

> **Note** providing a **valid** JSON file that has the *RequireJS* ID of `lightsaber.configData.json` **is mandatory**.

@class Lightsaber.Core.Configuration
@namespace Lightsaber.Core
@module Lightsaber.Core
@extends Lighstaber.Core.Model

@since 9.0.0

@requires Lighstaber.Core.Model

@constructor
**/
define('src/core/util/Configuration',[ 
	'src/core/model/Model', 
	'text!lightsaber.config.json'
], function( Model, ConfigData) {

	

	var Configuration = Model.extend({

		/**
		Adds a configuration object to the existing configuration, overriding existing properties of the same name.

		@method loadConfiguration
		@param {Object} configData the new configuration object to **merge** into the existing configuration
		**/
		loadConfiguration: function( configData ) {
			if (typeof configData === "string")
				configData = eval( "(" + configData + ")" );
			
			this.set( configData );
		},
		
     	/**
		Adds a configuration object to the existing configuration, overriding existing properties of the same name.

		@method loadCoreConfiguration
		@param {Boolean} clearFirst clears the custom configuration (loaded using `loadConfiguration` method)
		**/
		loadCoreConfiguration: function( clearFirst ) {
			if ( clearFirst === true) {
				this.clear();
			}
			this.loadConfiguration( ConfigData );
		}

	});
	
	var configuration = new Configuration();
	configuration.loadCoreConfiguration();

	return configuration;
});
/**
Base Core <em>REST Data Source</em> component. Is overridden by all other *REST Data Source* components.

The *REST Data Source* component is not intended to be instantiated directly, rather used as a base by extending 
*REST Data Source* components - for example: {{#crossLink "Lightsaber.Core.RESTDataSource"}}{{/crossLink}}.

The main purpose of a *REST Data Source* is to abstract away specific details of *Model* - *REST Service* - using *CRUD* interface. It is connected (embedded) to {{#crossLink "Lightsaber.Core.LSRESTDataSource"}}{{/crossLink}}.

```javascript
new RESTDataSource({
    create: {     
        url: '/customer/:custId/order/:nodeId',
        params: {custId: '@custId', nodeId:'2012'},
        qParams: {salesChannel: 'SS'},
    }
});
```

or:

```javascript
new RESTDataSource({
    read: {    
        method: 'GET' 
        url: '/customer/:custId'
    }
});
```

@class Lightsaber.Core.RESTDataSource
@namespace Lightsaber.Core
@module Lightsaber.Core
@extends Object

@since 9.0.0

@requires underscore
@requires backbone
@requires Lightsaber.Core.Utils
@requires Lightsaber.Core.Configuration

@examples Lightsaber.Core.Model

@constructor
@param {Object} [options] configuration object
@param {Object} [options.defaults] default values to be used across all method-specific configurationobjects (see below)
@param {Object} [options.<method>] configuration options for a specific method (*create*, *update*, *read*, *readPage* or *delete*)
@param {String} [options.<method>.method] any HTTP method
@param {String} [options.<method>.contentType='application/json'] MIME type
@param {String} [options.<method>.protocol] protocol name: `http` or `file` 
@param {String} [options.<method>.host] host name
@param {String} [options.<method>.port] port number
@param {String} [options.<method>.module] name of the module; all URLs are relative to it
@param {String} [options.<method>.url] URL
@param {Object} [options.<method>.params] path parameters configuration object
@param {Object} [options.<method>.qParams] query parameters configuration object
@param {Object} [options.<method>.headers] HTTP request headers
@param {Object} [options.<method>.names] additinal parameters: `{pageStart:{qParam name}, pageSize:{qParam name}}`
@param {String} [options.<method>.fullURL] full URL
@param {Function} [options.<method>.parse] function (alternative) to parse server response
@param {Array} [options.<method>.payload] array of properties' names to send with the HTTP request
**/
define('src/core/dataSource/RESTDataSource',[
    'jquery',
    'underscore', 
    'backbone', 
    'src/core/util/Utils', 
    'src/core/util/Configuration'
], function($,_, Backbone, Utils, Configuration) {

    

    var RESTDataSource = function(settings) {
        
        var initialValues = { 
                'create': 	{method:'POST', contentType:'application/json'},
                'read':   	{method:'GET'},
                'readPage':	{method:'GET', supportsPagination:false, supportsSorting:false, supportsFiltering:false, parse:parsePage },
                'update': 	{method:'PUT', contentType:'application/json'},
                'delete': 	{method:'DELETE'}
        };
        
        this.namedParam =  (settings && settings.namedParam)? settings.namedParam: /:(\w+)/g ;
        
        this.methods = _.extend( {}, settings);
        delete this.methods.namedParam;
        
        _.each( initialValues, function( value, key) {
            this.methods[key]? _.defaults( this.methods[key], value) : (this.methods[key] = value);
        }, this );
                
        this.defaults = this.methods.defaults || {};
        
        var conf = Configuration.get('REST data source') || {};
        this.globalDefaults = conf.defaults || {};
        
        this.initialize.apply(this, arguments);
    };

    /**
    Main synchronization method that redirects to Model's one.

    @method sync
    @protected
    @param {String} method CRUD method
    @param {Model} model model that the data source is applied to
    @param {Object} options contains callbacks and additional parameters
    @return {...} result of the Model's `sync` method
    **/
    RESTDataSource.prototype.sync = function(method, model, options) {
        var conf = this.methods[method] || throwEx('method ' + method + ' is not defined');
        options = _.extend( {}, options);
        var url = this.getProperty( 'fullURL', conf, options) || this.composeURL( conf, model, options);
        this.lastUrl = url;



        var type = options.type || conf.method || this.defaults.method || throwEx('no HTTP method is defined for ' + method );
        var dataType = this.getProperty( 'dataType', conf, options) || 'json';
        var params = {type: type, dataType: dataType, url: url}; // defaults
        params.headers = this.mergeProperty( 'headers', conf, options);
        delete options.headers;
        params.contentType = this.getProperty( 'contentType', conf, options);
        params.timeout = this.getProperty( 'timeout', conf, options);

        var success = options.success;
        var rest = this;
        options.success = function( response, status, xhr) {
            if (success)
                success( rest.parse(response, conf, options), status, xhr);
        };

        // If we are using HTML5 (FormData object) we simply set the content type to multipart and create the correct FormData object, if not submit the information via form and iFrame.
        var data = model.toJSON();
        if (Utils.FileUpload.hasFileToSubmit(data,options)){
            if (Utils.FileUpload.isFormDataSupported()){
                options = Utils.FileUpload.getXhrOptions(data, options);
            }
            else{
                var jqXHR = Utils.FileUpload.submitDataAsForm(data, _.extend(params, options));
                return jqXHR;
            }
        }

        if (!options.data && model) {
            var contentType = this.getProperty( 'contentType', conf, options);
            if (contentType == 'application/json' || contentType == 'application/x-www-form-urlencoded') {
                params.contentType = contentType;
                var properties = model.toJSON();
                var payload = this.getProperty( 'payload', conf, options);
                if (payload)
                	properties = pick.apply(properties, payload);
                params.data = JSON.stringify(properties);
            }
            if (contentType == 'application/x-www-form-urlencoded') {
                params.data = params.data ? {model: params.data} : undefined;
            }
        }

        if (params.type !== 'GET') {
            params.processData = false;
        }
        

        var xhr = $.ajax(_.extend(params, options));
        if (model)
        	model.trigger('request', model, xhr, options);
        return xhr;
    };

    /**
    Parses the response.

    @method parse
    @protected
    @param {String} response
    @param {Object} conf configuration
    @param {Object} options contains callbacks and additional parameters
    @return {Object} parsed response
    **/
    RESTDataSource.prototype.parse = function( response, conf, options) {
    	var parsed = response;
    	var parse = this.getProperty( 'parse', conf, _.isFunction(options.parse)? options: {} );
    	if ( _.isFunction(parse)) {
    		parsed = parse(response);
    	}
        
        return parsed;
    };

    /**
    Sets the dynamic query parameters block.

    @method setQueryParams
    @param {Object} qparams object containing the query parameters to set
    **/
    RESTDataSource.prototype.setQueryParams = function(qparams) {
    	this.dynamicQueryParams = qparams;
    };

    /**
    Returns the properties of the *DataSource*.

    @method getProperties
    @return {Object} *DataSource* properties with default value of
    ___
    ```javascript
    { 
        supportsPagination: false,
        supportsSorting: false,
        supportsFiltering: false 
    }
    ```
    **/
    RESTDataSource.prototype.getProperties = function() {
		return { supportsPagination: this.methods.readPage.supportsPagination,
				 supportsSorting: this.methods.readPage.supportsSorting,
				 supportsFiltering: this.methods.readPage.supportsFiltering };
	};

    /**
    Sets the final URL to use.

    @method setFullURL
    @param {String} action (one of *create*, *update*, *read*, *readPage* or *delete*)
    @param {String} fullURL full URL
    **/
    RESTDataSource.prototype.setFullURL = function(action, fullURL) {
		this.methods[action].fullURL = fullURL;
    };

    /**
    Returns the {{#crossLink "Lightsaber.Core.DataSource/sync:method"}}{{/crossLink}} method of the *DataSource*.

    @method getSync
    @return {Function} {{#crossLink "Lightsaber.Core.DataSource/sync:method"}}{{/crossLink}} method of the *DataSource*
    **/
    RESTDataSource.prototype.getSync = function() {
      return _.bind( this.sync, this );
    };

    /**
    @private
    **/
    RESTDataSource.prototype.composeURL = function( conf, model, options) {
        var url =  this.getProperty( 'url', conf, options) || getValue(model, 'url');
        if (options.url) delete options.url;

        var qParams = this.makeQueryParams( conf, options);
        url = this.appendQueryString( url, qParams);

        var matches = url.match( this.namedParam );
        if (matches) {
            for (var i=0; i < matches.length; i++) {
                var param = matches[i].substring(1);
                var value = (options.params && options.params[param]) ||
                            (conf.params && conf.params[param]) ||
                            (model && model.get(param)) ||
                            (this.defaults.params && this.defaults.params[param]) ||
                            (this.globalDefaults.params && this.globalDefaults.params[param]);
                
                if ( _.isString(value) && value.charAt(0) === '@' ) {
                    value = value.substring(1);
                    value = options[value] || (model && model.get(value));
                }
                else if (_.isUndefined(value) ) {
                    value = options[param];
                }
                url = url.replace( matches[i], encodeURIComponent(value));
            }
        }

        url = this.prefixUrl( url, conf, options);

        return url;
    };


    /**
    @private
    **/
    RESTDataSource.prototype.makeQueryParams = function( conf, options) {
    	var qParams = {};
    	if (options.pagination) {
        	var names = this.getProperty( 'names', conf, options) || { pageStart: 'indexOfFirst', pageSize: 'pageSize'};
        	qParams[names.pageStart] = options.pagination.pageStart;
        	qParams[names.pageSize] = options.pagination.pageSize;
    	}
    	for (var a in options.sorting) {
    		qParams[a] = options.sorting[a];
    	}
    	for (a in options.filtering) {
    		qParams[a] = options.filtering[a];
    	}
        
        var property = 'qParams';
        return _.defaults( qParams, options[property], this.dynamicQueryParams, conf[property],
        		               this.defaults[property], this.globalDefaults[property]);
    };


    /**
    @private
    **/
    RESTDataSource.prototype.appendQueryParam = function( p, value) {
    	var str = '';
    	
    	if (value instanceof Array) {
    		if (value.length === 1) {
    			str = this.appendQueryParam( p, value[0] );
    		}
    		else if (value.length > 1) {
    			str = this.appendQueryParam( p, value.shift() ) + '&' + this.appendQueryParam( p, value );
    		}
    	}
    	else
    		str = p + '=' + encodeURIComponent(value);
    	
    	return str;
    };

    
   	/**
    @private
    **/
    RESTDataSource.prototype.appendQueryString = function( url, qParams) {
        var str = '';
        for (var p in qParams) {
        	str += (str? '&' : '') + this.appendQueryParam( p, qParams[p] );
        }
        return url + (str? '?' : '') + str;
    };


    /**
    @private
    **/
    RESTDataSource.prototype.prefixUrl = function( url, conf, options) {
        var prefix = '';

        var protocol = this.getProperty( 'protocol', conf, options) || window.location.protocol;
        prefix = protocol + (protocol.charAt(protocol.length-1)==':'? '' : ':' ) + '//';

        var host = this.getProperty( 'host', conf, options) || window.location.hostname;
        var port = this.getProperty( 'port', conf, options) || window.location.port;
        prefix = prefix + host + (port? ':'+ port : '' );

        var module = this.getProperty( 'module', conf, options);
        if (module) {
            prefix += '/' + encodeURI( trim(module) );
        }

        prefix += '/' + trim( url);
        return prefix;
    };

    /**
    @private
    **/
    RESTDataSource.prototype.getProperty = function( property, conf, options) {
        return options[property] || conf[property] || this.defaults[property] || this.globalDefaults[property];
    };

    /**
    @private
    **/
    RESTDataSource.prototype.mergeProperty = function( property, conf, options) {
        return _.defaults( {}, options[property], conf[property], this.defaults[property], this.globalDefaults[property]);
    };

    /**
     * Initialize is an empty function by default. Override it with your own initialization logic.
     * @methodOf Lightsaber.Core.RESTDataSource
     * @name initialize
     */
    RESTDataSource.prototype.initialize = function(){};

    /**
    @private
    **/
    var getValue = function(object, prop) {
        if (!(object && object[prop])) return null;
        return _.isFunction(object[prop]) ? object[prop]() : object[prop];
    };

    /**
    @private
    **/
    var throwEx = function(str) {
        throw new Error(str);
    };

    /**
    @private
    **/
    var trim = function(str) {
        var from = str.charAt(0) == '/'? 1: 0;
        var to = str.length - (str.charAt(str.length-1) == '/'? 1: 0);
        return str.substring( from, to);
    };

    /**
     * @private
     * Use apply or call: this is the object to pick from
     */
    var pick = function( /* keys* */) {
    	var picked = {};
    	var obj = this;
        _.each( Array.prototype.slice.call( arguments, 0), function(prop) {
        	if (!_.isUndefined( obj[prop]) ) {
        		picked[prop] = obj[prop];
        	}
        });
        return _.isEmpty(picked)? undefined: picked;
    };

    /**
    @private
    **/
    var parsePage = function( r) {
    	return { pageStart: r.indexOfFirst, pageSize: r.pageSize, totalSize: r.numberOfRows, hasMore: r.hasMore, data: r.data};
    };

    RESTDataSource.extend = Utils.extend;
    RESTDataSource.prototype.create = Utils.create;

    return RESTDataSource;
});
/**
Core <em>LS REST Data Source</em> component. 

The main purpose of *LS REST Data Source* is to abstract away specific details of *Model* - 
*REST Service* - using *CRUD* interface **while implementing Lightsaber security protocol**. 

It is connected (embedded) to {{#crossLink "Lightsaber.Core.DataSource"}}{{/crossLink}}.

```javascript
new LSRESTDataSource({
    create: {     
        url: '/customer/:custId/order/:nodeId',
        params: {custId: '@custId', nodeId:'2012'},
        qParams: {salesChannel: 'SS'},
    }
});
```

or:

```javascript
new LSRESTDataSource({
    read: {    
        method: 'GET' 
        url: '/customer/:custId'
    }
});
```

@class Lightsaber.Core.LSRESTDataSource
@namespace Lightsaber.Core
@module Lightsaber.Core
@extends Lightsaber.Core.RESTDataSource

@since 9.0.0

@requires underscore
@requires backbone
@requires Lightsaber.Core.Utils
@requires Lightsaber.Core.Configuration

@examples Lightsaber.Core.Model

@constructor
@param {Object} [options] configuration object
@param {Object} [options.defaults] default values to be used across all method-specific configurationobjects (see below)
@param {Object} [options.<method>] configuration options for a specific method (*create*, *update*, *read*, *readPage* or *delete*)
@param {String} [options.<method>.method] any HTTP method
@param {String} [options.<method>.contentType='application/json'] MIME type
@param {String} [options.<method>.protocol] protocol name: `http` or `file` 
@param {String} [options.<method>.host] host name
@param {String} [options.<method>.port] port number
@param {String} [options.<method>.module] name of the module; all URLs are relative to it
@param {String} [options.<method>.url] URL
@param {Object} [options.<method>.params] path parameters configuration object
@param {Object} [options.<method>.qParams] query parameters configuration object
@param {Object} [options.<method>.headers] HTTP request headers
@param {Object} [options.<method>.names] additinal parameters: `{pageStart:{qParam name}, pageSize:{qParam name}}`
@param {String} [options.<method>.fullURL] full URL
@param {Function} [options.<method>.parse] function (alternative) to parse server response
@param {Array} [options.<method>.payload] array of properties' names to send with the HTTP request
**/
define('src/core/dataSource/LSRESTDataSource',['jquery','underscore', 'src/core/dataSource/RESTDataSource', 'src/core/util/StorageUtil', 'src/core/util/Utils','src/core/util/Configuration'],
function($,_, RESTDataSource, StorageUtil, Utils,Configuration) {

    var LSRESTDataSource = RESTDataSource.extend( {
    	
    	lsSessionTokenAlias : Configuration.get('lsSessionTokenAlias') || 'LightsaberSessionToken',    
    	/**
    	Main-entry method. 

    	Initializes storage listener for token updates.

    	@method initialize
    	@protected
    	**/
	    initialize : function() {
	    	if (!LSRESTDataSource.initialized) {
	    		var self = this;
	    		$(window).bind('storage', function (event) {  
	    	    		if (event.key == self.lsSessionTokenAlias)
    	    			self.setToken( event.newValue );
	    		}); 
	    		
	    		LSRESTDataSource.initialized = true;
	    	}
	    },
	
	    /**
	    Sets the session token for Lightsaber's security services.

		@method setToken
		@param {String} token token to set
		@param {Boolean} shouldPersist whether the token should be saved
	    **/
	    setToken : function( token, shouldPersist ) {
	    	if (LSRESTDataSource.token !== token) {
	    		LSRESTDataSource.token = token;
	    		if (shouldPersist) {
	    			this.storage.set( this.lsSessionTokenAlias, token);
	    		}
	    	    LSRESTDataSource.trigger(LSRESTDataSource.TOKEN_UPDATE_EVENT, {token: token});
	    	}
	    },
	
	    /**
	    Retrieves the session token.

		@method setToken
		@return {String} token
	    **/
	    getToken : function() {
	    	if (!LSRESTDataSource.token) {
	    		LSRESTDataSource.token = this.storage.get( this.lsSessionTokenAlias);
	    	}
	    	return LSRESTDataSource.token;
	    },
	
	    /**
	    Main synchronization method that redirects to Model's one.

	    @method sync
	    @protected
	    @param {String} method CRUD method
	    @param {Model} model model that the data source is applied to
	    @param {Object} options contains callbacks and additional parameters
	    @return {...} result of the Model's `sync` method
	    **/
	    sync : function( method, model, options) {
	        options = _.extend( {}, options);
	    	var self = this;
	    	var error = options.error;
	    	options.error = function( xhr, status) {
	    		self.handleXhr(xhr);
	    		if (error) {
	    			var data;
	    			try {
	    				data = JSON.parse(xhr.responseText);
	    			} catch(e) {
	    				data = xhr.responseText;
	    			}

	    	    	LSRESTDataSource.trigger(LSRESTDataSource.ERROR, {
	    	    		statusCode: xhr.status,
	    	    		data: data,
	    	    		xhr: xhr
	    	    	});
	    			error( xhr, status);
	    		}
	    	};
	    	var success = options.success;
	        options.success = function( response, status, xhr) {
	    		self.handleXhr(xhr);
	        	if (success)  
	        		success( response, status, xhr);
	        };
	    	
    		this.applySecurity( options);
	    	
	    	return RESTDataSource.prototype.sync.call( this, method, model, options);
	    },
	
	    /**
        @private
        **/
	    handleXhr : function( xhr) {
	    	var h = xhr.getResponseHeader('uxfauthorization');
	    	if (h) {
	    		this.setToken(h === 'null'? undefined : h, true);	    		
	    	}
	    },

        /**
         * Add authorization information so that the server will authenticate the REST call.
         *
         * @method applySecurity
         * @param {object} options security options
         */
	    applySecurity : function( options) {
	    	var token = this.getToken();
	    	if (!token) {
	    		if (options.LSPassword) {
	    			throw 'Protected Lightsaber service requires a token';
	    		}
	    	}
	    	else {	    		    	
		    	if (options.LSPassword) {
		    		token += ' UXF_SecActionPSW:' + options.LSPassword;
		    		delete options.LSPassword;
		    	}
		    	
		    	var headers = options.headers || (options.headers = {});
		    	headers.authorization = token;
	    	}
	    },
	
	    /**
	    Gets the *sync* method for this DataSource. Intended to be used by Lightsaber's Model and Collection
	    
	    @private
	    **/
	    getSync : function() {
	      return _.bind( this.sync, this );
	    },
	
	    create : Utils.create

    });
    
    LSRESTDataSource.extend = Utils.extend;

    LSRESTDataSource.prototype.storage = StorageUtil.getStorage('session');

	LSRESTDataSource.TOKEN_UPDATE_EVENT = 'tokenUpdated';
	LSRESTDataSource.ERROR = 'error';

	LSRESTDataSource.TOKEN_INVALID = 'tokenInvalid';
	LSRESTDataSource.TOKEN_EXPIRED = 'tokenExpired';

    _.extend(LSRESTDataSource, Backbone.Events);

    return LSRESTDataSource;
});


/**
 * @class RESTModel
 * @type Model
 * @name RESTModel
 * @memberOf Lightsaber.Core
 * @extends Lightsaber.Model
 * @description 
 * The Lightsaber's RESTModel class. A convenience Model class that supports the RESTDataSource.
 * @example
 * 
 *          var Data = RESTModel.extend( {options:
 *                             { rest: {create: {method:'POST'} }, 
 *   	                         url:'myurl'}} );
 *
 *          Or
 *          
 *          var data = new RESTModel( {third:'now'}, {
 *                  url:'employee', 
 *                  rest: {create: {method:'POST', contentType:'application/json', module:'MMM'} }
 *          } );
 */


define('src/core/model/RESTModel',['underscore',
        'src/core/model/Model',
        'src/core/dataSource/RESTDataSource',
        'src/core/dataSource/LSRESTDataSource',
        'src/core/util/Utils'],
  function(_, Model, REST, LSREST, Utils) {


  var RESTModel = Model.extend({


    /** @lends Lightsaber.RESTModel.prototype */

    
    /**
     * Initializes the instance. Is usually called from the constructor
     * @param {Object}      [attributes]        The initial attributes of the created instance
     * @param {Object}      [options]           The options to use
     * @param {Object}        [options.rest]      See Lightsaber's RESTDataSource documentation
     */
	  initialize: function( attributes, options) {
		  var restOptions = _.defaults( {}, options && options.rest, this.options && this.options.rest );

		  Model.prototype.initialize.call( this, attributes, options);

		  this.setRESTConfig( restOptions );          
	  },

    /**
     * Configures the REST data source for the instance.
     * Default is LSRESTDataSource, pass unsecured to instantiates a new RESTDataSource
     * 
     * @param {Object}      RESTConfig          See Lightsabers RESTDataSource documentation
     */
    setRESTConfig: function( RESTConfig ) {
            var rest = (!RESTConfig || !RESTConfig.unsecured) ? new LSREST( RESTConfig) : new REST( RESTConfig);
            this.setDataSource( rest);
    },
    
    /**
     * Sets the dynamic query parameters block
     */
    setQueryParams: function(qparams) {
    	this.getDataSource().setQueryParams(qparams);
    },
    
    create: Utils.create
    
  });

  RESTModel.extend = Utils.extend;
  
  return RESTModel;

});
/**
Core <em>Secured REST Session</em> *Singleton* component 
that exposes <code>login</code> and <code>logout</code> API methods.

Settings are similar to {{#crossLink "Lightsaber.Core.RESTDataSource"}}{{/crossLink}}. For example:

```javascript
var restOpts = { 
    login: {
        method:'POST', 
        contentType:'application/json', 
        url: 'secured/login'
    }
};

var MySession = RESTSession.extend(null, {rest: restOpts});
MySession.login('MyUsername', 'MyPassword');
```

@class Lightsaber.Core.RESTSession
@namespace Lightsaber.Core
@module Lightsaber.Core
@extends Object

@since 9.0.0

@requires underscore
@requires backbone
@requires Lightsaber.Core.Utils
@requires Lightsaber.Core.RESTModel

@examples Lightsaber.Core.Model

@constructor
**/
define('src/core/dataSource/RESTSession',[
    'underscore', 
    'backbone', 
    'src/core/util/Utils', 
    'src/core/model/RESTModel'
], function(_, Backbone, Utils, RESTModel) {

    

    var RESTSession  = function() {
    /** @lends Lightsaber.RESTSession.prototype */
    };

    
    /**
     * @private
     */
    RESTSession.init = function() {
    	if (!this.model) {
    		var options = { 'read': this.rest && this.rest.login };    		 
    		this.model = new RESTModel( null, { rest: options } );
    	}
    };

    
    /**
    Tries to associate the application with a session by requesting a new session from the server.
    
    @method login
    @param {String} username user name
    @param {String} password password
    @param {Object} [options] options passed to the *login* service
    **/
    RESTSession.login = function( username, password, options) {
    	this.init();
    	this.model.set( {user:username, password:password} );
    	this.model.fetch( options);
    };

    
    /**
    Logs out from currently associated session (client-side only) by resetting itself and removing 
    the stored token.

    @method logout
    **/
    RESTSession.logout = function() {
    	this.init();
    	this.model.getDataSource().setToken( undefined, true);
    };

    RESTSession.extend = Utils.extend;
    RESTSession.prototype.create = Utils.create;

    return RESTSession;
});
/**
 * @class Collection
 * @type Collection
 * @name Collection
 * @memberOf Lightsaber.Core
 * @extends Backbone.Collection
 * @description
 * The Lightsaber's Collection class. Adds the ability for detachable data source.
 */


define('src/core/model/Collection',['jquery',
        'underscore',
        'backbone',
        'src/core/model/Model',
        'src/core/dataSource/RESTDataSource',
        'src/core/dataSource/LSRESTDataSource',
        'src/core/model/ErrorHandler',
        'src/core/util/Utils'],
        function($,_, Backbone, Model, REST, LSREST, ErrorHandler, Utils) {


  var Collection = Backbone.Collection.extend({


      model: Model,

      /**
       * Initializes the instance. Is usually called from the constructor
       * @methodOf Lightsaber.Core.Collection#
       * @name initialize
       * @param {Object}      [models]                The initial models of the created collection instance
       * @param {Object}      [options]                The options to use
       * @param {Object}        [options.rest]            See Lightsaber's RESTDataSource documentation
       * @param {String}        [options.url]             The Model's URL
       * @param {Object}        [options.pagination]    {pageStart,pageSize, nextURL, prevURL}
       * @param {Object}        [options.sorting]        Sorting Criteria (see setSorting)
       * @param {Object}        [options.filtering]        Filtering Criteria (see setFiltering)
       */
      initialize: function( models, options) {
          var opts = _.defaults( options || {}, this.options);

          if ( opts.rest )
              this.setRESTConfig( opts.rest );

          if ( opts.url )
              this.url = opts.url;

          if ( opts.pagination ) {
              this.pagination = {};
              this.reset();
              this.setPagination( opts.pagination);
          }

          if ( opts.sorting )
              this.setSorting( opts.sorting, true);

          if ( opts.filtering )
              this.setFiltering( opts.filtering, true);

          if ( opts.errorHandler ) // set instance error handler hides global handler
              this.errorHandler = opts.errorHandler;

          this.on( 'change', function(){ this.hasModelChanged = true;}, this);
          this.on( 'sort', function(o){ this.trigger( 'reset', o);}, this);

          this.added = 0;
      },

      /**
       * Adds a model (or an array of models) to the collection, firing an "add" event.
       * @methodOf Lightsaber.Core.Collection#
       * @name add
       * @param {array} models
       * @param {Object} options
       */
      add: function( models, options) {
          var len = _.isArray(models)? models.length: 1;
          if (len === 0 || !models)
              return;

          options || (options = {});
          if ( !options.isRest && this.pagination && this.pagination.all && this.length !== this.pagination.all.length )
              throw 'cannot add when holes exist';

          var index = options.at ? options.at : this.models.length;

          if ( !options.isRest)
              this.added += len;

          Backbone.Collection.prototype.add.call( this, models, options);

          if (this.serverPagination && this.pagination) {

              if ( options.isRest ||  !options.at ) {
                  var pindex = !options.isRest ? this.pagination.all.length: this.added + options.pageStart;

                  while ( len-- !== 0 ) {
                      this.pagination.all[pindex] = this.at(index);
                      pindex++; index++;
                  }
              }
              else {
                  models = this.models.slice( index, index + len );
                  Array.prototype.splice.apply( this.pagination.all, [options.at, 0].concat(models) );
              }

          }

      },

      /**
       * Sets a data source. This allows to switch data source for the collection on the fly.
       * It may discard existing sorting and filtering criteria if not compatible with the assigned data source.
       * @methodOf Lightsaber.Core.Collection#
       * @name setDataSource
       * @param {Object}    dataSource               An object having a getSync() method
       * @param {Object}    [options]                The options to use
       * @param {Function}    [options.mapModel]     Receives a model. For modifying models
       * @param {String}      [options.idAttribute]  The new id attribute
       */
        setDataSource: function( dataSource, options) {
            this.dataSource = dataSource;
            if (dataSource) {
                this.serverPagination = dataSource.getProperties().supportsPagination;
                this.serverSorting = dataSource.getProperties().supportsSorting;

                if (!this._checkSortingCriteria(this.sorting))
                    this.sorting = undefined;
                if (!this._checkSortingCriteria(this.comparator))
                    this.comparator = undefined;

                this.setSync( dataSource.getSync(), options);
            }
            else {
                this.serverPagination = undefined;
                this.serverSorting = undefined;
            }

            var models = this.models;
            this.reset( null, {silent:true});
            this.add( models, {silent:true});
        },


        /**
         * Returns the last data source that was set
         * @methodOf Lightsaber.Core.Collection#
         * @name getDataSource
         */
        getDataSource: function() {
            return this.dataSource;
        },


        /**
         * Sets an attribute
         * @methodOf Lightsaber.Core.Collection#
         * @name setAttribute
         * @param {String}    key      The attribute key
         * @param {Object}    value    The attribute value
         */
        setAttribute: function( key, value ) {
            if ( !this.attributes ) {
                this.attributes = {};
            }
            this.attributes[key] = value;
        },

        /**
         * Gets an attribute
         * @methodOf Lightsaber.Core.Collection#
         * @name getAttribute
         * @param {String}    key      The attribute key
         * @returns {Object}  The attribute value
         */
        getAttribute: function( key ) {
            if (this.attributes)
                return this.attributes[ key ];
        },


        get: function( key ) {
            var value = _.isString(key)? this.getAttribute(key) : undefined;

            return _.isUndefined(value)? Backbone.Collection.prototype.get.call( this, key): value;
        },


        /**
         * Configures the REST data source for the instance. Instantiates a new RESTDataSource
         * @methodOf Lightsaber.Core.Collection#
         * @name setRESTConfig
         * @param {Object}      RESTConfig          See Lightsaber's RESTDataSource documentation
         */
        setRESTConfig: function( RESTConfig ) {
            var rest = (!RESTConfig || !RESTConfig.unsecured) ? new LSREST( RESTConfig) : new REST( RESTConfig);
            this.setDataSource( rest);
        },


        /**
         * Configures the Pagination for the instance.
         * @methodOf Lightsaber.Core.Collection#
         * @name setPagination
         * @param {Object}      paginationConfig       { pageSize: <size>, pageStart: <index> }
         */
        setPagination: function( paginationConfig ) {
            this.pagination || (this.pagination = {});

            if ( _.isNumber( paginationConfig.pageStart) ) {
                this.pagination.pageStart = paginationConfig.pageStart;
            }

            if ( _.isNumber( paginationConfig.pageSize) ) {
                this.pagination.pageSize = paginationConfig.pageSize;
            }

        },


        /**
         * Configures the Sorting for the instance.
         * For server side sorting the SortingCriterion is any object as defined by the server and fetch() is called
         * For client Side sorting the SortingCriterion is a Backbone comparator: a function
         * @methodOf Lightsaber.Core.Collection#
         * @name setSorting
         * @param {Object}      sortingConfig       SortingCriterion
         * @param {boolean}      [preventFetch]
         */
        setSorting: function( sortingConfig, preventFetch ) {
            if ( !this._checkSortingCriteria(sortingConfig) )
                throw 'sorting is not compatible with data source';

            var shouldFetch = !sortingConfig && this.sorting;

            if (_.isFunction(sortingConfig)) {
                this.comparator = sortingConfig;
                this.sorting = undefined;
            }
            else {
                this.sorting = _.clone( sortingConfig );
                this.comparator = undefined;
            }

            if (this.serverSorting && (shouldFetch || this.sorting) && !preventFetch)
                this.fetch();
            if (this.comparator)
                this.sort();
        },


        /**
         * Returns Sorting criteria
         * @methodOf Lightsaber.Core.Collection#
         * @name getSorting
         * @returns {Object} the current sorting criteria
         */
        getSorting: function() {
            return this.sorting? this.sorting: this.comparator;
        },


        /**
         * Configures the Filtering for the instance and calls fetch().
         * Note: client side filtering is not supported when pagination is not configured
         * @methodOf Lightsaber.Core.Collection#
         * @name setFiltering
         * @param {Object}      sortingConfig       Filtering Criteria      is function for client side. is value object for server side.
         * @param {boolean}      [preventFetch]
         */
        setFiltering: function( filteringConfig, preventFetch ) {
            if (!filteringConfig) {
                this.filterator = undefined;
                this.filtering = undefined;
            }
            if (_.isFunction(filteringConfig))
                this.filterator = filteringConfig;
            else
                this.filtering = _.clone( filteringConfig );

            if (this.getDataSource() && !preventFetch)
                this.fetch();
        },


        /**
         * Returns filtering criteria
         * @methodOf Lightsaber.Core.Collection#
         * @name getFiltering
         */
        getFiltering: function() {
            return this.filtering;
        },


        /**
         * Temporarily sets the URL for one subsequent next call. Later calls to the next method revert to default behavior (using an updated pageStart).
         * @methodOf Lightsaber.Core.Collection#
         * @name setNextURL
         * @param {String} url to set
         */
        setNextURL: function(url) {
            return this.pagination.nextURL = url;
        },


        /**
         * Temporarily sets the URL for one subsequent prev call. Later calls to the prev method revert to default behavior (using an updated pageStart).
         * @methodOf Lightsaber.Core.Collection#
         * @name setPrevURL
         * @param {String} url to set
         */
        setPrevURL: function(url) {
            return this.pagination.prevURL = url;
        },


        /**
         * Returns collection's features
         * @methodOf Lightsaber.Core.Collection#
         * @name getProperties
         * @returns {Object} the underlying data source's properties
         */
        getProperties: function() {
            return this.dataSource.getProperties();
        },


        /**
         * Requests rows by absolute indexes. When data is ready for the requested rows, a dataReady event is fired.
         * @methodOf Lightsaber.Core.Collection#
         * @name gotoRows
         * @param {Number} from - the index of the first requested row
         * @param {Number} [to] - up to row. Defaults to pageSize up to total or total if no pagination
         * @param {Object} [options]  May contain success and error call-backs which will be passed (collection, response) as arguments.
         */
        gotoRows: function( from, to, options) {

            if ( from < 0 )
                from = 0;

            if ( !_.isNumber(to)) {
                options = to;
                to = this._getDefaultTo(from);
            }

            if (from >= to)
                throw '"from" should be less than "to"';
            if ( this.pagination.maxIndex && to > this.pagination.maxIndex + this.added)
                throw 'requested rows are out of bounds';
            if (from > this.length && this.added)
                throw 'cannot goto when items were added';

            options = options ? _.clone(options) : {};
            this.pagination.pageStart = from;
            
            this.pagination.pageNum = Math.ceil(((to-from)/this.pagination.pageSize)-1);

            if ( this.isPageAvailable( from, to) ) {
                if (options.success)
                    options.success(this, undefined);
                   this.triggerDataReady( from, to-from);
                   return $.Deferred().resolve().promise();
            }

            for (var i = from;  i < to; i++)
                if ( _.isUndefined( this.serverPagination? this.pagination.all[i] : this.at(i)) )
                    break;
                else
                    from++;

            if ( _.isUndefined(this.dataSource) )
                throw 'data source does not exist';

            var method;
            if (this.serverPagination) {
                method = 'readPage';
                options.pagination = {pageStart: from-this.added, pageSize: to-from};
            }
            else {
                method = 'read';
            }

            var collection = this;
            var ver = { orig: this.pagination.ver };
            var success = options.success;
            options.success = function( response, status, xhr) {
                if (ver.orig !== collection.pagination.ver)
                    return;

                if (collection.filterator) {
                    if (!collection.serverPagination)
                        response = _.filter(response, collection.filterator);
                    else
                        response.data = _.filter(response.data, collection.filterator);
                }

                if (!collection.serverPagination)
                    response =  { pageStart: 0, pageSize: collection.pagination.pageSize, totalSize: response.length, data: response};

                if (response.totalSize)
                    collection.pagination.maxIndex = response.totalSize;
                else if (!_.isUndefined(response.hasMore)) {
                    if (response.hasMore)
                        //Adding additional dummy record count to indicate there is at least one record more
                        collection.pagination.maxIndex = response.pageStart + response.data.length+1;
                    else
                        collection.pagination.maxIndex = response.pageStart + response.data.length;

                    collection.pagination.hasMore=response.hasMore;
                }

                var opts = { silent: true, isRest: true, pageStart: response.pageStart};
                collection.add( response.data, opts);

                if (collection.length === response.data.length)
                    collection.trigger('reset', collection );
                else
                    collection.triggerDataReady( response.pageStart+collection.added, response.data.length);

                if (success) success( collection, response.data, response);
            };

            Backbone.wrapError(collection, options);
            this.serverSorting && (options.sorting = this.sorting);
            options.filtering = this.filtering;
            return this.sync.call( this, method, this, options);
        },


        /**
         * Requests a page by the absolute number of the page. When data is ready for the requested page, a dataReady event is fired.
         * @methodOf Lightsaber.Core.Collection#
         * @name gotoPage
         * @param {Number} pageNum - the number of the requested page. 0 - based.
         * @param {Object} [options]  May contain success and error call-backs which will be passed (collection, response) as arguments.
         */
        gotoPage: function( pageNum, options) {
            var from = pageNum * this.pagination.pageSize;
            return this.gotoRows( from, options);
        },


        updateOptionsWithFullURL: function(urlAttName, options) {
            if ( _.isString(this.pagination[urlAttName])) {
                options || (options = {});
                options.fullURL || (options.fullURL = this.pagination[urlAttName]);
                delete this.pagination[urlAttName];
            }
            return options;
        },

        /**
         * Requests the next page
         * @methodOf Lightsaber.Core.Collection#
         * @name next
         * @param {Number} [num] relative next page to retrieve. Defaults to 1.
         * @param {Object} [options.success]  callback which will be passed (collection, response) as arguments.
         * @param {Object} [options.error]    callback which will be passed (collection, response) as arguments.
         * @param {Object} [options.fullURL]  set the final URL.
         */
        next: function( num, options ) {
            var pageStart =  this.pagination.pageStart;

            if ( !_.isNumber(num)) {
                options = num;
                pageStart += this.pagination.pageSize;
            }
            else {
                pageStart += this.pagination.pageSize * num;
            }

            options = this.updateOptionsWithFullURL('nextURL',options);
            
            return this.gotoRows( pageStart, options);
        },


        accNext: function() {
            var pageStart =  0;
            var options = this.updateOptionsWithFullURL('nextURL');

            var nextPageNum = this.getPageNum()+1;
            var to = (nextPageNum * this.pagination.pageSize) + this.pagination.pageSize;
            to = Math.min(this.pagination.maxIndex, to);
            
            return this.gotoRows( pageStart, to, options);
        },



        /**
         * Requests the previous page
         * @methodOf Lightsaber.Core.Collection#
         * @name prev
         * @param {Number} [num] relative next page to retrieve. Defaults to 1.
         * @param {Object} [options.success]  callback which will be passed (collection, response) as arguments.
         * @param {Object} [options.error]    callback which will be passed (collection, response) as arguments.
         * @param {Object} [options.fullURL]  set the final URL.
         */
        prev: function( num, options ) {
            var pageStart =  this.pagination.pageStart;

            if ( !_.isNumber(num)) {
                options = num;
                pageStart -= this.pagination.pageSize;
            }
            else {
                pageStart -= this.pagination.pageSize * num;
            }

            options = this.updateOptionsWithFullURL('prevURL',options);
            
            return this.gotoRows( pageStart, options);
        },

        accPrev: function() {
            var pageStart =  0;
            var options   = this.updateOptionsWithFullURL('prevURL');

            var nextPageNum = this.getPageNum()+1;
            var to = (nextPageNum * this.pagination.pageSize) - this.pagination.pageSize;
            to = Math.min(this.pagination.maxIndex, to);
            
            return this.gotoRows( pageStart, to, options);
        },

        /**
         * Requests the default set of models for this collection from the data source, resetting the collection when
         * they arrive. When pagination is supported the default set is the first page, otherwise it's the whole set.
         * When data is ready the reset event is fired.
         * @methodOf Lightsaber.Core.Collection#
         * @name fetch
         * @param {Object}      [options]
         */
        fetch: function( options) {
            this.reset( undefined, {silent:true});
            options || ( options = {});
            if (this.serverSorting && this.sorting || this.filtering) {
                this.serverSorting && (options.sorting = this.sorting);
                options.filtering = this.filtering;
            }

            options.reset = true;
            return this.pagination ?
                    this.gotoRows( 0, options) :
                    Backbone.Collection.prototype.fetch.call( this, options);
        },


        /**
         * Retrieves a page as an array of models, the starting index and the total size if available.
         * @methodOf Lightsaber.Core.Collection#
         * @name getPage
         * @param {Number}      [pageNum]     positive, 0 - based, defaults to 0
         */
        getPage: function( pageNum ) {
            if (_.isUndefined(pageNum))
                pageNum = 0;

            var from = this.pagination? pageNum * this.pagination.pageSize: 0;

            return this.getRows(from);
        },


        /**
         * Retrieves the rows as an array of models, the starting index and the total size if available.
         * @methodOf Lightsaber.Core.Collection#
         * @name getRows
         * @param {Number}      from     positive
         * @param {Number}      [to]     positive, if not specified, uses page size up to total rows
         */
        getRows: function( from, to) {
            var rows;
            if (this.hasModelChanged) {
                this.hasModelChanged = undefined;
                this.setSorting( this.getSorting() );
            }

            if (this.pagination) {
                var allowPartial = this.pagination.maxIndex === 0;
                rows = this.isPageAvailable( from, to, allowPartial)?
                        this._makePage( from, to, allowPartial):
                        { data: [], info: { totalSize: 0 } };
            }
            else {
                rows = {
                    data: this.models.slice(),
                    info: { totalSize: this.length }
                };
            }
            return rows;
        },


        /**
         * Checks if page is currently available.
         * @methodOf Lightsaber.Core.Collection#
         * @name isPageAvailable
         * @param {Number}      fromIndex
         * @param {Number}      [toIndex]        if not specified, uses page size up to total rows
         * @param {Boolean}     [allowPartial]        if true, allows partial pages
         * @returns {Boolean}
         */
        isPageAvailable: function( fromIndex, toIndex, allowPartial ) {
            if (_.isBoolean(toIndex)) {
                allowPartial = toIndex;
                toIndex = undefined;
            }

            if (!_.isNumber(toIndex)) {
                toIndex = this._getDefaultTo(fromIndex);
            }

            var isAvailable = undefined;

            if ( this.serverPagination ) {
                if (fromIndex >= toIndex || (toIndex > this.pagination.all.length && !allowPartial) )
                    isAvailable = false;

                   for (var i = fromIndex; isAvailable === undefined && i < toIndex; i++) {
                       if ( _.isUndefined( this.pagination.all[i] )  && !allowPartial )
                           isAvailable = false;
                       else if ( !_.isUndefined( this.pagination.all[i] )  && allowPartial )
                           isAvailable = true;
                   }

                   isAvailable === undefined && (isAvailable = !allowPartial);
            }
            else
                isAvailable = fromIndex < toIndex && (toIndex <= this.models.length || allowPartial) || !this.getDataSource();

            return isAvailable;
        },


        /** @private */
        triggerDataReady: function( pageStart, pageSize) {
            this.trigger( 'dataReady', { pageStart: pageStart,
                                         pageNum: this.getPageNum(pageStart),
                                         pageSize: pageSize }, this );
        },


        /**
         * Reset all data except for pageSize.
         * @methodOf Lightsaber.Core.Collection#
         * @name reset
         * @param {Object|array} models
         * @param {Object} [options]
         */
        reset: function( models, options) {
            if ( this.pagination) {
                options || (options = {});
                var isSilent = options.silent;
                options.silent = true;
            }

            this.added = 0;
            Backbone.Collection.prototype.reset.call( this, models, options);

            if ( this.pagination ) {

                if ( _.isUndefined(this.pagination.ver))
                    this.pagination.ver = 0;
                else
                    this.pagination.ver++;

                if (this.serverPagination) {
                    this.pagination.all = [];
                    for (var i=0; i < this.length; i++)
                        this.pagination.all[i] = this.at(i);
                }

                this.pagination.pageStart = 0;
                if ( !_.isNumber( this.pagination.pageSize) )
                    this.pagination.pageSize = 0;

                this.pagination.maxIndex = 0;
                this.pagination.nextURL = undefined;
                this.pagination.prevURL = undefined;

                if (!isSilent) {
                    this.trigger('reset', this, options);
                    options.silent = isSilent;
                }
            }

            return this;
        },

        isAccumelated: function(){
            if (this.pagination && _.isNumber(this.pagination.pageStart))
                return this.pagination.pageStart === 0 && this.pagination.pageNum>=1 ;
            return false;
        },
        /**
         * Returns the page number if row is on page boundary, otherwise returns lower bound
         * @methodOf Lightsaber.Core.Collection#
         * @name getPageNum
         * @param {Number}      [row]      Default is last request
         * @returns {Number}
         */
        getPageNum: function(row) {
            
            if (this.pagination){
                if (this.isAccumelated()  && _.isNumber(this.pagination.pageNum))
                    return this.pagination.pageNum;

                var num = _.isUndefined(row)? this.pagination.pageStart: row;
                return Math.floor( num / this.pagination.pageSize);
            }
            return 0;

        },


        /** @private */
        setSync: function( sync, options) {
            options || (options = {});

            var nSync = function( method, model, options) {
                if ( this.currentErrorHandler !== this.errorHandler) {
                    if (this.currentErrorHandler)
                        this.off( 'error', this.currentErrorHandler );

                    this.currentErrorHandler = this.errorHandler;
                    this.on ( 'error', this.currentErrorHandler );
                }

                return sync( method, model, options);
             };

            this.sync = nSync;

            this.model.sync = nSync;
            this.model.idAttribute = options.idAttribute;

            _.each(this.models, function(existingModel) {
                existingModel.setSync(sync, options);
            });

            if (options.idAttribute) {
                this.reset(this.models);
            }
        },

        setPayload: function(payload) {
            this.payload = payload;
        },
        toJSON: function() {
            return this.payload? this.payload: Backbone.Collection.prototype.toJSON.call( this );
        },

         /**
         * Returns the the total number of pages. Returns undefined if it's unknown.
         * @methodOf Lightsaber.Core.Collection#
         * @name getTotalPagesNumber
         * @returns {Number|undefined}
         */
        getTotalPagesNumber: function() {
            var totalPagesNumber = ( !_.isUndefined(this.pagination.hasMore) && !this.pagination.hasMore  ||
                                     _.isUndefined(this.pagination.hasMore) && this.pagination.maxIndex ) ?
                Math.ceil( (this.pagination.maxIndex + this.added) / this.pagination.pageSize) : undefined;

            return totalPagesNumber;
        },

         /**
         * Returns the the current page number.
         * @methodOf Lightsaber.Core.Collection#
         * @name getCurrentPageNumber
         * @returns {Number}
         */
        getCurrentPageNumber: function() {
            return this.getPageNum();
        },

         /**
         * Checks if the previous page exists (it may need to be fetched). Returns undefined if unknown.
         * @methodOf Lightsaber.Core.Collection#
         * @name hasPrev
         * @param {Number} [pageNum] the page that the check is relative to. Defaults to the current page.
         * @returns {boolean|undefined}
         */
        hasPrev: function(pageNum) {
            !_.isUndefined(pageNum) || ( pageNum = this.getPageNum() );
            var hasPrev = undefined;

            var hasPrev = !_.isUndefined(this.pagination.maxIndex) ?
                pageNum > 0 && (pageNum-1) * this.pagination.pageSize < this.pagination.maxIndex + this.added : undefined;

            return hasPrev;
        },

         /**
         * Checks if the next page exists (it may need to be fetched). Returns undefined if unknown.
         * @methodOf Lightsaber.Core.Collection#
         * @name hasNext
         * @param {Number} [pageNum] the page that the check is relative to. Defaults to the current page.
         * @returns {boolean|undefined}
         */
        hasNext: function(pageNum) {
            !_.isUndefined(pageNum) || ( pageNum = this.getPageNum() );
            var hasNext = undefined;

            if (_.isUndefined(this.pagination.maxIndex))
                hasNext = undefined;
            else if ((pageNum+1) * this.pagination.pageSize < this.pagination.maxIndex + this.added)
                hasNext = true
            else 
                hasNext = (this.pagination.hasMore === false)? false: undefined;

            return hasNext;
        },

        /** @private */
        _prepareModel: function(model, options) {

            if (!(model instanceof Backbone.Model)) {
                var attrs = model;
                options.collection = this;
                model = new this.model(attrs, options);
                if (!model._validate(model.attributes, options)) model = false;
            }
            else if (!model.collection) {
                model.collection = this;
            }

            model.sync = this.model.sync;
            if (this.model.idAttribute) {
                model.idAttribute = this.model.idAttribute;
            }

            return model;
        },


        /** @private
         *  @param {Number}      from          Starting row
         *  @param {Number}      [to]          Up to row
         * @param {Boolean}     [allowPartial]        if true, allows partial pages
         */
        _makePage: function( from, to, allowPartial) {
            if (_.isBoolean(to)) {
                allowPartial = to;
                to = undefined;
            }

            if (!_.isNumber(to)) {
                to = this._getDefaultTo(from);
            }

            var models = this.serverPagination? this.pagination.all: this.models;
            var data = _.reduce( models, function(m, v, i) {
                if ( i >= from && i < to && !_.isUndefined(v))
                    m.push(v);
                return m;
            }, []);

            var totalSize = (this.getDataSource() && !this.pagination.maxIndex)? 0: this.pagination.maxIndex + this.added;
            return {
                data: data,
                info: {
                    pageStart: from,
                    pageNum: this.getPageNum(from),
                    pageSize: this.pagination.pageSize,
                    totalSize: totalSize,
                    hasMore: this.pagination.hasMore,
                    totalPages: Math.ceil( totalSize / this.pagination.pageSize) }
            };
        },


        /** @private */
        _getDefaultTo: function( from ) {
            if ( this.pagination ) {
                var to = from + this.pagination.pageSize;
                if (this.pagination.maxIndex)
                    to = Math.min( to, this.pagination.maxIndex+this.added);
            }
            else
                to = this.models.length;

            return to;
        },

        /** @private */
        _checkSortingCriteria: function( criteria ) {
            var isOK = true;
            if ( !this.getDataSource() || _.isNull(criteria) || _.isUndefined(criteria) )
                return isOK;

            if (this.serverPagination) {
                isOK =  this.serverSorting && !_.isFunction(criteria) && _.isObject(criteria);
            }
            else {
                isOK = this.serverSorting? _.isObject(criteria): _.isFunction(criteria);
            }

            return isOK;
        },

        errorHandler: ErrorHandler.handleError,

        createComponent: Utils.create
  }, {

      /**
       * Sets the global default error handler
       * @methodOf Lightsaber.Core.Collection
       * @name setGlobalErrorHandler
       * @param {Function} handler
       *
       */
      setGlobalErrorHandler: function( handler ) {
          this.prototype.errorHandler = handler;
      },

      /**
       * Unsets the global default error handler
       * @methodOf Lightsaber.Core.Collection
       * @name unsetGlobalErrorHandler
       */
      unsetGlobalErrorHandler: function( ) {
          delete this.prototype.errorHandler;
      }
  });

  /**
   * @methodOf Lightsaber.Core.Collection
   * @name extend
   */
  Collection.extend = Utils.extend;

  return Collection;
});


define('src/core/viewModel/ViewModelConstructor',['underscore',
		'src/core/util/Utils',
		'src/core/model/Model'],
function(_, Utils, Model) {

	var commonConfig = {
		visible: true,
		enabled: true
	};

	/**
	 * ViewModel constructor. Constructs a ViewModel, sets models, config and data properties.
	 *
	 * Invokes {@link #initialize} method
	 * when ViewModel is created.
	 * Holds the component business logic.
	 * @extends Backbone.Events
	 * @param {Object} [options]
	 * 				Options for new ViewModel. Options will be copied to this.options property. 
	 * @param {Object} [options.models]
	 * 				Models of the ViewModel. It must be a hash map of name-value pairs, where value is a {@link Lightsaber.Core.Model}.
	 * 				If option is provided it is copied to this._models field, so it can be accessed from VievModel methods.
	 * 				If there is only one model specified, use {@link #defaultModel} method to get its name. 
	 * @param {Object} [options.subViewModels]
	 * 				Child ViewModels of this ViewModel. It must be a hash map of name-value pairs, where value is a {@link Lightsaber.Core.ViewModel}.
	 * 				If option is provided it is copied to this.subViewModels field, so it can be accessed from VievModel methods.
	 * 				Use {@link #getSubViewModel} method to get child ViewModel from the outside of this ViewModel.
	 * @param {Object} [options.data]
	 * 				Initialization values of ViewModel attributes. 
	 * 				Attributes can be accesed through {@link #attr} method.  
	 * @param {Object} [options.modelKeys:{}] mapping model fields to viewModel fields as <modelName>.<modelFieldName>:<vmFieldName>. Should only 
	 * 		be used when dataBinding is not used. modelName can be *. 
	 * @name Lightsaber.ViewModel
	 */
	var ViewModel = function(options) {
	    this.cid = _.uniqueId('vm');

	    // List of ViewModel options to be merged as properties.
	    options = options? _.clone(options): {};
	    options.models = _.extend( {}, this.models, options.models);
	    options.data = _.extend( {}, this.defaults, this.data, options.data);

	    Utils.configure(this, options, ['events', 'subViewModels']);

	    this.modelKeys = _.extend( {}, this.modelKeys, options.modelKeys);
	    options.attrs && (options.data = options.attrs);

	    this._models = options.models;
	    this._instantiateModels(options);
	    this.delegateEvents(this._models);
	    // TODO: check if it is necessary for binding
	    this.models = this._models || (this._models = {});

	    this._initializeData(options);
	    this.data.on('all', this._dataEventsHandler, this);
	    this.config = new Model(_.extend({}, commonConfig, this.config, options.config || {}));
	    this.config.on('all', this._configEventsHandler, this);

	    this.dataBindings = [].concat(options.dataBindings || [], this.dataBindings);
	    // Remove duplicates with priority to data bindings received from options
	    this.dataBindings = _.uniq(this.dataBindings, false, function(dataBinding) {
	        var result;
	        for (var fld in dataBinding) {
	            if(fld != "options") {
	                result = fld;
	                break;
	            }
	        }
	        return result;
	    }
	    );

	    this.subViewModels = _.extend({}, options.subViewModels, this.subViewModels);

	    this._instantiateSubViewModels(options);

	    this._references = 0;

	    this.set('subViewModels', this.subViewModels);
	    this.initialize.apply(this, arguments);

	    this._bindData();
	};
	return ViewModel;
});



/**
Date <em>Formatter</em> component. 
@class Lightsaber.Core.DateFormatter
@namespace Lightsaber.Core
@module Lightsaber.Core

@extends Object

@since 9.0.0
@requires underscore
@requires backbone
@requires Lightsaber.Core.Configuration
@requires single!Lightsaber.Core.FormattersContainer
@examples Lightsaber.Core.Formatter
@guides ["Designs/Formatter Design"]
@constructor
**/
define('src/core/formatter/DateFormatter',[
],function() {

	
	var DateFormatter = function(options) {
		if (options && options.resourceBundle) {
			this.resourceBundle = options.resourceBundle;
		}
	};

    /**
    Formats the date on the `value` parameter.

    For example:

    ```javascript
		var df = new DateFormatter({resourceBundle: rb});
		console.log(df.format(123456, 'yyyy-mm-dd'));		// outputs: 1970/01/01
		console.log(df.format(123456, 'HH:MM:ss mm/yyyy'))	// outputs: 02:02:03 01/1980
    ```

    @method format
    @param {String} dateValue value to be formatted
    @param {String} mask formatting mask
    @param {Boolean} [utc=false] indicates whether given value is in utc time
    @return {String} the formatted string
    **/
	DateFormatter.prototype.format = function(date, mask, utc) {
		var	token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZWN]|"[^"]*"|'[^']*'/g;
		var get = utc ? "getUTC" : "get",
			d = date[get + "Date"](),
			D = date[get + "Day"](),
			m = date[get + "Month"](),
			y = date[get + "FullYear"](),
			H = date[get + "Hours"](),
			M = date[get + "Minutes"](),
			s = date[get + "Seconds"](),
			L = date[get + "Milliseconds"](),
			o = utc ? 0 : date.getTimezoneOffset(),
			flags = {
				d:    d,
				dd:   pad(d),
				ddd:  getDayOfWeek(this.resourceBundle, D),
				dddd: getDayOfWeek(this.resourceBundle, D, "long"),
				m:    m + 1,
				mm:   pad(m + 1),
				mmm:  getMonthOfYear(this.resourceBundle, m),
				mmmm: getMonthOfYear(this.resourceBundle, m, "long"),
				yy:   String(y).slice(2),
				yyyy: y,
				h:    H % 12 || 12,
				hh:   pad(H % 12 || 12),
				H:    H,
				HH:   pad(H),
				M:    M,
				MM:   pad(M),
				s:    s,
				ss:   pad(s),
				l:    pad(L, 3),
				L:    pad(L > 99 ? Math.round(L / 10) : L),
				tt:   getDayPeriod(this.resourceBundle, H),
				TT:   getDayPeriod(this.resourceBundle, H, "caps"),
				o:    (o > 0 ? "-" : "+") + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),
				S:    getOrdinalNumber(this.resourceBundle, d)
			};		
			return mask.replace(token, function ($0) {
				return $0 in flags ? flags[$0] : $0.slice(1, $0.length - 1);
			});
	};

	// default values

	var defaultDayNames = [
		"Sun", "Mon", "Tue", "Wed",	"Thu", "Fri", "Sat",
		"Sunday", "Monday", "Tueday", "Wedesday", "Thursday", "Friday", "Saturday"
	];

	var defaultMonthNames = [
		"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
		"January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"
	]	

	var defaultOrdinalNumbers = [
		"1st", "2nd", "3rd", "4th", "5th", "6th", "7th", "8th", "9th", "10th",
		"11th", "12th", "13th", "14th", "15th", "16th", "17th", "18th", "19th", "20th",
		"21st", "22nd", "23rd", "24th", "25th", "26th", "27th", "28th", "29th", "30th", "31th"
	]	

	// private functions

	var pad = function (val, len) {
		val = String(val);
		len = len || 2;
		while (val.length < len) {
			val = "0" + val;
		}
		return val;
	}

	var getDayPeriod = function(rb, hour, type) {		
		var key = hour < 12 ? "am" : "pm";
		var dp = getStringValue(rb, key);			
		return type == "caps" ? dp.toUpperCase() : dp;		
	}

	var getOrdinalNumber = function(rb, num) {
		return getStringValue(rb, defaultOrdinalNumbers[num - 1]);		
	}

	var getDayOfWeek = function(rb, dow, type) {
		var dayIndex = type == "long" ? 7 + dow : dow;
		return getStringValue(rb, defaultDayNames[dayIndex]);
	}

	var getMonthOfYear = function(rb, moy, type) {
		var dayIndex = type == "long" ? 12 + moy : moy;
		return getStringValue(rb, defaultMonthNames[dayIndex]);
	}

	var getStringValue = function(rb, key) {
		if (rb) {
			var string = rb.getString(key);
			return typeof(string) != "undefined" ? string : key;
		}
		return key;
	}

	return DateFormatter;

});
/**

Core <em>FormattersContainer</em> component, responsible for accommodating all formatting functions. 

@class Lightsaber.Core.FormattersContainer
@namespace Lightsaber.Core
@module Lightsaber.Core
@extends Object

@since 9.0.0
@requires Lightsaber.Core.Utils
@requires Lightsaber.Core.Configuration
@requires Lightsaber.Core.DateFormatter

@examples Lightsaber.Core.Formatter
@guides ["Designs/Formatter Design"]
@constructor
**/

define('src/core/formatter/FormattersContainer',['src/core/util/Utils',
		'src/core/util/Configuration',
		'src/core/formatter/DateFormatter'], function (Utils, Configuration, DateFormatter) {

	var FormattersContainer = function () {};
    
    var _convertToNumber = function (value) {
         if (!isNaN(value)) {
            if (_.isString(value)) {
                value = parseFloat(value);
            }
        }
        return value;
    };
    /**
        All functions should be invoked in the following context
        > ```javascript
        > {
        >     getParams: function() {}, // returns formatting parameters passed
        >     getResourceBundle: function() {}, // returns the view model's resource bundle
        >     getVMData: function(key) {}, // returns the view model requested attribute
        > }
        > ```
    **/
    var innerFunctions = {       
        absNumberFormatter : function(value) {
            var options = this.getParams();
            var rb = this.getResourceBundle();
            var defaultNumberOfDecimalsKey = Configuration.get('defaultNumberOfDecimalsKey');            
            var defaultNumberOfDecimals = rb && rb.getString(defaultNumberOfDecimalsKey);            

            
            value = _convertToNumber (value);            
            
            if(_.isNumber(value) && value < 0) {
                value = Math.abs(value);
            }

            var fixedValue = (options && !isNaN(options.decimals))?  options.decimals :
                             (options && !isNaN(options.fixed)) ? options.fixed :
                             (rb && rb.getString(defaultNumberOfDecimalsKey));
            str = !isNaN(fixedValue) ? new String(Number(value).toFixed(fixedValue)) : new String(value);

            var decimal = str.match(/(.*)\.(.*)$/,'$2') ? str.replace(/(.*)\.(.*)$/,'$2') : '';
            var tsep = rb && rb.getString('thousandsSeparator') || ',', dmark = rb && rb.getString('decimalSeparator') || '.',
               string = _getWholePart(value).toString(),
               length = string.length,
               end = /^\d{4,}$/.test(string) ? length % 3 : 0;

            var result = (end ? string.slice(0, end) + tsep : '') + string.slice(end).replace(/(\d{3})(?=\d)/g, '$1' + tsep) + (decimal ? dmark + decimal : '');

            return result;
        },
        negativeSignFormatter : function (value) {
            var sign = '';
            
            value = _convertToNumber (value);
            if (value < 0) {
                sign = '-';                
            }             

            return sign;
        },
        negativeSignLocation : function () {
            var rb = this.getResourceBundle(),
                options = this.getParams();
            
            return (options && options.negativeLocation) || (rb && rb.getString('negativeLocation')) || 'left';
        }
    };

	var functions = {
	
	    /**
        Default number formatter.

        > **Note** that `default_number_formatter` is invoked in the following context:
        > 
        > ```javascript
        > {
        >     getParams: function() {}, // returns formatting parameters passed
        >     getResourceBundle: function() {}, // returns the view model's resource bundle
        >     getVMData: function(key) {}, // returns the view model requested attribute
        > }
        > ```
	    @method default_number_formatter

	    
	    @param {String} value
        @return {String} the formatted number
	    **/	
		default_number_formatter: function(value) {
            
            var result = innerFunctions.absNumberFormatter.call(this,value),
            sign = innerFunctions.negativeSignFormatter.call(this,value),            			
            signLocation = innerFunctions.negativeSignLocation.call(this);
            
            if (signLocation === 'right' || signLocation === 'r') {
                return result + sign;
            }
            else {
                return sign + result;                
            }
		},

	    /**
        Default mask formatter.
        > **Note** that `default_mask_formatter` is invoked in the following context:
        > 
        > ```javascript
        > {
        >     getParams: function() {}, // returns formatting parameters passed
        >     getResourceBundle: function() {}, // returns the view model's resource bundle
        >     getVMData: function(key) {}, // returns the view model requested attribute
        > }
        > ```

	    @method default_mask_formatter


	    @param {String} value
        @return {String} a string formatted according to the mask
	    **/	
		default_mask_formatter: function(value) {
			var rb = this.getResourceBundle();
			var params = this.getParams();
			if (rb && params.type) {
				var rbMaskValue = rb.getString(params.type);
				if (rbMaskValue) {
					return String(value).replace(rbMaskValue[0],rbMaskValue[1]);
				}
			}
			return value;
		},

	    /**
        Default date formatter.

        > **Note** that `default_date_formatter` is invoked in the following context:
        > 
        > ```javascript
        > {
        >     getParams: function() {}, // returns formatting parameters passed
        >     getResourceBundle: function() {}, // returns the view model's resource bundle
        >     getVMData: function(key) {}, // returns the view model requested attribute
        > }
        > ```

        @method default_date_formatter
	    @param {String} value
        @return {String} the formatted date string
	    **/	
		default_date_formatter: function(value) {
			
            if ( _.isNull(value) || _.isUndefined(value) ) {
                return undefined;
            }

            var dateObject = Utils.getDate(value);
			if (dateObject.toString() === 'Invalid Date') {
				return undefined;
			}
			var rb = this.getResourceBundle();
			if (rb) {
				var params = this.getParams();
				var rbMaskKeyParts = [this.getType()];
				if (params.type) {
					rbMaskKeyParts.push(params.type);
				}
				rbMaskKeyParts.push("mask");
				var rbMaskValue = rb.getString(rbMaskKeyParts.join("_")) || rb.getString(this.getType() + '_mask');
				if (rbMaskValue) {		
					return new DateFormatter({resourceBundle: rb}).format(dateObject, rbMaskValue);
				}
			}
			return dateObject.toLocaleString();
		},

         /**
        Default currency formatter.

        > **Note** that `default_currency_formatter` is invoked in the following context:
        > 
        > ```javascript
        > {
        >     getParams: function() {}, // returns formatting parameters passed
        >     getResourceBundle: function() {}, // returns the view model's resource bundle
        >     getVMData: function(key) {}, // returns the view model requested attribute
        > }
        > ```
	    @method default_currency_formatter

	    
	    @param {String} value
        @return {String} the formatted currency number
	    **/	
		default_currency_formatter: function(value) {             

            var options = this.getParams(),
                rb = this.getResourceBundle(),
                negativeSign = innerFunctions.negativeSignFormatter.call(this,value),
                negativeLocation = innerFunctions.negativeSignLocation.call(this),
                currencySpacer = (options && options.hasOwnProperty('currencySpacer'))? options.currencySpacer : ((rb && rb.getString('currencySpacer')) || ''),
                currencySymbol =  (options && options.currency) || (rb && rb.getString('currencySymbol')) || '$',
                currencyLocation = (rb && rb.getString('currencyLocation')) || 'left'; //supported values 'left'/'right'/'absLeft'/'absRight';


            
            var amount = innerFunctions.absNumberFormatter.call(this,value);
            var result = '';
            
            
            if (negativeLocation === 'right' || negativeLocation === 'r') {
                switch(currencyLocation) {
                    case 'right':
                    case 'r':
                        result =  amount + currencySymbol + currencySpacer +negativeSign ;
                    break;
                    case 'absRight':
                        result =  amount + negativeSign + currencySpacer +currencySymbol;
                    break;
                    default:
                        result = currencySymbol + currencySpacer + amount + negativeSign;
                    break;
                }
            }
            else{
                switch(currencyLocation) {
                    case 'right':                        
                    case 'r':
                    case 'absRight':
                        result =  negativeSign + amount+ currencySpacer + currencySymbol;
                    break;
                    case 'absLeft':
                        result =  currencySymbol + currencySpacer + negativeSign + amount;
                    break;
                    default:
                        result = negativeSign + currencySymbol + currencySpacer + amount;
                    break;
                }
            }
              return result;
		}
	};

	_.extend(FormattersContainer, {extend: Utils.extend});

	_.extend(FormattersContainer.prototype, functions);

	var _getWholePart = function(number) {
		var pos_int = Math.floor(number < 0 ? -number : number);
		return number < 0 ? -pos_int : pos_int;
	}

	return FormattersContainer;

});

/**
Base <em>Formatter</em> component. Intended to be extended by specific formatters.

Base <em>Formatter</em> (and other formatters extending from it) is responsible for delegating formatting 
to relevant formatting functions in {{#crossLink "Lightsaber.Core.FormattersContainer"}}{{/crossLink}}.

@class Lightsaber.Core.Formatter
@namespace Lightsaber.Core
@module Lightsaber.Core
@extends Object

@since 9.0.0
@requires underscore
@requires backbone
@requires Lightsaber.Core.Configuration
@requires single!Lightsaber.Core.FormattersContainer
@guides ["Designs/Formatter Design"]
@constructor
**/
define('src/core/formatter/Formatter',[
    'underscore', 
        'backbone', 
        'src/core/util/Configuration',
    'single!src/core/formatter/FormattersContainer'
],   function(_, Backbone, Configuration, FormattersContainer) {

    
  var Formatter = function() {};

    /**
    Formats the *ViewModel* properties based on the provided `options.formatType`.
    The formatter to be used is either:
    1. default one with value with `'default_<options.formatType>_formatter'` structure, as defined in 
        {{#crossLink "Lightsaber.Core.FormattersContainer"}}{{/crossLink}}, or
    2. custom, with `'<options.formatType>_formatter'` structure.
    For custom formatter - the name of the actual formatter function (which, for default one is `'default_<options.formatType>_formatter'`) 
    should be defined on {{#crossLink "Lightsaber.Core.Configuration"}}{{/crossLink}}:
    ```javascript
    {
        custom_formatter: 'customNumberFormatter',
    }
    ```
    and the function is defined on custom *FormattersContainer* that extends from 
    {{#crossLink "Lightsaber.Core.FormattersContainer"}}{{/crossLink}} and is injected into {{#crossLink "Lightsaber.Core.Formatter"}}{{/crossLink}} by 
    means of either:

    1. *RequireJS* override/replace, or
    2. extension of {{#crossLink "Lightsaber.Core.Formatter"}}{{/crossLink}} that uses a different *FormattersContainer*
    @method format
    @param {Object} bindContext 
    @param {Object} options
    @param {String} options.formatType formatting type
    @param {Array} options.fields *ViewModel* property names to format      
    @param {Object} [options.formatParams] formatting parameters  
    @return {String} the formatted string
    **/
  Formatter.prototype.format = function( bindContext, options ) {

    var formatType = options.formatType;
    
    if (typeof(formatType) == "undefined") { // if no formatting is specified
      throw new Error("Format type must be specified");
    }

    // fetches formatter function name from configuration. Fall back to 'default_<type>_formatter' if no formatter is configured
    var formatter;
    var configurationFormatter = Configuration.get(formatType + '_formatter');
    if ( configurationFormatter && FormattersContainer[configurationFormatter] ) {
      formatter = configurationFormatter;
    } else {
      formatter = 'default_' + formatType + '_formatter';
    }
    
    var context = _.extend(bindContext, {
      getParams: function() { return options.formatParams || {}; },
      getType: function() { return formatType; }
    });

    var fields = options.fields || [];
    var values = [];
    for (var i=0; i<fields.length; i++) {
      values.push(bindContext.getVMData(fields[i]));
    }

    return FormattersContainer[formatter] ? FormattersContainer[formatter].apply(context, values) : values.join(","); // return key if no formatters are available
  };

  Formatter.prototype.formatCurrentBindingContext = function(fields, type, params) {
      var formattingOptions = {
          fields: _.isArray(fields) ? fields : [fields]
      };
      if (type) {
          formattingOptions.formatType = type;
      }
      if (params) {
          formattingOptions.formatParams = params;
      }
      return this.format(this.bindContext, formattingOptions);
  };
  return Formatter;

});



/**
 * @memberOf Lightsaber.Core
 * @name Binding
 * @class Binding
 * @type Constructor
 * @description 
 * 		The Lightsaber's Data Binding class. Provides the ability to bind changed in one object to actions on another one.
 * 		Objects can be plain Javascript objects, Models, ViewModels and DOM objects.
 */
define('src/core/binding/Binding',['jquery','underscore', 'backbone', 'single!src/core/formatter/Formatter', 'knockout'],   function($,_, Backbone, Formatter, KO) {
	

	/**
	 * @class Binding
	 */
	var Binding = function() {

		/** @private */
		this.groups = {};

		/** @private */
		this.bindings = {};

		/** @private */
		this.counter = 0;
	};

	/**
	 * Processes declarative data bindings defined on the passed object argument.
	 *
	 * The argument should contain a data member as below:
	 * dataBindings : [
	 *	 {  <path> : <value>,
	 *		options: { [dependencySet: <dependencySet>], [context: <context>], [set: <set>] }
	 *	 },
	 * ];
	 *
	 * Where,
	 *   path - String. The path to the field
	 *
	 * @methodOf Lightsaber.Core.Binding
	 * @name bindAll
	 * @param {Object}	context	  May contain a "dataBindings" data member
	 * @param {Object}	[bindings]   An explicit dataBindings array
	 */

	Binding.prototype.bindAll = function( context, bindings ) {
		var dataBindings = bindings || context && context.dataBindings || [];

		for (var i in dataBindings) {
			var target, value;
			for (var a in dataBindings[i]) {
				switch(a) {
				case 'options': break;
				default: target = a; value = dataBindings[i][a]; break;
				}
			}

			this.bind( context, target, value, dataBindings[i].options);
		}
	};

	/**
	 * Binds a value to a target.
	 * 
	 * @methodOf Lightsaber.Core.Binding
	 * @name bind
	 * @param {Object}	[context]   The context object
	 * @param {Function}  target	  Path, function(value, options).
	 * @param {Function}  value	   Path, function(context,models) or expression. Function should have no side effects.
	 * @param {Object}	[options]   The options to use
	 * @param {Object}	  [options.dependencySet]	An array of {bean:<bean>, field:<field name>}
	 * @param {Object}	  [options.context]		  context
	 * @param {Function}	[options.setter]		   setter
	 * @param {String}	  [options.set]			  set
	 * @param {Object}	  [options.groupId]		  groupId
	 * @param {Boolean}	 [options.dynamicDependency]	dynamicDependency
	 * @param {Boolean}	 [options.setOnBind]		setOnBind, true by default
	 * @param {Boolean}	 [options.twoWay]		   twoWay
	 * @param {Function}	[options.error]			Callback'd when target set has failed
	 * @param {Function}	[options.warning]		  Callback'd when target set has produced warnings
	 */
	Binding.prototype.bind = function( context, target, value, options) {

		if ( _.isFunction(context) || _.isString(context) ) {
			options = value;
			value = target;
			target = context;
			context = null;
		}
		options = _.extend( {}, options);
		var origTarget = target;
		var origValue = value;

		if (options.twoWay && !(_.isString(target) && _.isString(value)) ) {
			throw 'Two way binding can only be used for paths';				
		}

		if (options.setter) {
			if (options.set) {
				throw 'Options "set" and "setter" should not both be provided';
			}
			target = options.setter;
		}

		if ( _.isString(target) ) {
			target = this.handleTargetPath( target, context, options);
		}
		else if ( !_.isFunction(target) ) {
			throw 'Target cannot be an expression';
		}

		if ( _.isString(value) ) {
			value = this.handlePath( value, context, options);
		}
		else if ( !_.isFunction(value) ) {
			value = this.handleExpression( value.exp, context, options);
		}

		if (options.dependencySet && options.dynamicDependency) {
			throw 'Either options.dependencySet or options.dynamicDependency can be set';
		}

		this._bind( context, target, value, options);

		if (options.twoWay) {
			delete options.dependencySet;
			delete options.setter;
			options.setOnBind = false;
			delete options.targetField;
			delete options.targetObject;
			delete options.valueField;
			delete options.twoWay;

			this.bind(context, origValue, origTarget, options);
		}
	};


	/**
	 * Unbinds all existing data bindings that were marked by groupId or
	 * if groupId is not passed unbinds all existing data bindings of the data binding object.
	 *
	 * @methodOf Lightsaber.Core.Binding
	 * @name unbind
	 * @param {Object}	[groupId]	The object to apply the setter on
	 */
	Binding.prototype.unbind = function( groupId ) {
		if (groupId) {
			for (var j in this.groups[groupId]) {
				var i = this.groups[groupId][j];
				this.unbindDependencySet( this.bindings[i].dependencySet, this.bindings[i].handler);
				delete this.bindings[i];
			}
			delete this.groups[groupId];
		} else {
			for (var k in this.bindings) {
				this.unbindDependencySet( this.bindings[k].dependencySet, this.bindings[k].handler);
			}
			this.bindings = {};
			this.groups = {};
		}
	};

	/**
	 * @private
	 * Binds a value to a setter function.
	 * This method can deduce the value's dependency set. If needed the dependency set can be explicitly defined using options.dependencySet.
	 * If the dependency set is empty the setter is immediately called with the expression value.
	 * 
	 * @methodOf Lightsaber.Core.Binding
	 * @name _bind
	 * @param {Object}	[context]   The object to apply the setter on
	 * @param {Function}  setter	  The function to activate when setting the expression value
	 * @param {Function}  value	   Calculates the expression. Signature is function(context,models). Should have no side effects.
	 * @param {Object}	options	 The options to use. See bind 
	 */
	Binding.prototype._bind = function( context, setter, value, options) {

		var id = this.counter++;
		var inerror = _getInError(options, true);
		var inwarning = _getInError(options, false);
		var error = _getError(options);
		var opts = _.defaults( {error:inerror, warning:inwarning}, options);

		options.targetObject && options.targetField && error && options.targetObject.on && options.targetObject.on( 'error:' + options.targetField, error, this); // not nested

		var changeHandler = function(a,b,c) {
			var res = this.calcValue( value, context, options, options.dynamicDependency);
			if ( res.v !== this.bindings[id].v ) {
				this.bindings[id].v = res.v;
				opts._warningWasFound = c && c._warningWasFound;
				opts._bound = true;
				setter.call( context, res.v, opts );
				delete opts._warningWasFound;
			}
			if (options.dynamicDependency) {
				this.handleDependencySet( res.dependencySet, changeHandler,
						this.bindings[id].dependencySet, this.bindings[id].handler );
				this.bindings[id].dependencySet = res.dependencySet;
			}
		};

		// find dependency set
		var fixedDependencySet = options.dependencySet;
		var result = this.calcValue( value, context, options, !fixedDependencySet);
		var dependencySet = fixedDependencySet || result.dependencySet;

		if (dependencySet.length === 0  || !(options.setOnBind === false) ) {
			options._bound = true;
			setter.call( context, result.v, options );
		}

		if (dependencySet.length > 0) {  // bind to changes in dependency set
			this.handleDependencySet( dependencySet, changeHandler);
			this.bindings[id] = {};
			this.bindings[id].dependencySet = dependencySet;
			this.bindings[id].handler = changeHandler;
			this.bindings[id].v = result.v;

			if (options && options.groupId) {
				this.groups[options.groupId] || (this.groups[options.groupId] = []);
				this.groups[options.groupId].push(id);
			}
		}
	};


	/**
	 * @private
	 */
	Binding.prototype.handleTargetPath = function( target, context, options) {
		var segments = target.split('.');

		if ( _.isEqual(segments[0], 'context') ) {
			if ( _.isUndefined(options.context) || _.isUndefined(options.context[segments[1]]) ) {
				throw 'When using context in path - options.context is mandatory';
			}
		}
		else if ( _.isNull(context) ) {
			throw 'When using this or models in path - default context is mandatory';
		}

		var exp = 'return ', currObj;
		switch ( segments[0] ) {
			case 'this': currObj = context; exp += 'this'; break;
			case 'models': currObj = context.models; exp += 'this.models'; break;
			case 'subViewModels': currObj = context.subViewModels; exp += 'this.subViewModels'; break;
			case 'context': currObj = options.context; exp += 'options.context'; break;
			default:
				segments.unshift('this');
				currObj = context; exp += 'this';
			break;
		}

		if (segments.length > 2 && typeof currObj.data === 'object' && currObj.data.__vmdata__) {
			exp += '.data';
			currObj = currObj.data;
		}

		var targetObject;
		for (var i=1; i < segments.length-1; i++) {
			var seg = segments[i];
			if (KO.isSubscribable(currObj[seg])) {
				targetObject = exp;
				exp += '.' + seg + '()';
				currObj = currObj[seg]();
			} else if ( _.isFunction(currObj.get) ) {
				targetObject = exp;
				exp += '.get("' + seg + '")';
				currObj = currObj.get(seg);
			} else {
				exp += '["' + seg + '"]';
				currObj = currObj[seg];
			}
		}

		seg = segments[i];
		options.targetField = options.targetField || seg;
		var set = options.set || 'set';
		if (KO.isSubscribable(currObj[seg])) {
			targetObject = exp;
			exp += '.' + seg + '(v)';
		} else if ( _.isFunction( currObj[set] ) ) {
			targetObject = exp;
			exp += '.' + set + '("' + seg + '", v, options)';
		} else {
			exp += '["' + seg + '"] = v';
		}

		options.targetObject || 
		(options.targetObject = targetObject?
				(new Function( 'options', targetObject )).call( context, options ):
				undefined);

		return new Function( 'v', 'options', exp );
	};

	/**
	 * @private
	 */
	Binding.prototype.handlePath = function( path, context, options) {
		var segments = path.split('.');

		if ( _.isEqual(segments[0], 'context') ) {
			if ( _.isUndefined(options.context) || _.isUndefined(options.context[segments[1]]) ) {
				throw 'When using context in path - options.context is mandatory';
			}
		}
		else if ( _.isNull(context) ) {
			throw 'When using this or models in path - default context is mandatory';
		}

		var currObj;
		var exp = segments[0];
		switch ( segments[0] ) {
			case 'this': currObj = context; break;
			case 'models': currObj = context.models; break;
			case 'subViewModels': currObj = context.subViewModels; exp = 'this.subViewModels'; break;
			case 'context': currObj = options.context; break;
			default:
				segments.unshift('this');
				currObj = context;
				exp = 'this';
			break;
		}

		for (var i=1; i < segments.length; i++) {
			var seg = segments[i];
			if (!currObj) 
				throw 'Object does not exist';
			else if (KO.isSubscribable(currObj[seg])) {
				exp += '.' + seg + '()';
				if (i < segments.length-1 )
					currObj = currObj[seg]();
			} else if ( _.isFunction(currObj.get) ) {
				exp += '.get("' + seg + '")';
				if (i < segments.length-1 )
					currObj = currObj.get(seg);
			} else {
				exp += '["' + seg + '"]';
				if (i < segments.length-1 )
					currObj = currObj[seg];
			}
		}
		options.valueObject = currObj;
		options.valueField = seg;
		return this.handleExpression( exp, context, options);
	};

	/**
	 * @private
	 */
	Binding.prototype.handleExpression = function( expression, context, options) {
		if (!_.isString(expression) || expression.length === 0) {
			throw 'expression cannot not be empty';
		}
		return new Function( 'context', 'models', 'return ' + expression);
	};

	/**
	 * @private
	 */
	Binding.prototype.calcValue = function(value, context, options, dynamicDependency) {
		var originalGet = Backbone.Model.prototype.get;
		var dependencySet = [];
		var v;

		Backbone.Model.prototype.get = function(v) {
			if (dynamicDependency) {
				dependencySet.push( {bean: this, field: v} );
			}
			return originalGet.call(this, v);
		};

		try {
			var evaluator = function() {
				return v = value.call(context, options.context, context?context.models: null);
			};
			var computed = KO.computed(evaluator);
			if (computed.isActive()) {
				dependencySet.push({
					KO: true,
					subscribable: computed
				});
			}

		} finally {
			Backbone.Model.prototype.get = originalGet;
		}

		return { v: v, dependencySet: dependencySet };
	};

	/**
	 * @private
	 */
	Binding.prototype.handleDependencySet = function( dependencySet, handler, prevDependencySet, prevHandler) {
		this.unbindDependencySet( prevDependencySet, prevHandler);
		for ( var i in dependencySet ) {
			if (dependencySet[i].KO) {
				dependencySet[i].subscription = dependencySet[i].subscribable.subscribe(handler, this);
			} else {
				dependencySet[i].bean.on( 'change:' + dependencySet[i].field, handler, this );
			}
		}
	};

	/**
	 * @private
	 */
	Binding.prototype.unbindDependencySet = function( dependencySet, handler) {
		for ( var i in dependencySet ) {
			if (dependencySet[i].KO) {
				dependencySet[i].subscription.dispose();
			} else {
				dependencySet[i].bean.off( 'change:' + dependencySet[i].field, handler, this );
			}
		}
	};

	/**
	 * Processes the bindings defined on the view's DOM elements.
	 *
	 * @methodOf Lightsaber.Core.Binding
	 * @name bindDOM
	 * @param {Object}	view			The view to bind
	 */
	Binding.prototype.bindDOM = function( view ) {
		this.unbindDOM( view);

		var groupId = '_' + view.cid;
		var options = { groupId: groupId};
		view.events || ( view.events = {});

		var handler = this._handle( this, view, options );

		if (view.$root.attr('data-ls-bind'))
			view.$root.each( handler );
		view.$root.find('[data-ls-bind]').each( handler );

		handler = this._handleAttribute( view, options );
		if (view.$root.attr('data-ls-bind-attr'))
			view.$root.each( handler );
		view.$root.find('[data-ls-bind-attr]').each( handler );

		if (! _.isEmpty(view.events) )
			view.delegateEvents();
	};

	/**
	 * Unbinds all DOM bindings.
	 *
	 * @methodOf Lightsaber.Core.Binding
	 * @name unbindDOM
	 * @param {Object}	view			The view to bind
	 */
	Binding.prototype.unbindDOM = function( view ) {
		var groupId = '_' + view.cid;
		this.unbind(groupId);
		view.undelegateEvents();
	};
	

	/**
	 * @private
	 */
	Binding.prototype._handle = function( binding, view, options) {
		var self = this;
		return function( index ) {
			var w = $(this);
			var bindOptions = Binding.getBindOptions(w.attr('data-ls-bind'));		
			var fields = bindOptions.fields; 
			
			// TODO: Support multiple fields
			switch (bindOptions.bindSetType) {
				case 'text':
					self._handleText( w, fields[0], binding, view, options, bindOptions);
					break;
				case 'value':
					self._handleValue( w, fields[0], binding, view, options, bindOptions);
					break;
				default: 
					break;
			}
		};
	};


  	Binding.getBindOptions = function( attrValue ) {

		var string = attrValue.replace(/\s+/g,"");
		var bindOptions = {};

		var params = {};
		var paramsRegex = /.*?\((.*)?\)/;
		if ( string.match( paramsRegex ) ) {
		  var paramsString = string.replace(paramsRegex,'$1');	  
		  _.each(paramsString.split(","), function(paramPair) {
			var pair = paramPair.split(":");
			params[pair[0]] = pair[1];
		  });
		}

		var typeRegex = /(.*?)\|(.*?)\(.*|(.*?)\|(.*?)/;

		if ( string.match(typeRegex) ) {
		  bindOptions.formatType = string.replace(typeRegex, '$2');
		}

		var bindSetTypeRegex = /^(.*?):.*/;
		bindOptions.bindSetType = string.replace(bindSetTypeRegex, '$1');

		var fieldsRegex = /.*?:(.*?)\|.*|.*?:(.*?)/;
		var fieldsString = string.replace(fieldsRegex, '$1');
		bindOptions.fields = fieldsString.split(",");

		return _.extend(bindOptions, _.isEmpty(params) ? {} : {formatParams: params});

  	};

	/**
	 * @private
	 */
	Binding.prototype._handleAttribute = function( view, options) {
		var getSetter = function( w, attr) {
			return function(v) { 
				w.attr( attr, v); };
		};
		
		var self = this;
		return function( index ) {
			var w = $(this);
			var entries = w.attr('data-ls-bind-attr').replace(' ', '').split(',');

			for (var i=0; i < entries.length; i++) {
				var entry = entries[i].split(':');
				var value = self._getValue( entry[1], view);
				var setter = getSetter( w, entry[0]);
				self._bind( view.viewModel, setter, value, options );
			}
			
		};
	};

	
	/**
	 * @private
	 */
	var _adjustError = function( error, field, origField) {
		var adjError = _.clone(error);
		adjError.statusText = error.statusText && error.statusText.replace( origField, field );
		adjError.attrs = {};
		adjError.attrs[field] = error.attrs[origField];

		return adjError;
	};

	/**
	 * @private
	 */
	var _getInError = function( options, isError) {
		return function( model, error, opt ) {
			if (error && error.source === 'validation' && opt && opt.valueObject) {
				_.each(isError? error.errors: error.warnings, function(err) {
					if (err.conf.fieldName == opt.targetField) {
						var adjustedError = _adjustError( err, opt.valueField, opt.targetField );
						var func = isError? options.error: options.warning;
						if (func)
							func( model, adjustedError, opt);
						else
							opt.valueObject.trigger( (isError? 'bindingError:': 'bindingWarning:') + opt.valueField, opt.valueObject, adjustedError, opt );
					}
				});
			}
		};
	};

	/**
	 * @private
	 */
	var _getError = function( options ) {
		return (options && options.targetField && options.valueObject && options.valueField) ?
				function ( model, error, opt ) {
					var adjustedError = _adjustError( error, options.valueField, options.targetField );
					options.valueObject.trigger( 'bindingError:' + options.valueField, options.valueObject, adjustedError );
				} :	undefined;
	};
	
	/**
	 * @private
	 */
	Binding.prototype._getValue = function( path, view) {
		var segs = path.split('.');
		var mappedKey = _getVmKey(segs[0], view);
		if (mappedKey !== segs[0]) {
			path = path.replace( segs[0], mappedKey);
		}
		 return this.handlePath( path, view.viewModel, {});
	};
	
	/**
	 * @private
	 */
	Binding.prototype._handleText = function( w, path, binding, view, options, bindOptions) {

		var setter = function( value) {	
			var formattedValue = bindOptions.formatType ? Formatter.format( view.getBindContext(), bindOptions ) : value;
			w.text( formattedValue );
		};

		var value = this._getValue(path, view);

		binding._bind( view.viewModel, setter, value, options );
	};

	/**
	 * @private
	 */
  Binding.prototype._handleValue = function( w, path, binding, view, options) {

	  var setter = function( value) {
		w.val(value);
	  };

	  var segs = path.split('.');
	  var mappedKey = _getVmKey(segs[0], view);
	  var mappedPath = (mappedKey !== segs[0])? path.replace( segs[0], mappedKey): path;

	  var value = this.handlePath( mappedPath, view.viewModel, {});

	  binding._bind( view.viewModel, setter, value, options );
	  
	  var event = 'change [data-ls-bind*="value:' + path + '"]';
	  
	  var handler = this.handleTargetPath( mappedPath, view.viewModel, {});
	  view.events[event] = function() { 
		return handler.call( view.viewModel, w.val() );
	  };
  };

  /**
   * @private
   */
	var _handleEvent = function( eventname, handler, binding, view, options) {
		var event = eventname + ' [data-ls-bind*="' + eventname + ':' + handler + '"]';
		view.events[event] = handler;
	};

	/**
	 * @private
	 */
	var _getVmKey = function( field, view) {
		var vmKey;
		return (vmKey = view.vmKeys['data.' + field])? vmKey: field;
	};

	return Binding;
});

/**
 * @memberOf Lightsaber.Core
 * @class ViewModel
 * @type Constructor
 * @name ViewModel
 * @description
 * Represent business (or logical) data (whether client-side or server-originated) that is eventually presented to the user or used to
 * calculate the data that is presented to the user. Note that data object properties (and as such ViewModel properties) can be
 * bound to various models (in models and outside of it) through the bindings parameter.
 * @constructor
 * @param {Object} [options.data:{}] An object that may contain properties.
 *      Designed for properties that represent static data that in some cases may actually come from the server.
 * @param {Object} [options.models:undefined] An object that may contain models that the ViewModel uses.
 *      Models of the ViewModel. It must be a hash map of name-value pairs, where value is a {@link Lightsaber.Core.Model}.
 *      If option is provided it is copied to this._models field, so it can be accessed from ViewModel methods.
 *      If there is only one model specified, use {@link #defaultModel} method to get its name.
 * @param {Object} [options.bindings:{}] An array of binding pairs. 
 * @param {Object} [options.config.actions:{}] Entries of actions that will be called as a result of click/select events.
 *      they are used by the button and search views. Entries are according to the name of the trigger for the action and should
 *      have the function to be called
 * @param {Object} [options.subViewModels:{}] Child ViewModels of this ViewModel.
 *      It must be a hash map of name-value pairs, where value is a {@link Lightsaber.Core.ViewModel}.
 *      If option is provided it is copied to this.subViewModels field, so it can be accessed from VievModel methods.
 *      Use {@link #getSubViewModel} method to get child ViewModel from the outside of this ViewModel.
 * @param {Object} [options.modelKeys:{}] mapping model fields to viewModel fields as <modelName>.<modelFieldName>:<vmFieldName>. Should only 
 *      be used when dataBinding is not used. modelName can be *. 
 * @example
 *      var myViewModel = new Lightsaber.Core.ViewModel({
 *          data: {
 *              label : 'Test'
 *          },
 *          models : {
 *              items : new Lightsaber.Core.Collection({...}),
 *              user : someUserInstance
 *          },
 *          binding: [
 *              { 'label' : 'models.user.name' },
 *              { 'id' : 'models.user.userId' },
 *          ]
 *      });
 */

define('src/core/viewModel/BaseViewModel',['jquery','underscore',
        'backbone',
        'src/core/viewModel/ViewModelConstructor',
        'src/core/util/Utils',
        'src/core/binding/Binding',
        'src/core/model/Model',
        'src/core/model/Collection'],
function($,_, Backbone, ViewModel, Utils, Binding, Model, Collection) {

    /**
     * Cached regex to parse events.
     * @private
     */
    var eventSplitter = /^\s*(\S*)\s*(\S*)?\s*$/;
    var logicalEventExtractor = /{([^}]*)}/;

    
    _.extend(ViewModel, {
        isViewModel: true,
        /**
         * Create a new class extending ViewModel class.
         * @methodOf Lightsaber.Core.ViewModel#
         * @name extend
         * @param {Object} protoProps New class prototype properties and methods.
         * @param {Object} classProps New class properties and methods.
         * @returns A new class.
         */
        extend: Utils.extend,

        mergeProperties: {
            config: 'merge',
            defaults: 'merge',
            models: 'merge',
            viewModels: 'merge',
            dataBindings: 'merge'           
        }
    });

    _.extend(ViewModel.prototype, Backbone.Events, {


        /**
         * Initialize is an empty hook function. It is invoked when the ViewModel is created.
         * Override it with your own initialization logic of the ViewModel.
         * @methodOf Lightsaber.Core.ViewModel#
         * @name initialize
         * @param {Object} [options] Options object passed to constructor.
         *                         It is not recommended to use it directly.
         *                         Use appropriate getters/setters to access ViewModels fields.
         * <code>
         * var WidgetViewModel = Lightsaber.Core.ViewModel.extend({
         *   initialize: function(options) {
         *     // put your initialization logic here
         *   }
         * });
         * </code>
         */
        initialize : function(options) {},

        /**
         * Default values of ViewModel data fields. ViewModel data fields that are not specified in options.data
         * parameter of {@link #initialize} will be initialized with these values. Override it to provide
         * default values for your ViewModel.
         * After initialization data fields can be gotten/set through {@link #get}/{@link #set} methods.
         * <code>
         * var WidgetViewModel = Lightsaber.Core.ViewModel.extend({
         *   defaults: {
         *     label: 'Name' // default label value
         *   },
         *   initialize: function(options) {
         *     this.get('label'); // value of options.data.label or 'Name' if it was not provided
         *   }
         * });
         * </code>
         */
        defaults : {},

        /**
         * Default values of ViewModel config options. ViewModel config options that are not specified in options.config
         * parameter of {@link #initialize} will be initialized with these values. Override it to provide
         * default configuration options of your ViewModel.
         * After initialization configuration options can be gotten/set through {@link #getConfig}/{@link #setConfig} methods.
         * <code>
         * var WidgetViewModel = Lightsaber.Core.ViewModel.extend({
         *   config: {
         *     vertical: false // by default vertical is true
         *   },
         *   initialize: function(options) {
         *     this.getConfig('vertical'); // value of options.config.vertical or true if it was not provided
         *   }
         * });
         * </code>
         */
        config: {},

        dataBindings: [],
        
        coreEvents: {
            'error *' : 'dataError',
            'all *' : 'errorHandler'
        },
        
        mapValidationError: function( error, modelName ) {
            if ( _.isEmpty(this.modelKeys) )
                return;
            
            error.attrs = _.reduce( error.attrs, function( memo, value, field) {
                var newField = this.modelKeys[ modelName + '.'+ field];
                memo[ newField? newField : field ] = value;
                return memo;
            }, {}, this);
            
        },
        
        _errorEventPattern: /^(error:|warning:)(.+)$/,
        
        errorHandler : function( eventName, model, error ) {
            var matched = this._errorEventPattern.exec(eventName);
            if (!matched)
                return;

            if ( !_.isEmpty(this.modelKeys) )
                error = $.extend( true, {}, error);
            
            if ( error && error.source === 'validation' ) {
                var modelName = ( model && model.cid && this._modelsMap[model.cid])? this._modelsMap[model.cid] : '*';
                this.mapValidationError( error, modelName);
                var newField = this.modelKeys[ modelName + '.'+ matched[2]];
                newField && (eventName = matched[1] + newField);
            }
            
            this.trigger( eventName, model, error);
        },
        
        dataError : function( model, error, options ) {
            if ( !_.isEmpty(this.modelKeys) )
                error = $.extend( true, {}, error);
            
            if ( error && error.source === 'validation' ) {
                var modelName = ( model && model.cid && this._modelsMap[model.cid])? this._modelsMap[model.cid] : '*';
                if ( error.errors )
                    for (var i in error.errors)
                        this.mapValidationError( error.errors[i], modelName);
                if ( error.warnings )
                    for (var i in error.warnings)
                        this.mapValidationError( error.warnings[i], modelName);
            }
            
            this.trigger('error', model, error, options);
        },
        
        _instantiateModels: function( options ) {
            // TODO: check effectiveness
            var model;
            for (var key in this._models) {
                model = this._models[key];
                if (_.isFunction(model)) {
                    this._models[key] = this.create(_.uniqueId('_model'), model, {});
                }
                else if (_.isArray(model)) {
                    this._models[key] = this.create(_.uniqueId('_model'), Collection, model);
                }
                else if (_.isObject(model) && _.has(model,'id') && _.has(model, 'class') && _.keys(model).length === 2) {
                    this._models[key] = this.create(model.id, model['class'], {});
                }
                else if (!(model instanceof Model || model instanceof Collection)) {
                    this._models[key] = this.create(_.uniqueId('_model'), Model, model);
                }
            }
            
            this._modelsMap = {};
            if (this.modelKeys) {
                _.each( this._models, function(model, name){
                    this._modelsMap[ model.cid] = name;
                }, this);
            }   
        },

        _instantiateSubViewModels: function( options ) {},

        /**
         * Sets models' events handlers. ViewModels allows to specify event handling in
         * a declarative way. Usually there is no need to call 'delegateEvents' directly
         * because it is called within the ViewModel's constructor. So you just need to specify
         * 'events' property in your ViewModel.
         * If you call 'delegateEvents' directly, keep in mind that it drops previously
         * bound events by internal call to {@link #undelegateEvents}.
         *
         * @methodOf Lightsaber.Core.ViewModel#
         * @name delegateEvents
         * @param {Object} [events=this.events] Hash map from events to handlers. 
         * Form is '<event-name> [<source-model>]' : '{<logicalEvent>} | <callback>'
         * Where
         *      <event-name> - the name of the event
         *      <source-model> - the event source model. If omitted than defaultModel will be used. * is a wildcard.
         *      <logicalEvent> - the mapped event to be re-triggered by the ViewModel after removing models from the event's argument list.
         *      <callback> - the viewModel's method.
         *                   
         *
         * @example <u>Syntax:</u>
         *   events: { "event [model|*]": "{logicalEvent} | callback", ... }
         *
         * @example <u>Usage example:</u>
         *   events: {
         *     'reset collection':  '{list:loaded}',
         *     'change:name user':  'onNameChanged'
         *   }
         * @throws {Error} If model or callback does not exist.
         */
        delegateEvents : function( models, events) {
            if ( !models ) return;
            
            if (_.isFunction(events)) events = events.call(this);
            events = _.defaults( {}, events, this.events, this.coreEvents);
            this.undelegateEvents();
            var delegatedEvents = this._delegatedEvents = {};
            var defaultModel = this.defaultModel();
            
            for (var key in events) {
                var handler = events[key];
                var logicalEvent = handler.match(logicalEventExtractor);
                if (logicalEvent) {
                    handler = _.bind(this._triggerWithoutModels, this, logicalEvent[1]);
                } else {
                    handler = this[handler];
                    if (!handler) throw new Error('Method "' + events[key] + '" does not exist');
                }

                var match = key.match(eventSplitter);
                var eventName = match[1];
                var modelName = match[2] || defaultModel;
                
                var eventProducers;
                if (modelName === '*') {
                    eventProducers = _.values(models);
                }
                else {
                    if (!models[modelName]) throw new Error('Model "' + modelName + '" does not exist');
                    eventProducers = [ models[modelName] ];
                }
                                
                _.each( eventProducers, function(eventProducer) {
                    if ( modelName !== '*' || _.isFunction(eventProducer.on) ) {
                        eventProducer.on(eventName, handler, this);

                        var list = delegatedEvents[modelName] || (delegatedEvents[modelName] = []);
                        list.push({
                            name: eventName,
                            handler: handler,
                            producer: eventProducer
                        });
                    }
                }, this);
                
            }
        },

        /**
         * Call Backbone.Events.trigger after removing Models from arguments list.
         * @private
         */
        _triggerWithoutModels: function() {
            var args = _.filter(arguments, function(param) {
                return !(param instanceof Model || param instanceof Collection);
            });
            this.trigger.apply(this, args);
        },

        /**
         * Clears all events previously bound with {@link #delegateEvents}.
         * @methodOf Lightsaber.Core.ViewModel#
         * @name undelegateEvents
         */
        undelegateEvents : function(model) {
            var events;
            if (model) {
                events = this._delegatedEvents[model] || [];
            } else {
                events = _.flatten(_.values(this._delegatedEvents || {}));
                delete this._delegatedEvents;
            }
            for (var i = 0, l = events.length; i < l; ++i) {
                var event = events[i];
                event.producer.off(event.name, event.handler);
            }
        },

        _initializeData: function (options) {
            var MyModel = Model;
            
            var validations = [].concat(options.validations || [], this.validations || []);
            if (validations.length)
                MyModel = Model.extend({ validations: validations });

            this.data = new MyModel(_.extend( {}, this.defaults, options.data) );
        },

        _bindData: function() {
            this._binding = new Binding();
            this._binding.bindAll(this);
        },

        /**
         * If there is exactly one registered model returns its name, otherwise returns undefined.
         * @methodOf Lightsaber.Core.ViewModel#
         * @name defaultModel
         * @returns {String|undefined} name of a single model or undefined if there are more (less) than one registered models.
         */
        defaultModel: function() {
            var models = this._models && _.keys(this._models);
            if (models && (models.length === 1)) {
                return models[0];
            }
        },


        setModel: function(name, model) {
            throw new Error("ViewModel.setModel() is not supported.");
        },

        getModel: function(name) {
            return this._models[name];
        },

        destroy: function() {
            this.off();            
            this.clean();
            this.undelegateEvents();
            this._binding.unbind();
            this._unbindSubViewModelEvents();
        },

        _unbindSubViewModelEvents: function() {
            if (this.subViewModels) {
                _.each(this.subViewModels, function(subViewModel) {
                    if(subViewModel && (typeof subViewModel.off === 'function')) {
                        subViewModel.off(null, null, this);                        
                    }
                }, this);
            }  
        },

        clean: function() {},

        // reference counting
        addRef: function() {
            ++this._references;
        },
        retain: function() {
            return this.addRef.apply(this, arguments);
        },
        release: function() {
            --this._references;
        },

        // TODO: remove after retrofits
        /**
         * Fetch is invoked on ViewModel to retrieve the data from its models.
         * By default, it only triggers the {@link #event:vm:ready} event to notify views that
         * the ViewModel attribubtes are ready for rendering. Override it with
         * your own data fetching logic.
         * @methodOf Lightsaber.Core.ViewModel#
         * @name fetch
         * @param {Object} [options] Fetching options passed to underlying models.
         * @deprecated
         */
        fetch : function(options) {
            /**
             * Is triggered when ViewModel attribubtes are ready to be rendered by View.
             * @event
             * @param request Search request.
             * @name vm:ready
             */
            this.trigger("vm:ready");
        },

        /**
         * Generic function that delegates user actions to their matching handlers.
         * @methodOf Lightsaber.Core.ViewModel#
         * @name handleUserAction
         * @param {String} action User action that will be used as the name of handler function in this ViewModel.
         * @param [, ...] Set of parameters to be passed to the matching handler function.
         * @throws {Error} If the matching handler function is not found in this ViewModel instance.
         * @deprecated
         */
        handleUserAction : function (action) {
            if (_.isUndefined(this[action]) || !_.isFunction(this[action])) {
                throw new Error("Unknown user action '" + action + "'.");
            } else {
                this[action].apply(this, _.tail(arguments, 1));
            }
        },
        
        /**
         * The action handler. Calls for the handler function of the given action.
         * @methodOf Lightsaber.Core.ViewModel#
         * @name handleAction
         * @param {Object} action The action name. Either String the ViewModel's action, or
         *                   Object {vm: <subViewModel name>, key: <subViewModel's action> }
         * @param {Object} event The event object.
         */
        handleAction : function(action, event) {
            if ( !_.isString(action) && _.isObject(action) && this.subViewModels[action.vm] ) {
                var subvm = this.subViewModels[action.vm];
                subvm.handleAction.apply(subvm, _.union([action.key], _.rest(arguments)) );
                return;
            }

            var actions = this.getConfig('actions');
            if (actions && actions[action]) {
                actions[action].apply(this, _.tail(arguments, 1));
            } else if (!_.isUndefined(this[action]) && _.isFunction(this[action])) {
                // falling through, having a user action method on the view model
                this[action].apply(this, _.rest(arguments));
            } else {
                arguments[0] = 'action:' + arguments[0];
                this.trigger.apply(this, arguments);
            }
        },
        
        
        /****
         * Generic actions for backwards compatability
         * 
         */
        /**
         * Handler for <code>"search"</code> user action.
         * Triggers {@link #event:user:search} event.
         * @methodOf Lightsaber.Core.ViewModel#
         * @name search
         * @param {String} 
         * request Search request.
         */
        search: function(request) {
            /**
             * Is triggered when user submits search request.
             * @event
             * @memberOf Lightsaber.Core.ViewModel#
             * @param request Search request.
             * @name user:search
             */
            this.set('value',request);
            this.trigger('user:search', request);
        },
        /**
         * Handler for logical <code>click</code> user action.
         * @methodOf Lightsaber.Core.ViewModel#
         * @name clickAction
         * Triggers {user:action} event.
         */
        click: function () {
            /**
             * Triggers on user action.
             * @event
             * @name user:action
             * @memberOf Lightsaber.Core.ViewModel#
             * @param action Click action type.
             */
            this.trigger("user:action", this.attr("action"));
        },
        
        
        /**
         * Sets a property. Depending on the key the value is set on the VM or one of its subVMs.
         * @param key either String the ViewModel's key, or
         *                   Object {vm: <subViewModel name>, key: <subViewModel's key> } or
         *                   Object to set
         * @param [value] Object    The value to set
         * @param [options] Object  The options to use
         */
        set: function(key, value, options) {
            if (key && (key === 'config' || key.config))
                throw new Error("Lightsaber.Core.ViewModel.set(): `config` data attribute name is proibited");
            
            if ( _.isObject(key) && key.key && this.subViewModels[key.vm] ) 
                return this.subViewModels[key.vm].set( key.key, value, options);
            
            return this.data.set.apply(this.data, arguments)? this: false;
        },
        reset: function() {
            this.clear();
        },
        clear: function() {
            if(this.data && this.data instanceof Backbone.Model) {
                this.data.clear();              
            }
        },
        
        previous: function() {
            return this.data.previous.apply(this.data, arguments);
        },

        /**
         * Gets a property. Depending on the key the value is retrieved from the VM or one of its subVMs.
         * @param key either String the ViewModel's key, or
         *                   Object {vm: <subViewModel name>, key: <subViewModel's key> }
         */
        get: function(key) {
            if (key === 'config')
                throw new Error("Lightsaber.Core.ViewModel.get(): `config` data attribute name is proibited");
            
            var value;
            if ( _.isString(key) )
                value = this.data.get(key);
            else if ( _.isUndefined(key) ){
                value = this.data.toJSON();
                //Deleting subViewModels property in order to avoid circular dependency
                delete value.subViewModels;
            }
            else if ( _.isObject(key) && this.subViewModels[key.vm] )
                value = this.subViewModels[key.vm].get(key.key);
                
            return value;
        },

        setConfig: function() {
            this.config.set.apply(this.config, arguments);
            return this;
        },

        getConfig: function(key) {
            return arguments.length === 0 ? this.config.toJSON() : this.config.get(key);
        },

        getData: function() {},

        _dataEventsHandler: function(eventName, model, value, options) {
            var event = { target: this },
                specificEvent = /^change:/.test(eventName);
            if (specificEvent) event.value = value;
            event.changed = model.changedAttributes && model.changedAttributes();
            event._warningWasFound = options && options._warningWasFound;
            this.trigger(eventName, event);
        },

        _configEventsHandler: function(eventName, model, value) {
            var event = { target: this },
                specificEvent = /^change:/.test(eventName);
            if (specificEvent) event.value = value;
            if (model)
            {
                event.changed = { config: model.changedAttributes && model.changedAttributes() };
            }           
            eventName = eventName.replace(/^change/, 'change:config');
            this.trigger(eventName, event);
        },

        // TODO: remove after retrofits
        /**
         * Get or set view model attributes. The behaviour depends on type of passed arguments.
         * @methodOf Lightsaber.Core.ViewModel#
         * @name attr
         * @param {String|String[]|Object} arg
         *              <ol><li>If <code>arg</code> is <code>String</code> and second argument <code>value</code> IS NOT provided,
         *              the method behaves as getter: value of the attribute with name <code>arg</code> is
         *              returned, or <code>undefined</code> if there is no such attribute.</li>
         *              <li>If <code>arg</code> is <code>String</code> and second argument <code>value</code> IS provided,
         *              the method behaves as setter: value of attribute with name <code>arg</code> is
         *              setted to <code>value</code>. Reference to this ViewModel is returned.</li>
         *              <li>If <code>arg</code> is <code>String[]</code> the method behaves as batch getter:
         *              it treats the array as list of attribute names and returns values of
         *              these attirbutes as a hash map of name-value pairs.</li>
         *              <li>If <code>arg</code> is <code>Object</code> the method behaves as batch setter:
         *              it treats the object as a hash map of name-value pairs and set to the
         *              specified attributes the specified names. Reference to this ViewModel is returned.</li></ol>
         * @param [value] Value to set, if first argument is String (option 2).
         * @returns See <code>arg</code> parameter description.
         * @throws {Error} If arguments of unexpected type were passed.
         * @deprecated
         */
        attr: function(arg, value) {
            var data, i, len;

            // batch getter
            if(_.isArray(arg)) {
                data = {};
                for (i = 0, len = arg.length; i < len; ++i) {
                    data[arg[i]] = this.get(arg[i]);
                }
                return data;

            // setter
            } else if (_.isString(arg) && arguments.length > 1 || _.isObject(arg)) {
                return this.set(arg, value);

            // getter
            } else if(_.isString(arg)) {
                return this.get(arg);
            }
            throw new Error("Lightsaber.Core.ViewModel.attr(): invalid type of arguments");
        },

        /**
         * Get child ViewModel by id. Use this method to get child ViewModels from the outside of this ViewModel.
         * @methodOf Lightsaber.Core.ViewModel#
         * @name getSubViewModel
         * @param {String} id Id of child ViewModel.
         * @returns {Lightsaber.Core.ViewModel|undefined} If there is a child ViewModel with such id it is returned.
         */
        getSubViewModel: function(id) {
            return this.subViewModels && this.subViewModels[id];
        },

        /**
         * Add child ViewModel. Use this method to add child ViewModels from the outside of this ViewModel.
         * @methodOf Lightsaber.Core.ViewModel#
         * @name getSubViewModel
         * @param {String} id Id of child ViewModel.
         * @param {Lightsaber.ViewModel} A new instance of a view-model.
         */
        addSubViewModel: function(id, viewModel) {
            this.subViewModels[id] = viewModel; 
            var subViewModels = this.get('subViewModels');
            var newData = subViewModels || {};
            newData[id] = viewModel;
            if (!subViewModels) {
                this.set('subViewModels', newData);
            } else {
                subViewModels[id] = viewModel;
            }          
        },

        /**
         * Get the <code>dataBinding</code> reference object in order to control
         * @methodOf Lightsaber.Core.ViewModel#
         * @name getDataBinding
         * @return {Object} The <code>dataBinding</code> object.
         */
        getDataBinding: function() {
            return this.dataBindings;
        },

        /**
         * Create a new subset of current view-model and populate it according to given data bindings.
         * @methodOf Lightsaber.Core.ViewModel#
         * @name createSubsetViewModel
         * @param {String} [options.id] Id of child view-model. If provided the subset view-model will be stored inside this view-model.
         * @param {Array}  [options.dataBindings] The data-bindings between the current view-model and the newly created subset.
         * @param {Object} [options.viewModel.type=Lightsaber.ViewModel] The type of view-model (should be a reference to constructor function of the type).
         *                  Default value: Lightsaber.ViewModel
         * @param {Object} [options.viewModel.settings] The settings that will be passed to subset constructor.
         * @returns {Lightsaber.ViewModel} A new instance of subset view-model.
         */
        createSubsetViewModel: function(options) {
            // initialize options if not provided
            options || (options = {});
            // prepare the options for the newly created view model
            var viewModelOptions = _.extend({},
                options.dataBindings ? {dataBindings: options.dataBindings} : {},
                options.viewModel && options.viewModel.settings ? options.viewModel.settings : {});

            // create the new view model instance
            var child = new (options.viewModel && options.viewModel.type || ViewModel)(viewModelOptions);
            // store the subset under sub-view-models if the id is provided
            if (options.id) {
                this.subViewModels || (this.subViewModels = {});
                this.subViewModels[options.id] = child;
            }
            return child;
        },

        /**
         * Apply the given data bindings to an existing view-model instance.
         * @methodOf Lightsaber.Core.ViewModel#
         * @name applySubsetBindings
         * @param {String} [options.id] Id of child view-model. If provided the subset view-model will be stored inside this view-model.
         * @param {Array}  [options.dataBindings] The data-bindings between the current view-model and the newly created subset.
         * @param {Object} options.viewModelInstance The existing instance of view-model or its sub-type.
         */
        applySubsetBindings: function(options) {
            if (!(options && options.viewModelInstance && options.viewModelInstance instanceof ViewModel)) {
                throw "No valid subset instance is provided.";
            }
            var instance = options.viewModelInstance;
            var bindings = [].concat(instance.dataBindings || [], options.dataBindings || []);
            instance._binding.bindAll(instance, bindings);
            if (options.id) {
                this.subViewModels || (this.subViewModels = {});
                this.subViewModels[options.id] = instance;
            }
        },
        shouldRegister: function() {
            return true;
        },
        //Storage not supported for None ObservableViewModel.
        shouldRestore: function() {
            return false;
        },
        shouldPersist: function() {
            return false;
        }

    }, Utils.Factory, Utils.Common);

    return ViewModel;
});



/**
@memberOf Lightsaber.Core
@name CollectionViewModel

@class CollectionViewModel
@type ViewModel

@description
ViewModel to handle a list of items to be displayed. List will be based
on a model and can automatically handle the model changes.

@example
		var viewModel = new Lightsaber.CollectionViewModel({
			models : {
				items : model // only one model is expected for the list
			},
			config : {
				filterFunction : function(myItem) {return myItem.someField != null}
			},
			autoUpdate : true
		});
@constructor 

@memberOf Lightsaber.ViewModel.CollectionViewModel

 * @param Object
 *            Lightsaber.Model(options) Object with options for the viewmodel
 * @param {Boolean}
 *            [options.autoUpdate=true] Indication whether to update the view
 *            when the collection changes
 * @param {Boolean}
 *            [options.visible=true] Indication whether this viewmodel will be
 *            visible. For this viewmodel the only implication is in the view.
 * @param {Boolean}
 *            [options.enabled=true] Indication whether this viewmodel is
 *            enabled. For this viewmodel the only implication is in the view.
 * @param {Function}
 *            [options.config.filterFunction] Filter function that will be used
 *            on the model for display
 * @param {Function}
 *            [options.config.sortFunction] Sort function that will be used on
 *            the model for client sorting the data. Must return a single value
 * @param {String}
 *            [options.config.sortFieldName] Field on the model that will be
 *            used for client side sorting
 * @param {Function}
 *            [options.config.groupFunction] Sort function that will be used on
 *            the model for grouping the items
 * @param {String}
 *            [options.config.groupFieldName] Field on the model that will be
 *            used for grouping the list
 * @param Object
 *            options.models={} Object with the collection that will be used for
 *            the list
*/
define('src/components/collection/viewmodel/CollectionViewModel',[
    'underscore',
    'jquery',
	'src/core/viewModel/BaseViewModel',
	'src/core/model/Collection'
], function(_, $, BaseViewModel, Collection) {

		
	var CollectionViewModel = BaseViewModel.extend({

		
		/**
		 Initialized the list and will load the data if required.
		 @memberOf Lightsaber.ViewModel.CollectionViewModel
		 @name initialize
		 @throws Exception in case no model is sent
		 @function		 
		 */	
		currentModel : null,
		viewModelType : "Collection",
		initialize : function() {
			this._initialize();
		},


		_initialize : function() {
			_.bindAll(this);
			this.currentModel = this._getModel();
			if(this.currentModel) {
				// adding listeners on the model changes
				this.currentModel.on("reset", this._processDataReset, this);
				this.currentModel.on("error", this.error, this);
				this.currentModel.on("change", this._change, this);
				this.currentModel.on("add", this._add, this);
				this.currentModel.on("remove", this._remove, this);
				this.currentModel.on("dataReady", this._processDataReady, this),
				this.on('change:config:filterFunction', this.refresh); 
				this.on('change:config:sortFieldName', this.refresh); 
				this.on('change:config:sortFunction', this.refresh); 

				
			}
			/*else {
				throw "A list cannot be intialized without a collection";
			}*/
		},
		
		/**
		 Method called in order to get the next page for the data
		 @memberOf Lightsaber.ViewModel.CollectionViewModel
		 @name nextPage
		 @param Integer numOfPages
		 @function		 
		 */	
		nextPage : function(numOfPages,options) {
			this.currentModel.next(numOfPages,options);
		},
		/**
		 Method called in order to get the previous page for the data
		 @memberOf Lightsaber.ViewModel.CollectionViewModel
		 @name previousPage
		 @param Integer numOfPages
		 @function		 
		 */	
		previousPage : function(numOfPages,options) {
			this.currentModel.prev(numOfPages,options);
		},		
		/**
		 Method called in order to get the previous page for the data
		 @memberOf Lightsaber.ViewModel.CollectionViewModel
		 @name previousPage
		 @param Integer pagenum
		 @function		 
		 */	
		gotoPage : function(pagenum,options) {
			this.currentModel.gotoPage(pagenum,options);
		},	
		/**
		 Method called in order to change the page size for the pagination
		 @memberOf Lightsaber.ViewModel.CollectionViewModel
		 @name previousPage
		 @param Integer pagenum
		 @function		 
		 */	
        setPageSize : function(pageSize){
      	  if(!_.isNumber(pageSize))
					pageSize = Number(pageSize);
      	  this.currentModel.pagination.pageSize = pageSize;
      	  this.currentModel.gotoPage(0);
        },	
  	  	/**
         * @methodOf Lightsaber.ViewModel.CollectionViewModel
         * @name setSorting
         * @description This method set the sorting criteria in model and reload the data. this only works for paginated
         * viewmodels since it will refetch the data from the server.
         * Client side sorting is changed by changing the configuration.
         * 
         * @constructs
         * @param {Object} sortingCriteria: Contains the sorting criteria which should be provided to model attached to this view model.
         * @Returns nothing.
         * @Example
         * 	setSorting({ fieldName : <field_name>, asc : <true/false> });
         */
  	  	_setSorting : function(sortingCriteria){
  		  	this.currentModel.setSorting(sortingCriteria);
        },
		/***
		 * default config values
		 */
		config: {
			autoUpdate : true,
			enabled:true,
			visible:true
		},
		/**
		 Method called in order to add an item to the collection through API.
		 triggers "items.added" event if autoUpdate is true
		 @memberOf Lightsaber.ViewModel.CollectionViewModel
		 @name add
		 @function		 
		 */	
		/**
		 this event is a called when an item is added to the model
		 @memberOf Lightsaber.ViewModel.CollectionViewModel
		 @name items:added
		 @param Object item	the added item in JSON format
		 @param String idAttribute	the attribute field for the item
		 @event
		 @function		 
		 */
		add : function(obj, options) {
			if (this.currentModel.get(obj.cid) == null) {
				this.currentModel.add( obj, _.extend( {silent: true}, options ) );
				this._add(obj, this.currentModel, options);
			}
		},

		/***
		 * Internal add method. called when added to the model or when added by API
		 */
		_add : function(obj, collection, options) {
			if (this.getConfig("autoUpdate")) {
				var data = this.getData(obj);
				if (data != null) {
					this.trigger("items:added", data, options && options.at);					
				}
			}
		},
		/**
		 Method called when an item has been changed in the model.
		 triggers "items.changed" event if autoUpdate is true
		 @memberOf Lightsaber.ViewModel.CollectionViewModel
		 @name change
		 @function		 
		 */	
		/**
		 this event is a called when an item is changed on the model
		 or when the model is refreshed
		 @memberOf Lightsaber.ViewModel.CollectionViewModel
		 @name items:change
		 @param Object item	the changed item in JSON format, either single item or the entire model
		 @param String idAttribute	the attribute field for the item
		 @event
		 @function		 
		 */
		change : function(obj) {
			if(this.currentModel.get(obj.cid)) {
				this.currentModel.remove(obj, {silent:true});
				this.currentModel.add(obj, {silent:true});
				this._change(obj);
			}
		},
		/***
		 * Internal method when model has changed. called from model trigger or through API
		 */
		_change : function(obj) {
			if (this.getConfig("autoUpdate")) {
				var data = this.getData(obj);
				if (data != null) {
					this.trigger("items:changed", data);					
				}
			}
		},
		/**
		 Called to remove a model from the collection through API.
		 triggers "items.removed" event if autoUpdate is true
		 @memberOf Lightsaber.ViewModel.CollectionViewModel
		 @name remove
		 @function		 
		 */	
		/**
		 this event is a called when an item is removed from the model
		 @memberOf Lightsaber.ViewModel.CollectionViewModel
		 @name items:removed
		 @param Object item	the removed item in JSON format
		 @param String idAttribute	the attribute field for the item
		 @event
		 @function		 
		 */
		remove : function(obj) {
			if (this.currentModel.get(obj.cid)) {
				this.currentModel.remove(obj, {silent:true});
				this._remove(obj);
			}
		},
		/***
		 * Internal method to remove the item. called when triggered from model or
		 * when through API
		 */
		_remove : function(obj) {
			if (this.getConfig("autoUpdate")) {
				var data = this.getData(obj);
				if (data != null) {
					this.trigger("items:removed", data);					
				}
			}
		},
	
		/**
		 Method called to refresh the view. this will take the existing
		 model and clear and rebuild the list
		 Triggers "items:refreshed" event
		 @memberOf Lightsaber.ViewModel.CollectionViewModel
		 @name refreshData
		 @function		 
		 */	
		/**
		 this event is a called when the view should refresh the data, is sent with the data
		 @memberOf Lightsaber.ViewModel.CollectionViewModel
		 @name items:refreshed
		 @param Object items	the model data in JSON format
		 @param String idAttribute	the attribute field for the items
		 @event
		 @function		 
		 */
		refresh : function() {
			this.trigger('items:refreshed', this.getData());
		},
		
		/**
		 Method called to clear the list in the view. 
		 Triggers "items:cleared" event
		 @memberOf Lightsaber.ViewModel.CollectionViewModel
		 @name clearData
		 @function		 
		 */	
		/**
		 this event is a called when the view should be emptied of data
		 @memberOf Lightsaber.ViewModel.CollectionViewModel
		 @name items:emptied
		 @event
		 @function		 
		 */
		empty : function() {
			this.trigger('items:emptied');	
		},


        /***
         * Method that may be called by the view in order to refresh the data.
         * the fetch will trigger the event that will set the data in the view 
         */
        _resetData : function() {
        	this.currentModel.fetch();
        },

		/**
		 Called in order to get the data from the viewModel that is required for display
		 @memberOf Lightsaber.ViewModel.CollectionViewModel
		 @name getData
		 @return Object with "items" containing the collection or "item" for single model data and "idAttribute" with the ID of the model
		 @function		 
		 */	
       getData : function(obj) {
    	   return this._getData(obj);
        },
        
		/**
		 Called in order to get the data from the viewModel that is required for display.
		 This will get the grouped data either from the data that was processed with the event
		 or will get the current page
		 @memberOf Lightsaber.ViewModel.CollectionViewModel
		 @name getData
		 @return Data sent from the model
		 @function		 
		 */	
        getGroupedData : function(dataObject) {
        	if (dataObject == null) {
	  			dataObject = this._getPage();
	  		}
	  		if (dataObject.modelData && dataObject.modelData.data != null) {
			    return this._handleFullList(dataObject.modelData);	  			
	  		}
		    if (dataObject.data != null) {
			    return this._handleFullList(dataObject);
		    } else {
			    return this._handleItem(dataObject);
		    }
        },
		/**
		 * Returns whether the collection is a regular or a grouped collection
		 @memberOf Lightsaber.ViewModel.CollectionViewModel
		 @name isGroupedCollection
		 @return boolean whether the collection is grouped
		 @function		 
		 */	
        isGroupedCollection : function() {
			var isGrouped = (this.getConfig("itemListName") != null);
			if (!isGrouped) {
				isGrouped = (this.getConfig("groupFieldName") != null);
				if (!isGrouped) {
					isGrouped = (this.getConfig("groupFunction") != null);						
				}
			}
			return isGrouped;
        },
		
		/****************************************************************************
		 * P R I V A T E
		 ****************************************************************************/
		/**
		 * Internal implementation that will return the data for the getData function.
		 * can be overridden in extending classes
		 * 
		 * return list in the following way:
		 * {
		 * 	items : [
		 * 		{ name : "aa"},
		 * 		{ name : "ab"},
		 * 		{ name : "bb"}
		 * 	],
		 * 	idAttribute : "name"
		 * }
		 * 
		 * 
		 * returns single item in the following way:
		 * {
		 * 	item : { name : "aa"},
		 * 	idAttribute : "name",
		 * 	sortedIndex : 0
		 * }
		 */
        _getData : function(obj) {
    	   	var sortFunction = this._getSortFunction();
        	var itemsId = this._getItemsId(this.currentModel);
        	if (obj== null || obj.data) /* handling the data if it is on the model*/ {
        		if (obj == null) obj = this._getPage();
        		var tempCollection = null;
       		    var returnObj = {idAttribute : itemsId} 
        		// handling client side sort and filter in case we are not paginated
        		if (obj != null) {
        			if (!this.currentModel.dataSource || !this.currentModel.dataSource.getProperties().supportsPagination) { // server-side pagination is not supported
            			// filtering
            			tempCollection = this._getFilteredDataJSON(obj.data);
                		// sorting
                		tempCollection = this._getSortedDataJSON(tempCollection, sortFunction);
                		
                		if (obj.info.pageSize != null) { // client side pagination
                			returnObj.paginationInfo = obj.info;
                		}
                		
            		} else {
            			// getting JSON for page
            			tempCollection = new Collection(obj.data).toJSON();
            			returnObj.paginationInfo = obj.info;
            		}        			
        		}
        		// returning data
        		if (tempCollection == null) tempCollection = [];
        		returnObj.items = tempCollection;
    			return returnObj;        		
        	} else /* handling data from CRUD event */{
           		// filtering
        		var tempCollection = this._getFilteredDataJSON([obj]);
    			if (tempCollection == null) return null;
    			var item = tempCollection[0];
    			// sorting
        		if (sortFunction != null) {
        			var pageObjs = this._getPage();
        			if (pageObjs.info.pageSize == null) {
            			// have to get the filtered list to get the correct index ID
            			var filterCollection = this._getFilteredDataJSON(pageObjs.data);
            			// getting the index of the item in the list
                    	var itemIndex =  this._getSortedIndex(filterCollection, item, sortFunction);
                		return {item: item, idAttribute : itemsId, sortedIndex : itemIndex, modelData : obj}        		        				
        			}
        		} else {
            		return {item: item, idAttribute : itemsId, modelData : obj}        		        			
        		}
        	}
		},
        
        /***
		 * Gets the model for use in the list. 
		 * hook for customization
		 */
		_getModel :function() {
			var modelName = this.defaultModel();
			if (modelName) {
				return this.models[modelName];
			} else {
				return null;
			}
		},
		
        /*****
         * Used for sorting of the list internally
         */
        _iterator : function(item) {
        	return item[this.getConfig("sortFieldName")]; 
        },
        /***
         * private. called when the viewmodel "reset" is called
         */
        _processDataReset : function (eventData) {
        	this._processData(eventData, "items:loaded");
        },
        /***
         * private. called when the viewmodel "dataready" is called
         */
        _processDataReady : function (eventData) {
        	this._processData(eventData, "items:paginated");        	
        },

        
		/**
		 Method called when the model has succesfully been loaded and renders the view. 
		 Triggers "items:loaded" event	 
		 */	
		/**
		 this event is a called when an item in the list has been selected
		 @memberOf Lightsaber.ViewModel.CollectionViewModel
		 @name items:loaded
		 @event
		 @param Event event
		 @param [Object] items array with the items in the data
		 @param String idAttribute name of the ID attribute for the model
		 @function		 
		 */
		/**
		 this event is a called when an item in the list has been selected
		 @memberOf Lightsaber.ViewModel.CollectionViewModel
		 @name items:paginated
		 @event
		 @param Event event
		 @param [Object] items array with the items in the data
		 @param String idAttribute name of the ID attribute for the model
		 @param {Object} paginationInfo details of the pagination for the current data
		 @function		 
		 */        
		_processData : function(eventData, triggerName) {
			var outputData = null;
			var pagenum = 0;
			if (eventData.pageNum != null) {
				// getting the page number and the data for the page
				pagenum = eventData.pageNum;
			} else {
				pagenum = 0;
			}
			var pageData = this._getPage(pagenum);
			outputData = this.getData(pageData);
			outputData.modelData = pageData;
			this.trigger(triggerName, outputData);								
		},
		
		/**
		 this event is a called when the viewmodel throws an error
		 @memberOf Lightsaber.ViewModel.CollectionViewModel
		 @name error
		 @event
		 @function		 
		 */        
		error : function(errorMessage, options) {
           this.trigger('error', errorMessage, options);
		},

		/*****
		 * Returns the data after the client filter function has been called
		 */
        _getFilteredDataJSON : function(data) {
        	if (data == null || data.length == 0) return null;
        	var filterFunction = this.getConfig("filterFunction");
        	if (filterFunction) {
            	data = _.filter(data, filterFunction);  	
        	}
        	if (data.length == 0) {
        		return null;
        	} else {
            	return new Collection(data).toJSON();        	        		
        	}
        },

		/*****
		 * Returns the data after the client sort function has been called
		 */
        _getSortedDataJSON : function(jsonData, sortFunction) {
        	if (jsonData == null || jsonData.length == 0) return null;
    		if (sortFunction != null) {
    			return _.sortBy(jsonData, sortFunction); 
    		} else {
    			return jsonData;
    		}
        },
        /***
         * finding the sort function. either the default function or by input
         */
        _getSortFunction : function() {
      	   // finding the sort function. either the default function or by input
      	   var sortFunction = null;
      	   if (this.getConfig("sortFunction")) {
      		   sortFunction = this.getConfig("sortFunction");
      	   } else if (this.getConfig("sortFieldName")) {
      		   sortFunction = this._iterator;
      	   }
      	   return sortFunction;
        },
        /***
         * Gets the ID attribute from the collection with the items or "id"
         */
        _getItemsId : function(collection) {
        	var itemsId = collection.model.prototype.idAttribute? collection.model.prototype.idAttribute : 'id';
        	return itemsId;
        },
        /***
         * Gets the index of the current item in the entire list
         */
        _getSortedIndex : function(jsonCollection, item, sortFunction) {
        	// soring the input data
        	var sortInput = _.sortBy(jsonCollection, sortFunction);
        	// creating a map with the sort keys
        	var sortedData = _.map(sortInput, sortFunction);
        	// getting our sort key
        	var itemSortValue = sortFunction(item);
        	// getting the index in the sort key array for our new item
        	var index =  _.sortedIndex(sortedData, itemSortValue); 	
        	return index;
        },
        /**
         * @methodOf Lightsaber.ViewModel.CollectionViewModel
         * @name getSorting
         * @description This method returns the pagination criteria for pagination.
         * @constructs
         * @param
         * @Returns {Object} criteria.
         * @Example
         * 	
         */
        _getSorting : function(){
      	  return this.currentModel.sorting;
        },
        /**
         * @methodOf Lightsaber.ViewModel.CollectionViewModel
         * @name getPagination
         * @description This method returns the pagination criteria object for pagination.
         * @constructs
         * @param 
         * @Returns {Object} pagination
         * @Example
         * 	
         */
        _getPagination : function(){
        	return this.currentModel.pagination;
        },
        
        _getPage : function( pageNum ){
        	var res = this.currentModel.getPage(pageNum);
        	res && res.data && this.set( {'items':res.data} );
        	return res;
        },
        
        /***
         * G R O U P   R E L A T E D
         */
	    /***********************************************************************
		 * Handles a single item in order to be sent with the event looks like
		 * this for group: { group : { groupName: "A", id : 1, items : [
		 * {name:AA}, {name:AB} ] }, itemListName : "items", idAttribute : "id" }
		 * 
		 * and like this for item: group : { groupName: "A", id : 1, }, item :
		 * {name:"AA", idAttribute: "name", sortedIndex: 1} }
		 */
	    _handleItem : function(obj) {
	    	 var innerItem;
	    	 // handling case where we got the model object instead of transformed data.
	    	if (obj.item == null) {
			    innerItem = this._getData(obj);	    		
	    	} else {
	    		innerItem = obj;
	    	}
		    if (innerItem != null) {
			    if (this.getConfig("itemListName")) /*
													 * we got an entire group
													 */{
				    var groupItemsId = this._getItemsId(this.currentModel);
				    var innerModels = obj.get(this.getConfig("itemListName"));
				    if (innerModels != null && innerModels.length && innerModels[0].models != null) {
					    itemsId = this._getItemsId(innerModels[0]);
				    } else {
					    itemsId = "id";
				    }

				    var outputObj = {
				        group : innerItem.item,
				        itemsListName : this.getConfig("itemListName"),
				        groupIdAttribute : groupItemsId,
				        idAttribute : itemsId,
				        sortedIndex : innerItem.sortedIndex
				    };
				    return outputObj;
			    } else /* single item from flat model */{
				    var groupFunction = this._getGroupFunction();
				    var itemGroup = groupFunction(innerItem.item);
				    var groupObj = {
				        groupName : itemGroup,
				        id : itemGroup,
				        idAttribute : this._getItemsId(this.currentModel)
				    };
				    var outputObj = innerItem;
				    outputObj.group = groupObj;
				    return outputObj;
			    }
		    }
		    return null;
	    },

	    /***********************************************************************
		 * Build the entire list of data from the model. a hierachical output
		 * with the groups and their inner items
		 */
	    _handleFullList : function(obj) {
		    // data we need for the output
		    var itemsId = null;
		    var groupItemsId = null;
		    var outputArray = null;
		    var itemListNameStr = null;

		    if (this.getConfig("itemListName")) /* Grouped input model */{
			    groupItemsId = this._getItemsId(this.currentModel);
			    // we have a list containing inner items. no
			    // need for us to do the grouping
			    itemListNameStr = this.getConfig("itemListName");
			    // looping though the groups and looking for the
			    // first item we can find to see if we can get
			    // the itemID
			    for ( var i = 0; i < obj.data.length; i++) {
				    var innerItems = obj.data[0].get(itemListNameStr);
				    if (innerItems != null && innerItems.length && innerItems.models) {
					    itemsId = this._getItemsId(innerItems);
				    }
			    }
			    if (itemsId == null) {
				    itemsId = "id";
			    }
			    // getting filtered and sorted data here for the output.
			    // filter and sort will only be on first level
			    outputArray = this._getData(obj).items;
		    } else /* flat input model */{
			    itemsId = this._getItemsId(this.currentModel);
			    groupItemsId = itemsId;

			    var currentGroup = null;
			    var currentItems = null;
			    outputArray = [];
			    itemListNameStr = "items";
			    // get the filtered and sorted list on the client for non pagination
			    var innerItems = this._getData(obj);
			    var groupFunction = this._getGroupFunction();
			    // loop through item though item and create the grouping
			    // this will be sequential. grouping is only
			    // done if the next item has the same group. groups are not
			    // unique. the same group can appear twice.
			    for ( var i = 0; i < innerItems.items.length; i++) {
				    var itemGroup = groupFunction(innerItems.items[i]);
				    if (itemGroup != currentGroup) {
					    currentGroup = itemGroup;
					    outputArray[outputArray.length] = {
					        groupName : currentGroup,
					        id : currentGroup,
					        items : []
					    };
					    currentItems = outputArray[outputArray.length - 1].items;
				    }
				    currentItems[currentItems.length] = innerItems.items[i];
			    }
		    }
		    // putting together the output object
		    var outputObj = {
		        items : outputArray,
		        idAttribute : itemsId,
		        groupIdAttribute : groupItemsId,
		        itemsListName : itemListNameStr,
		        paginationInfo : obj.info
		    }
		    return outputObj;
	    },

	    /***********************************************************************
		 * Default group method. this will return the group according to a field
		 * on the model
		 */
	    _groupIterator : function(item) {
		    var field = item[this.getConfig("groupFieldName")];
		    if (field == null) {
			    return "";
		    } else {
			    return field;
		    }
	    },

	    /***********************************************************************
		 * Retrieves the function for grouping. Either by groupField or
		 * groupFunction, if those do not exist we take the sortfunction for
		 * grouping
		 */
	    _getGroupFunction : function() {
		    // finding the sort function. either the default
		    // function or by input
		    var groupFunction = null;
		    if (this.getConfig("groupFunction")) {
			    groupFunction = this.getConfig("groupFunction");
		    } else if (this.getConfig("groupFieldName")) {
			    groupFunction = this._groupIterator;
		    }
		    if (groupFunction == null) {
			    groupFunction = this._getSortFunction();
			    if (groupFunction == null) {
				    throw "No grouping function has been defined";
			    }
		    }
		    return groupFunction;
	    }        

	});
	
	CollectionViewModel.mergeProperties = {
		'config' : 'merge'
	}

	return CollectionViewModel;

});

define('src/core/viewModel/ViewModel',['src/core/viewModel/BaseViewModel',
        'src/components/collection/viewmodel/CollectionViewModel',
        'src/core/model/Collection'
        ], function(BaseViewModel,CollectionViewModel,Collection) {

    
                var ViewModel = BaseViewModel.extend({

        
        _instantiateSubViewModels: function( options ) {
            // TODO: check effectiveness
            var subViewModel;
            for (var key in this.subViewModels) {
                subViewModel = this.subViewModels[key];
                if (_.isFunction(subViewModel)) {
                    this.subViewModels[key] = this.create(_.uniqueId('_viewmodel'), subViewModel, {}); 
                }
                else if (_.isArray(subViewModel)) {
                    this.subViewModels[key] = this.create(_.uniqueId('_viewmodel'), CollectionViewModel, {
                        models: {
                            data: new Collection(subViewModel)
                        }
                    });
                } 
                else if (_.isObject(subViewModel) && _.has(subViewModel,'id') && _.has(subViewModel, 'class') && _.keys(subViewModel).length === 2) {
                    this.subViewModels[key] = this.create(subViewModel.id, subViewModel['class'], {});
                }
                else if (!(subViewModel instanceof ViewModel || subViewModel instanceof CollectionViewModel)) {
                    this.subViewModels[key] = this.create(_.uniqueId('_viewmodel'), ViewModel, subViewModel); 
                }
            }
        }
    });

    return ViewModel;

});


define('src/core/knockout/ContentBinding',[
    'jquery',
    'knockout',
    'src/core/util/Utils'
], function($, KO, Utils) {
    
    

    KO.CustomBindingProvider = function() {
        var defaultBindingProvider = new KO.bindingProvider();
        function getBindingsString(node) {
            var bindings = null, value;
            if(node.getAttribute) {
                value = node.getAttribute('data-content-id');
                if(value) {
                    bindings = ['content: {id: "' + value + '"}']; 
                    return bindings.join(', ');                   
                }
            }
            return bindings;
        }
        this.nodeHasBindings = function(node) {
          return !!getBindingsString(node) || defaultBindingProvider.nodeHasBindings(node);
        };
        this.getBindings = function(node, bindingContext) {
            var bindingsString = getBindingsString(node, bindingContext) || defaultBindingProvider.getBindingsString(node, bindingContext);
            return bindingsString ? defaultBindingProvider.parseBindingsString(bindingsString, bindingContext, node) : null;
        };
        this.getBindingAccessors = function(node, bindingContext) {
            var bindingsString = getBindingsString(node, bindingContext) || defaultBindingProvider.getBindingsString(node, bindingContext);
            return bindingsString ? defaultBindingProvider.parseBindingsString(bindingsString, bindingContext, node, {'valueAccessors':true}) : null;
        };
    };

    // Constructor
    var ContentBinding = function() {
        _.bindAll(this, '_base', 'init', 'update', '_ascendToWidget', '_findHandler'); 
    };

    _.extend(ContentBinding, {
        extend: Utils.extend
    });

    _.extend(ContentBinding.prototype, {
        _base: function(element, valueAccessor, allBindingsAccessor, context, bindingContext) {
            var handler = this._findHandler(bindingContext);
            var widget = this._ascendToWidget(handler.view);

            var $element, config, value;

            if(widget && widget.contentData) {
                config = valueAccessor();

                if(config && config.id) {
                    value = widget.contentData[config.id];
                    
                    if(value) {
                        $element = $(element);
                        $element.text(value);                                
                    }
                }
            }
        },

        init: function(element, valueAccessor, allBindingsAccessor, context, bindingContext) {
            this._base(element, valueAccessor, allBindingsAccessor, context, bindingContext);
        },
        
        update: function(element, valueAccessor, allBindingsAccessor, context, bindingContext) {
            this._base(element, valueAccessor, allBindingsAccessor, context, bindingContext);            
        },

        _ascendToWidget: function(component) {
            var parent;

            if(component) {
                if(!component.isBusinessWidget 
                    || (component.isBusinessWidget && !component.contentData)) {
                    
                    if(component.getParent) {
                        parent = this._ascendToWidget(component.getParent());                        
                    }
                } else {
                    parent = component;                        
                }                
            }

            return parent;
        },

        _findHandler: function(bindingContext) {
            var handler;
            
            if(bindingContext) {
                if(bindingContext.$data && 
                    _.isObject(bindingContext.$data) && 
                    ('__viewhandler__' in bindingContext.$data) || ('__viewhandler__' in bindingContext)) {
                    handler = bindingContext.__viewhandler__ || bindingContext.$data.__viewhandler__;
                } else {
                    for (var i = 0, length = bindingContext.$parents.length; i < length; i++) {
                        if(bindingContext.$parents[i] && ('__viewhandler__' in bindingContext.$parents[i])) {
                            handler = bindingContext.$parents[i].__viewhandler__;
                            break;
                        }                    
                    };
                }
            }

            return handler;
        }
    });

    return ContentBinding;

});
define('src/core/knockout/ViewCustomBinding',['knockout',
    'src/core/util/Utils'
], function(KO, Utils) {
    
    

    var ViewCustomBinding = function() {
        // Only when you know what you are doing. Otherwise, avoid this.
        _.bindAll(this, 'init', '_findHandler');        
    };

    _.extend(ViewCustomBinding, {
        extend: Utils.extend,
        mergeProperties: {
            data: 'merge',
            config: 'merge',
            defaults: 'merge',
            models: 'merge',
            dataBindings: 'merge',
            mapping: 'merge'
        }
    });

    _.extend(ViewCustomBinding.prototype, {
        init: function(element, valueAccessor, allBindingsAccessor, context, bindingContext) {
            var method = this._findHandler(bindingContext);

            var binding = valueAccessor();
            var viewProps = {};

            //checks if its comment DOM to retreive the whole DOM inner content
            if (element.nodeType === 8) {
                var childElements = KO.virtualElements.childNodes(element);
                if (childElements.length > 1) {
                    //assuming the comment wraps a div that contains all the content
                    viewProps.template = false;
                    element = childElements[1];
                }
            }//Checking if the element contains any children
            else if (element.children && element.children.length > 0) {
                viewProps.template = false;
                //////Needs to be re-designed///////////////
                $(element.children).wrapAll('<div/>');
                element = element.children[0];
            }
            if(binding && binding.name) {
                viewProps.name = binding.name;
            } else {
                viewProps.name = binding;
            }

            if(binding && binding.id) {
                viewProps.id = binding.id;
            } else {
                viewProps.id = _.uniqueId('inline_');
            }
            if(binding && typeof binding.initVM !== 'undefined') {
                viewProps.initVM = binding.initVM;
            } else {
                viewProps.initVM = true;
            }

            if(method) {
                method(element, viewProps, context, bindingContext);
            }

            return { controlsDescendantBindings: true };
        },

        _findHandler: function(bindingContext) {
            var handler;
            
            if(bindingContext) {
                if(bindingContext.$data && 
                    _.isObject(bindingContext.$data) && 
                    ('__viewhandler__' in bindingContext.$data) || ('__viewhandler__' in bindingContext)) {
                    handler = bindingContext.__viewhandler__ || bindingContext.$data.__viewhandler__;
                } else {
                    for (var i = 0, length = bindingContext.$parents.length; i < length; i++) {
                        if(bindingContext.$parents[i] && ('__viewhandler__' in bindingContext.$parents[i])) {
                            handler = bindingContext.$parents[i].__viewhandler__;
                            break;
                        }                    
                    };
                }
            }

            return handler;
        }
    });

    return ViewCustomBinding;

});
define('src/core/knockout/WidgetCustomBinding',[
    'src/core/util/Utils',
    'knockout'
], function(Utils, KO) {
    
    

    var WidgetCustomBinding = function() {
        // Only when you know what you are doing. Otherwise, avoid this.
        _.bindAll(this, 'init', '_findHandler');       
    };

    _.extend(WidgetCustomBinding, {
        extend: Utils.extend,
        mergeProperties: {
            data: 'merge',
            config: 'merge',
            defaults: 'merge',
            models: 'merge',
            dataBindings: 'merge',
            mapping: 'merge'
        }
    });

    _.extend(WidgetCustomBinding.prototype, {
        init: function(element, valueAccessor, allBindingsAccessor, context, bindingContext) {
            var inlineWidgetHandler = this._findHandler(bindingContext);

            var binding = valueAccessor();
            var widgetProps = {};

            if(typeof binding === 'string') {
                binding = {name: binding};
            }
            
            widgetProps = _.extend({}, binding, widgetProps);

            //checks if its comment DOM to retreive the whole DOM inner content
            if (element.nodeType === 8) {
                var childElements = KO.virtualElements.childNodes(element);
                if (childElements.length > 1) {
                    //assuming the comment wraps a div that contains all the content
                    widgetProps.template = false;
                    element = childElements[1];
                }
            }//Checking if the element contains any children
            else if (element.children && element.children.length > 0) {
                widgetProps.template = false;
                //////Needs to be re-designed///////////////
                $(element.children).wrapAll('<div/>');
                element = element.children[0];
            }

            // if(binding && typeof binding.initVM !== 'undefined') {
            //     widgetProps.initVM = binding.initVM;
            // } else {
            //     widgetProps.initVM = true;
            // }

            if(inlineWidgetHandler) {
                inlineWidgetHandler(element, widgetProps, context, bindingContext);
            }

            return { controlsDescendantBindings: true };
        },

        _findHandler: function(bindingContext) {
            var handler;
            
            if(bindingContext) {
                if(bindingContext.$data && 
                    _.isObject(bindingContext.$data) && 
                    ('__widgethandler__' in bindingContext.$data) || ('__widgethandler__' in bindingContext)) {
                    handler = bindingContext.__widgethandler__ || bindingContext.$data.__widgethandler__;
                } else {
                    for (var i = 0, length = bindingContext.$parents.length; i < length; i++) {
                        if(bindingContext.$parents[i] && ('__widgethandler__' in bindingContext.$parents[i])) {
                            handler = bindingContext.$parents[i].__widgethandler__;
                            break;
                        }                    
                    };
                }
            }

            return handler;
        }
    });

    return WidgetCustomBinding;

});
define('src/core/knockout/RBACustomBinding',[
    'src/core/util/Utils',
], function(Utils) {
    
    

    // Constructor
    var RBACustomBinding = function() {
        _.bindAll(this, 'init', '_findHandler'); 
    };

    _.extend(RBACustomBinding, {
        extend: Utils.extend
    });

    _.extend(RBACustomBinding.prototype, {
        init: function(element, valueAccessor, allBindingsAccessor, context, bindingContext) {
            var rbaHandler = this._findHandler(bindingContext);
            
            var binding = valueAccessor();
            var props = {id: binding};

            rbaHandler(element, props, context, bindingContext);
        },

        _findHandler: function(bindingContext) {
            var handler;
            
            if(bindingContext) {
                if(bindingContext.$data && 
                    _.isObject(bindingContext.$data) && 
                    ('__rbaHandler__' in bindingContext.$data) || ('__rbaHandler__' in bindingContext)) {
                    handler = bindingContext.__rbaHandler__ || bindingContext.$data.__rbaHandler__;
                } else {
                    for (var i = 0, length = bindingContext.$parents.length; i < length; i++) {
                        if(bindingContext.$parents[i] && ('__rbaHandler__' in bindingContext.$parents[i])) {
                            handler = bindingContext.$parents[i].__rbaHandler__;
                            break;
                        }                    
                    };
                }
            }

            return handler;
        } 
    });

    return RBACustomBinding;

});
define('src/core/knockout/IE8Blame',[
    'knockout'
], function(KO) {
    
    
    
    if(KO.utils.ieVersion <= 11) {
        var invokeForEachNodeInContinuousRange = function(firstNode, lastNode, action) {
            var node, nextInQueue = firstNode, firstOutOfRangeNode = KO.virtualElements.nextSibling(lastNode);
            while (nextInQueue && ((node = nextInQueue) !== firstOutOfRangeNode)) {
                nextInQueue = KO.virtualElements.nextSibling(node);
                action(node, nextInQueue);
            }
        };

        var activateBindingsOnContinuousNodeArray = function(continuousNodeArray, bindingContext) {
            // To be used on any nodes that have been rendered by a template and have been inserted into some parent element
            // Walks through continuousNodeArray (which *must* be continuous, i.e., an uninterrupted sequence of sibling nodes, because
            // the algorithm for walking them relies on this), and for each top-level item in the virtual-element sense,
            // (1) Does a regular "applyBindings" to associate bindingContext with this node and to activate any non-memoized bindings
            // (2) Unmemoizes any memos in the DOM subtree (e.g., to activate bindings that had been memoized during template rewriting)

            if (continuousNodeArray.length) {
                var firstNode = continuousNodeArray[0],
                    lastNode = continuousNodeArray[continuousNodeArray.length - 1],
                    parentNode = firstNode.parentNode,
                    provider = KO.bindingProvider['instance'],
                    preprocessNode = provider['preprocessNode'];

                if (preprocessNode) {
                    invokeForEachNodeInContinuousRange(firstNode, lastNode, function(node, nextNodeInRange) {
                        var nodePreviousSibling = node.previousSibling;
                        var newNodes = preprocessNode.call(provider, node);
                        if (newNodes) {
                            if (node === firstNode)
                                firstNode = newNodes[0] || nextNodeInRange;
                            if (node === lastNode)
                                lastNode = newNodes[newNodes.length - 1] || nodePreviousSibling;
                        }
                    });

                    // Because preprocessNode can change the nodes, including the first and last nodes, update continuousNodeArray to match.
                    // We need the full set, including inner nodes, because the unmemoize step might remove the first node (and so the real
                    // first node needs to be in the array).
                    continuousNodeArray.length = 0;
                    if (!firstNode) { // preprocessNode might have removed all the nodes, in which case there's nothing left to do
                        return;
                    }
                    if (firstNode === lastNode) {
                        continuousNodeArray.push(firstNode);
                    } else {
                        continuousNodeArray.push(firstNode, lastNode);
                        KO.utils.fixUpContinuousNodeArray(continuousNodeArray, parentNode);
                    }
                }

                // Need to applyBindings *before* unmemoziation, because unmemoization might introduce extra nodes (that we don't want to re-bind)
                // whereas a regular applyBindings won't introduce new memoized nodes
                invokeForEachNodeInContinuousRange(firstNode, lastNode, function(node) {
                    if (node.nodeType === 1 || node.nodeType === 8)
                        KO.applyBindings(bindingContext, node);
                });
                invokeForEachNodeInContinuousRange(firstNode, lastNode, function(node) {
                    if (node.nodeType === 1 || node.nodeType === 8)
                        KO.memoization.unmemoizeDomNodeAndDescendants(node, [bindingContext]);
                });

                // Make sure any changes done by applyBindings or unmemoize are reflected in the array
                KO.utils.fixUpContinuousNodeArray(continuousNodeArray, parentNode);
            }
        };

        var originalExecution = function(targetNodeOrNodeArray, renderedNodesArray, bindingContext, renderMode, options) {
            var haveAddedNodesToParent = false;
            switch (renderMode) {
                case "replaceChildren":
                    KO.virtualElements.setDomNodeChildren(targetNodeOrNodeArray, renderedNodesArray);
                    haveAddedNodesToParent = true;
                    break;
                case "replaceNode":
                    KO.utils.replaceDomNodes(targetNodeOrNodeArray, renderedNodesArray);
                    haveAddedNodesToParent = true;
                    break;
                case "ignoreTargetNode": break;
                default:
                    throw new Error("Unknown renderMode: " + renderMode);
            }

            if (haveAddedNodesToParent) {
                activateBindingsOnContinuousNodeArray(renderedNodesArray, bindingContext);
                if (options['afterRender'])
                    KO.dependencyDetection.ignore(options['afterRender'], null, [renderedNodesArray, bindingContext['$data']]);
            }
        };

        var ie8execution = function(targetNodeOrNodeArray, renderedNodesArray, bindingContext, renderMode, options) {
            var timer = window.setTimeout(function() {
                originalExecution(targetNodeOrNodeArray, renderedNodesArray, bindingContext, renderMode, options);
                window.clearTimeout(timer);
            }, 10);
        };
        var count = 0;
        var stopCounting = false;

        var customExecuteTemplate = function(targetNodeOrNodeArray, renderMode, template, bindingContext, options) {
            options = options || {};
            var firstTargetNode = targetNodeOrNodeArray && getFirstNodeFromPossibleArray(targetNodeOrNodeArray);
            var templateDocument = firstTargetNode && firstTargetNode.ownerDocument;
            var templateEngineToUse = (options['templateEngine'] || _templateEngine);
            KO.templateRewriting.ensureTemplateIsRewritten(template, templateEngineToUse, templateDocument);
            var renderedNodesArray = templateEngineToUse['renderTemplate'](template, bindingContext, options, templateDocument);

            // Loosely check result is an array of DOM nodes
            if(count < 200 && !stopCounting) {
                count++;
                originalExecution(targetNodeOrNodeArray, renderedNodesArray, bindingContext, renderMode, options);                    
            } else {
                ie8execution(targetNodeOrNodeArray, renderedNodesArray, bindingContext, renderMode, options);
                stopCounting = true;
                count = 0;
            }
            
            return renderedNodesArray;
        };

        var getFirstNodeFromPossibleArray = function(nodeOrNodeArray) {
            return nodeOrNodeArray.nodeType ? nodeOrNodeArray
                                            : nodeOrNodeArray.length > 0 ? nodeOrNodeArray[0]
                                            : null;
        };

        var _templateEngine;
        KO.setTemplateEngine = function (templateEngine) {
            if ((templateEngine != undefined) && !(templateEngine instanceof KO.templateEngine))
                throw new Error("templateEngine must inherit from KO.templateEngine");
            _templateEngine = templateEngine;
        };

        KO.renderTemplate = function (template, dataOrBindingContext, options, targetNodeOrNodeArray, renderMode) {
            options = options || {};
            if ((options['templateEngine'] || _templateEngine) == undefined)
                throw new Error("Set a template engine before calling renderTemplate");
            renderMode = renderMode || "replaceChildren";

            if (targetNodeOrNodeArray) {
                var firstTargetNode = getFirstNodeFromPossibleArray(targetNodeOrNodeArray);

                var whenToDispose = function () { return (!firstTargetNode) || !KO.utils.domNodeIsAttachedToDocument(firstTargetNode); }; // Passive disposal (on next evaluation)
                var activelyDisposeWhenNodeIsRemoved = (firstTargetNode && renderMode == "replaceNode") ? firstTargetNode.parentNode : firstTargetNode;

                return KO.dependentObservable( // So the DOM is automatically updated when any dependency changes
                    function () {
                        // Ensure we've got a proper binding context to work with
                        var bindingContext = (dataOrBindingContext && (dataOrBindingContext instanceof KO.bindingContext))
                            ? dataOrBindingContext
                            : new KO.bindingContext(KO.utils.unwrapObservable(dataOrBindingContext));

                        // Support selecting template as a function of the data being rendered
                        var templateName = typeof(template) == 'function' ? template(bindingContext['$data'], bindingContext) : template;

                        var renderedNodesArray = customExecuteTemplate(targetNodeOrNodeArray, renderMode, templateName, bindingContext, options);
                        if (renderMode == "replaceNode") {
                            targetNodeOrNodeArray = renderedNodesArray;
                            firstTargetNode = getFirstNodeFromPossibleArray(targetNodeOrNodeArray);
                        }
                    },
                    null,
                    { disposeWhen: whenToDispose, disposeWhenNodeIsRemoved: activelyDisposeWhenNodeIsRemoved }
                );
            } else {
                // We don't yet have a DOM node to evaluate, so use a memo and render the template later when there is a DOM node
                return KO.memoization.memoize(function (domNode) {
                    KO.renderTemplate(template, dataOrBindingContext, options, domNode, "replaceNode");
                });
            }
        };

        KO.renderTemplateForEach = function (template, arrayOrObservableArray, options, targetNode, parentBindingContext) {
            // Since setDomNodeChildrenFromArrayMapping always calls executeTemplateForArrayItem and then
            // activateBindingsCallback for added items, we can store the binding context in the former to use in the latter.
            var arrayItemContext;

            // This will be called by setDomNodeChildrenFromArrayMapping to get the nodes to add to targetNode
            var executeTemplateForArrayItem = function (arrayValue, index) {
                // Support selecting template as a function of the data being rendered
                arrayItemContext = parentBindingContext['createChildContext'](arrayValue, options['as'], function(context) {
                    context['$index'] = index;
                });
                var templateName = typeof(template) == 'function' ? template(arrayValue, arrayItemContext) : template;
                return customExecuteTemplate(null, "ignoreTargetNode", templateName, arrayItemContext, options);
            }

            // This will be called whenever setDomNodeChildrenFromArrayMapping has added nodes to targetNode
            var activateBindingsCallback = function(arrayValue, addedNodesArray, index) {
                activateBindingsOnContinuousNodeArray(addedNodesArray, arrayItemContext);
                if (options['afterRender'])
                    options['afterRender'](addedNodesArray, arrayValue);
            };

            return KO.dependentObservable(function () {
                var unwrappedArray = KO.utils.unwrapObservable(arrayOrObservableArray) || [];
                if (typeof unwrappedArray.length == "undefined") // Coerce single value into array
                    unwrappedArray = [unwrappedArray];

                // Filter out any entries marked as destroyed
                var filteredArray = KO.utils.arrayFilter(unwrappedArray, function(item) {
                    return options['includeDestroyed'] || item === undefined || item === null || !KO.utils.unwrapObservable(item['_destroy']);
                });

                // Call setDomNodeChildrenFromArrayMapping, ignoring any observables unwrapped within (most likely from a callback function).
                // If the array items are observables, though, they will be unwrapped in executeTemplateForArrayItem and managed within setDomNodeChildrenFromArrayMapping.
                KO.dependencyDetection.ignore(KO.utils.setDomNodeChildrenFromArrayMapping, null, [targetNode, filteredArray, executeTemplateForArrayItem, options, activateBindingsCallback]);
            }, null, { disposeWhenNodeIsRemoved: targetNode });
        };

        var templateComputedDomDataKey = KO.utils.domData.nextKey();
        var disposeOldComputedAndStoreNewOne = function(element, newComputed) {
            var oldComputed = KO.utils.domData.get(element, templateComputedDomDataKey);
            if (oldComputed && (typeof(oldComputed.dispose) == 'function'))
                oldComputed.dispose();
            KO.utils.domData.set(element, templateComputedDomDataKey, (newComputed && newComputed.isActive()) ? newComputed : undefined);
        };        
    }

});
define('src/core/knockout/KOUnderscoreTemplateEngineIntegration',[
    'src/core/util/Utils',
    'knockout',
    'knockout.mapping',
    'knockout.validation'
], function(Utils, KO, KOMapping, KOValidation) {
    
    
    
    KO.underscoreTemplateEngine = function () {};

    KO.underscoreTemplateEngine.prototype = KO.utils.extend(new KO.nativeTemplateEngine(), {
        renderTemplate: function(template, bindingContext, options, templateDocument) {
            var registeredTemplate, 
            templateSource, 
            HTMLFragmentTemplate, 
            HTMLFragment, 
            HTMLNodes,
            context, 
            path,
            type,
            contextData,
            parentPath,
            anonymousTemplate,
            textContainer,
            container,
            textTemplate;

            var addUnderscoreCustomFunc = function(context){
                _.extend(context, {'i18n': bindingContext.$root.__getResourceBundle__, 'format' : bindingContext.$root.__getFormatter__});
            };

            anonymousTemplate = new KO.templateSources.anonymousTemplate(template);
            textContainer = anonymousTemplate['text']();
            HTMLNodes = anonymousTemplate['nodes']();

            if (options && textContainer && /\S/.test(textContainer)) {
                if (options.path) {
                    textTemplate = textContainer;

                    context = bindingContext.$data;

                    contextData = Utils.safeUnwrap(context);


                    var path = KO.unwrap(options.path);
                    var templatePathSelector = '[data-template-path="' + path + '"]';
                    var nodePathTemplate = $(HTMLNodes).find(templatePathSelector);
                    if (nodePathTemplate.length > 0) {
                        // textTemplate = nodePathTemplate.prop('outerHTML');
                        // registeredTemplate = _.template(textTemplate);
                        // addUnderscoreCustomFunc(contextData);
                        // HTMLFragment = registeredTemplate(contextData);
                        // this.unwrapAugmentOptions(options);
                        // return KO.utils.parseHtmlFragment(HTMLFragment);

                        HTMLFragment = nodePathTemplate.prop('outerHTML');
                    }
                    else {
                        HTMLFragment = textContainer;
                    }
                    
                    this.unwrapAugmentOptions(options);
                    return KO.utils.parseHtmlFragment(HTMLFragment);
                }
                else if (options.type) {
                    textTemplate = textContainer;

                    context = bindingContext.$data;

                    contextData = Utils.safeUnwrap(context);


                    var type = KO.unwrap(options.type);
                    var templateTypeSelector = '[data-template-type="' + type + '"]';
                    var nodeTypeTemplate = $(HTMLNodes).find(templateTypeSelector);
                    if (nodeTypeTemplate.length > 0) {
                        // textTemplate = nodeTypeTemplate.prop('outerHTML');
                        // registeredTemplate = _.template(textTemplate);
                        // addUnderscoreCustomFunc(contextData);
                        // HTMLFragment = registeredTemplate(contextData);
                        // this.unwrapAugmentOptions(options);
                        // return KO.utils.parseHtmlFragment(HTMLFragment);

                        HTMLFragment = nodeTypeTemplate.prop('outerHTML');
                        this.unwrapAugmentOptions(options);
                        return KO.utils.parseHtmlFragment(HTMLFragment);
                    }
                }
            }

            // textContainer = KO.utils.domData.get(bindingContext, anonymousTemplatesDomDataKey);
            if (options && textContainer && /\S/.test(textContainer) && !options.type) {
                textTemplate = textContainer;

                context = bindingContext.$data;

                contextData = Utils.safeUnwrap(context);

                registeredTemplate = _.template(textTemplate);
                addUnderscoreCustomFunc(contextData);
                HTMLFragment = registeredTemplate(contextData);
                this.unwrapAugmentOptions(options);
                return KO.utils.parseHtmlFragment(HTMLFragment);
            }

            else if(options && options.name) {
                templateSource = this.makeTemplateSource(template, templateDocument);
                HTMLFragmentTemplate = _.template('<% with($data) { %>' + templateSource.text() + '<% } %>'); // TODO: improve with()!!!
                HTMLFragment = HTMLFragmentTemplate(bindingContext).replace(/\s+/g, ' ');

            } else if(options && options.path) {
                context = bindingContext.$data;

                contextData = Utils.safeUnwrap(context);

                path = KO.unwrap(options.path);

                if(requirejs.defined('tpl!' + path)) {
                    registeredTemplate = requirejs('tpl!' + path);
                } else {
                    registeredTemplate = _.template(requirejs('text!' + path));
                    addUnderscoreCustomFunc(contextData);
                }

                HTMLFragment = registeredTemplate(contextData);
                

            } else if(options && options.module) {
                context = bindingContext.$data;
                if(_.isFunction(options.module)) {
                    HTMLFragment = options.module(KOMapping.toJS(context));                    
                } else if(typeof options.module === 'String') {
                    HTMLFragment = _.template(options.module, KOMapping.toJS(context));
                }
            } else if(options && options.type) {
                type = KO.unwrap(options.type);
                registeredTemplate = bindingContext.$root.templates[type];
                context = bindingContext.$data;
                
                contextData = Utils.safeUnwrap(context);

                if(_.isFunction(registeredTemplate)) {
                    HTMLFragment = registeredTemplate(contextData);
                } else if(typeof registeredTemplate === 'string') {
                    addUnderscoreCustomFunc(contextData);
                    HTMLFragment = _.template(registeredTemplate, contextData);
                }
                
            } else {
                throw new Error('Template binding doesn"t have correct "name" or "path" settings.');
            }

            if(options && options.augment) {
                options.data = options.data || {};
                parentPath = KO.unwrap(options.augment.path) || KO.unwrap(options.augment.id);
                options.data.path = KO.observable(parentPath + '/' + KO.unwrap(options.data.id));
            }

            return KO.utils.parseHtmlFragment(HTMLFragment);
        },

        unwrapAugmentOptions: function(options) {
            if(options && options.augment) {
                options.data = options.data || {};
                var parentPath = KO.unwrap(options.augment.path) || KO.unwrap(options.augment.id);
                options.data.path = KO.observable(parentPath + '/' + KO.unwrap(options.data.id));
            }
        },

        createJavaScriptEvaluatorBlock: function(script) {
            return '<%= ' + script + ' %>';
        }
    });

    KO.setTemplateEngine(new KO.underscoreTemplateEngine());

});
define('src/core/knockout/KnockoutPlugins',[
    'module',
    'jquery',
    'underscore',
    'knockout',
    'knockout.mapping',
    'knockout.validation',
    'src/core/util/Utils',
    'src/core/knockout/ContentBinding',
    'src/core/knockout/ViewCustomBinding',
    'src/core/knockout/WidgetCustomBinding',
    'src/core/knockout/RBACustomBinding',
    'src/core/formatter/DateFormatter',
    'src/core/knockout/IE8Blame',
    'src/core/knockout/KOUnderscoreTemplateEngineIntegration'
], function(Module, $, _, KO, KOMapping, KOValidation, Utils, ContentBinding, ViewCustomBinding, WidgetCustomBinding, RBACustomBinding,  DateFormatter) {

    KO.subscribable.fn.unixDate = function() {
        var formatter = new DateFormatter();
        var origin = this;
        var result;

        var computed = KO.computed({
            read: function() {
                var val = origin();
                if (typeof(val) === 'string'){
                    val = parseInt(val,10);
                }
                var value = new Date(val);

                if(!val) {
                    result = '';
                } else {
                    result = formatter.format(value, 'yyyy-mm-dd');                                              
                }

                return result;
            },
            write: function(value) {
                result = new Date(value).getTime();
                origin(result);     
            }
        });

        return computed;
    };

    KO.extenders.backup = function (target) {
        var sub = target.subscribe(function(value) {
            target._backup = target.peek();    
            sub.dispose();
        }, null, 'beforeChange');

        return target;
    };

    KO.subscribable.fn.reset = function() {
        if(!_.isUndefined(this._backup)) {
            this(this._backup);
        }
    };

    KO.bindingHandlers.logger = {
        update: function(element, valueAccessor, allBindings) {
            //store a counter with this element
            var count = KO.utils.domData.get(element, "_ko_logger") || 0,
                data = KO.toJS(valueAccessor() || allBindings());

            KO.utils.domData.set(element, "_ko_logger", ++count);

            if (window.console && window.console.log) {
                console.log(count, element, data);
            }
        }
    };

    if(requirejs.appContext 
        && requirejs.appContext.config 
        && (requirejs.appContext.config.cms)) {
        KO.bindingProvider.instance = new KO.CustomBindingProvider();        
    }

    KO.bindingHandlers.content = new ContentBinding();
    KO.bindingHandlers.view = new ViewCustomBinding();
    KO.bindingHandlers.widget = new WidgetCustomBinding();
    KO.bindingHandlers.rba = new RBACustomBinding();

    KO.virtualElements.allowedBindings.view = true;
    KO.virtualElements.allowedBindings.widget = true;
    KO.virtualElements.allowedBindings.rba = true;



    KO.observable.fn.apply = function(context) {
        var suffix = '.' + this.peek();
        var uniqueId;

        if(_.isObject(context)) {
            if('uniqueId' in context) {
                uniqueId = context.uniqueId + suffix;
            } else {
                uniqueId = context.id + suffix;
            }
        } else if(KO.isObservable(context)) {
            uniqueId = context.peek() + suffix;
        } else if(_.isString(context)) {
            uniqueId = context + suffix;
        } else {
            uniqueId = _.uniqueId('id_');
        }

        return uniqueId;
    }

    KO.observable.fn.isArray = function() {
        return (KO.isObservable(this) && 
            (this.hasOwnProperty('remove') || this.hasOwnProperty('mappedRemove'))
        );
    };

    KO.observableArray.fn.size = function() {
        var items = this(), count = 0;

        if (items == null || typeof items.length === "undefined") {
            return 0;
        }

        for (var i = 0, l = items.length; i < l; i++) {
            if (items[i]._destroy !== true) {
                count++;
            }
        }

        return count;
    };

    KO.extenders.mask = function(target, mask) {
        var result = KO.computed({
            read: function() {
                return target();
            },
            write: function(value) {
                target(value.replace(mask));
            }
        }).extend({notify: 'always'});

        return result;
    };

    KO.extenders.lazy = function(target, options) {
        var result = KO.computed({
            read: function() {
                if (!result.loaded() && options.callback && options.context) {
                    options.callback.call(options.context);
                }
                
                return target();
            },
            write: function(newValue) {
                result.loaded(true);
                target(newValue);
            },
            
            deferEvaluation: true
        });
        
        result.loaded = KO.observable();
        
        result.refresh = function() {
            result.loaded(false);
        };
        
        return result;
    };

    KO.extenders.process = function(target, options) {
        var result = KO.computed({
            read: function() {
                var result;
                if (options.callback && options.context) {
                    result = options.callback.call(options.context, target);
                } else if (options.callback) {
                    result = options.callback(target);
                }
                return result;
            },
            write: function(newValue) {
                target(newValue);
            },
            deferEvaluation: true,
            disposeWhenNodeIsRemoved: options.node
        });

        return result;
    };

    /* action binding */

    var _processActions = function(valueAccessor) {
        var actions = [];
        var actionsBinding = KO.unwrap(valueAccessor());        

        if(_.isObject(actionsBinding)) {
            for(var event in actionsBinding) {
                if (event === 'args'){ //args is a special case property, so we will not create an event named args
                    continue;
                }
                actions.push({action: actionsBinding[event], event: event, args:actionsBinding.args});
            }
        } else if(_.isString(actionsBinding)) {
            actions.push({action: actionsBinding, event: 'click'});
        }

        return actions;
    };

    var action = function(element, valueAccessor, allBindingsAccessor, context, bindingContext) {
        var method = context.__handler__;

        if(!method) {
            method = bindingContext.$root.__handler__;
        }
        
        var actions = _processActions(valueAccessor);        
        
        _.each(actions, function(action) {
            var currentAction = KO.unwrap(action.action);
            var $element = $(element);
            $element.off(action.event);

            if(context.__vmKeys__ && context.__vmKeys__['action.' + currentAction]) {
                currentAction = KO.unwrap(context.__vmKeys__['action.' + currentAction]);
            }

            $element.on(action.event, function(origEvent) {
                var data = KOMapping.toJS(context);
                delete data.__handler__;
                delete data.__ko_mapping__;
                delete data.__viewhandler__;
                delete data.__getResourceBundle__;
                method(currentAction, origEvent, data, context, bindingContext, action.args);
            });
        });
    };

    KO.bindingHandlers.action = {
        init: action,
        update: action
    };

    /* view binding */

    var findPropInContext = function(bindingContext, propName) {
        var handler;

        if(bindingContext) {
            if(bindingContext.$data && _.isObject(bindingContext.$data) &&
                (propName in bindingContext.$data) || (propName in bindingContext)) {
                handler = bindingContext[propName] || bindingContext.$data[propName];
            } else {
                for (var i = 0, length = bindingContext.$parents.length; i < length; i++) {
                    if(typeof(bindingContext.$parents[i]) === 'object' && (propName in bindingContext.$parents[i])) {
                        handler = bindingContext.$parents[i][propName];
                        break;
                    }
                }
            }
        }

        return handler;
    };

    KO.bindingHandlers.click = {
        init: function(element, valueAccessor, allBindings, viewModel, bindingContext) {
            var viewContext = findPropInContext(bindingContext,'__viewContextHandler__');
            var newValueAccessor = function () {
                var result = {};
                result['click'] = valueAccessor()(viewContext);
                return result;
            };
            return KO.bindingHandlers['event']['init'].call(this, element, newValueAccessor, allBindings, viewModel, bindingContext);
        }
    };
    KO.bindingHandlers.click.preprocess = function(val){
        return 'function(newScopeFetcher){ if (typeof(newScopeFetcher) === "function") { with(newScopeFetcher()) { return ' + val + '} } else { return ' + val + '} }';
    };

    var eventHandler = function(element, valueAccessor, allBindingsAccessor, context, bindingContext) {
        var events = _processActions(function() {
            var actionsBinding = valueAccessor();
            if ( _.isFunction(actionsBinding)){
                var viewContext = findPropInContext(bindingContext,'__viewContextHandler__');
                actionsBinding = actionsBinding(viewContext);
            }
            return actionsBinding;
        });
        var $element = $(element);
        var convertToviewEventName = function(eventName){
            return eventName + '.view';
        };
        _.each(events, function(event) {
            var actionsBinding = KO.unwrap(event.action);
            var eventHandler = context.__clickhandler__ || bindingContext.$root.__clickhandler__ ;
            var viewEventName = convertToviewEventName(event.event);
            $element.off(viewEventName);
            $element.on(viewEventName, function(origEvent) {
                var data = KOMapping.toJS(context);
                var handlerReturnValue;
                try{
                    if(!_.isUndefined(eventHandler)) {
                        handlerReturnValue = eventHandler( event.args ? { method: actionsBinding, args: event.args } : actionsBinding, $element, data, context, bindingContext, origEvent );
                    }
                    else if(!_.isUndefined(event.action)){
                        handlerReturnValue = event.action(context, origEvent, $element, bindingContext, data);
                    }
                }
                finally {
                    if (handlerReturnValue !== true) { // Normally we want to prevent default action. Developer can override this by explicitly returning true.
                        if (origEvent.preventDefault)
                            origEvent.preventDefault();
                        else
                            origEvent.returnValue = false;
                    }
                }
                var bubble = allBindingsAccessor.get(event.event + 'Bubble') !== false;
                if (!bubble) {
                    origEvent.cancelBubble = true;
                    if (origEvent.stopPropagation)
                        origEvent.stopPropagation();
                }

            });
        });
    };
    KO.bindingHandlers.event = {
        init: eventHandler,
        update: eventHandler
    };
    KO.bindingHandlers.event.preprocess = function(val){
        return 'function(newScopeFetcher){ if (typeof(newScopeFetcher) === "function") { with(newScopeFetcher()) { return ' + val + '} } else { return ' + val + '} }';
    };

    /* i18n binding */

    var i18n = function(element, valueAccessor, allBindingsAccessor, context, bindingContext) {
        var getResourceBundle = bindingContext.$root.__getResourceBundle__;
        var resourceBundle = getResourceBundle();
        var msg = KO.unwrap(valueAccessor());
        var args, str;

        if(_.isObject(msg)) {
            args = KO.toJS(msg.args);
            msg = KO.unwrap(msg.message);
        } 

        if(!resourceBundle || !resourceBundle.getString(msg, args)) {
            str = msg;
        } else {
            str = resourceBundle.getString(msg, args);   
        }

        if(_.isUndefined(str)) {
            str = '';
        }       

        element.innerHTML = str;
    };

    KO.bindingHandlers.i18n = {
        init: i18n,
        update: i18n
    };

    KO.bindingHandlers.allowBindings = {
        init: function(elem, valueAccessor) {
            var shouldAllowBindings = KO.unwrap(valueAccessor());
            return { controlsDescendantBindings: !shouldAllowBindings };
        }
    };
    KO.virtualElements.allowedBindings.allowBindings = true;
    
    KO.bindingHandlers.file = {
        init: function(element, valueAccessor) {
            KO.utils.registerEventHandler(element, 'change', function(origEvent) {
                var inputElm = origEvent.target;
                var formData = new FormData();
                for (var i = 0; i < inputElm.files.length; i++) {
                    var file = this.files[i];
                    formData.append(inputElm.name,file,file.name);
                }
                if (KO.isObservable(valueAccessor())) {
                    valueAccessor()(formData);
                }
                KO.utils.triggerEvent(inputElm,'filesSelected');
            });
        }
    };
    KO.bindingHandlers.extendWith = {
        init: function(element, valueAccessor, allBindings, viewModel, bindingContext) {
            var invokeMethod = viewModel.invoke;
            if(!invokeMethod) {
                invokeMethod = bindingContext.$root.invoke;
            }
            var extendParams = KO.unwrap(valueAccessor());
            var extendObj = {};
            extendObj[extendParams.name] = invokeMethod(extendParams.func, extendParams.params);

            // Make a modified binding context, with a extra properties, and apply it to descendant elements
            var innerBindingContext = bindingContext.extend(extendObj);
            KO.applyBindingsToDescendants(innerBindingContext, element);

            // tell KO *not* to bind the descendants itself, otherwise they will be bound twice
            return { controlsDescendantBindings: true };


        }
    };
});

define('src/core/viewModel/ObservableViewModel',[
    'jquery',
    'underscore',
    'backbone',
    'src/core/util/Utils',
    'src/core/binding/Binding',
    'src/core/model/Model',
    'src/core/model/RESTModel',
    'src/core/model/Collection',
    'src/components/collection/viewmodel/CollectionViewModel',
    'src/core/viewModel/ViewModel',
    'src/core/util/StorageUtil',
    'knockout',
    'knockout.mapping',
    'knockout.validation',
    'src/core/knockout/KnockoutPlugins'
], function($, _, Backbone, Utils, Binding, Model, RESTModel, Collection, ViewModel, CollectionViewModel, StorageUtil, KO, KOMapping, KOValidation) {

    var ObservableViewModel = function(options) {
        var mapping, data;

        this.options = options || {};
        this._populateModels();
        mapping = this._getPropertyByPrecedence('mapping', {});

        this._augmentMapping(mapping);

        this.observe = this._getPropertyByPrecedence('observe', true);
        data = this._getPropertyByPrecedence('data', this.defaults);

        if(KO.isObservable(data)) {
            this.data = data;
        } else {
            this.data = KOMapping.fromJS(data, mapping);
        }

        this.config = this._getPropertyByPrecedence('config', {visible: true, enabled: true});
        this.dataBindings = this._getPropertyByPrecedence('dataBindings', []);

        this.data.__handler__ = _.bind(this.handleAction, this);
        if (!this.subViewModels) {
            this.subViewModels = {};
        }
        this._instantiateSubViewModels(options);
        this._listenToModelChanges();
        this.initialize.apply(this, arguments);

        this.data.__vmdata__ = true;

        this.data.invoke = _.bind(this.invoke, this);

        this._bindData();

        this._initValidation();
        this._processValidationPaths();

        this._processRba();

        delete this.data.__vmdata__;
    };

    _.extend(ObservableViewModel, {
        isViewModel: true,
        extend: Utils.extend,
        mergeProperties: {
            data: 'merge',
            config: 'merge',
            defaults: 'merge',
            models: 'merge',
            dataBindings: 'merge',
            mapping: 'merge'
        }
    });

    _.extend(ObservableViewModel.prototype, Backbone.Events, {    
        initialize: function() {},

        config: {
            validationSettings: {
                insertMessages: false,
                decorateInputElement: true,
                errorsAsTitle: false,
                errorElementClass: 'is-invalid',
                errorMessageClass: 'validationMessage',
                grouping: {
                    deep: true
                }
            }
        },

        defaults : {
        },
        
        processData : function (newData) {
            KOMapping.fromJS(newData, this.data);
        },
        
        _listenToModelChanges: function () {
            var models = this.options.models;
            _.each(models, function (collection, key) {
                var onCollectionChanged = _.bind(function(coll){
                    var newData = {models: { }};
                    if (KOMapping.isMapped(coll)){
                        coll = KOMapping.toJS(coll);
                    }
                    newData.models[key] = coll;                        
                    this.processData (newData);
                },this);
                var onDataReady = _.bind(function(pagginInfo , coll) {
                    onCollectionChanged(coll);
                },this);
                if (collection.on){
                    collection.on('dataReady', onDataReady);
                    collection.on('reset', onCollectionChanged);
                    //collection.on('change add remove', onCollectionChanged);
                }
            },this);
        },

        _initValidation: function() {
            var validationConfig = this.getConfig('validationSettings');
            KOValidation.init(validationConfig, true); 
        },

        invoke: function(method) {
            var args = Array.prototype.slice.call(arguments, 1);
            var result = this[method].apply(this, args);

            return result;
        },

        // TODO: deprecate with message
        getData: function() {},

        _augmentMapping: function(mapping) {
            
        },

        augment: function(prop, value, mapping) {  
            var data = this.get(true);

            if(_.isObject(mapping)) {
                data[prop] = KOMapping.fromJS(value, mapping);                       
            } else if(_.isUndefined(mapping)) {
                data[prop] = value;
            }
        },

        set: function(prop, value, mapping) {
            if(_.isBoolean(mapping) && mapping) { // raw === true
                mapping = {};
                mapping.copy = [prop]; // do not make the value observable
            } else if(_.isUndefined(mapping)) {
                mapping = {};
            } else if(mapping._bound) {
                mapping = mapping.mapping || {};                
            }

            var silent = mapping.silent;
            var newValue = {};
            var oldValue;

            if(_.isObject(prop)) {
                if(KO.isObservable(prop)) {
                    newValue = KO.toJS(prop);
                } else {
                    if(_.isObject(value)) {
                        mapping = value;
                        newValue = prop;
                    } else {
                        mapping = KO.utils.unwrapObservable(prop)['__ko_mapping__'];

                        if(mapping) {
                            newValue = KOMapping.toJS(prop);                            
                        } else {
                            newValue = prop;
                        }
                    }
                }

                delete newValue.__ko_mapping__;

                KOMapping.fromJS(newValue, mapping, this.data);
                this._triggerEvent({name: 'change', prop: prop});
            } else {
                if(!_.isUndefined(this.data[prop]) && KO.isObservable(this.data[prop])) {
                    if(this.data[prop].isArray && this.data[prop].isArray()) {
                        KOMapping.fromJS(value, mapping[prop], this.data[prop]);
                    } else {
                        oldValue = KO.unwrap(this.data[prop]);
                        this.data[prop](value);
                    }
                } else {
                    mapping.observe = mapping.observe || [];
                    // mapping.observe.push(prop);

                    newValue[prop] = value;
                    KOMapping.fromJS(newValue, mapping, this.data);
                }               
                
                if(!silent) {
                    if(oldValue !== value) {
                        this._triggerEvent({name: 'change', prop: prop, value: value});                        
                    }
                }
            }            
        },

        get: function(prop, wrapped) {
            var result;

            if(_.isBoolean(prop) && prop) {
                result = this._getWrapped();
            } else if(_.isObject(prop)) {
                result = this._getMapped(prop);
            } else {
                if(!_.isUndefined(wrapped)) {
                    result = this._getWrapped(prop);
                } else {
                    if(prop) {
                        if(!_.isUndefined(this.data[prop])) {
                            result = KOMapping.toJS(this.data[prop]);
                        }
                    } else {
                        result = KOMapping.toJS(this.data);
                    }                    
                }
            }

            return result;
        },

        setValueByPath: function(path, value, mapping) {
            var data = this._getWrapped();
            Utils.setValueByPath(data, path, value, mapping);
        },

        getValueByPath: function(path, wrapped) {
            var data = this._getWrapped();
            var result;

            if(path) {
                result = Utils.getValueByPath(data, path, wrapped);
            } else {
                result = this.get(wrapped);
            }

            return result;
        },

        _getMapped: function(mapping) {
            return KOMapping.toJS(this.data, mapping);
        },

        attr: function(arg, value) {
            var data, i, len;

            // batch getter
            if(_.isArray(arg)) {
                data = {};
                for (i = 0, len = arg.length; i < len; ++i) {
                    data[arg[i]] = this.get(arg[i]);
                }
                return data;

            // setter
            } else if (_.isString(arg) && arguments.length > 1 || _.isObject(arg)) {
                return this.set(arg, value);

            // getter
            } else if(_.isString(arg)) {
                return this.get(arg);
            }
        },

        _getWrapped: function(prop) {
            var result;
            if(prop) {
                result = this.data[prop];
            } else {
                result = this.data;
            }

            return result;
        },

        setConfig: function(prop, value) {
            this.config[prop] = value;
            this._triggerEvent({name: 'change', subname: 'config', prop: prop, value: value});
        },

        getConfig: function(prop) {
            var result;
            if(prop) {
                result = this.config[prop];
            } else {
                result = this.config;
            }
            return result;
        },

        reset: function() {
            this.clear();
            this.data.__handler__ = _.bind(this.handleAction, this);
        },

        clear: function() {
            this.data = {};
        },

        handleAction : function(action) {
            var actions, currentAction;

            if (action && _.isString(action)) {
                actions = this.getConfig('actions');

                if (actions) {
                    currentAction = actions[action];

                    if(_.isString(currentAction)) {
                        currentAction = this[currentAction];
                    }
                } 

                if(!currentAction) {
                    currentAction = this[action];
                }

                if(currentAction) {
                    currentAction.apply(this, _.tail(arguments, 1));
                } else {
                    this.trigger.apply(this, arguments);
                    arguments[0] = 'action:' + arguments[0];
                    this.trigger.apply(this, event);
                }
            }
        },

        _createDataForEvent: function(prop, value) {
            var eventData = {
                _warningWasFound: undefined,
                changed: {},
                target: this
            };

            if(value) {
                eventData.value = value;
                eventData.changed[prop] = value;
            } else {
                eventData.changed = prop;
            }

            return eventData;
        },

        _triggerEvent: function(config) {
            var eventData = this._createDataForEvent(config.prop, config.value),
                eventName = config.name,
                augmentedEventData;

            if(config.subname) {
                eventName += ':' + config.subname;
                augmentedEventData = eventData.changed;
                eventData.changed = {};
                eventData.changed[config.subname] = augmentedEventData;
            }

            this.trigger(eventName, eventData);

            if(_.isObject(config.prop)) {
                _.each(config.prop, function(value, key) {
                    eventData.value = config.prop[key];
                    this.trigger(eventName + ':' + key, eventData);        
                }, this)
            } else {
                this.trigger(eventName + ':' + config.prop, eventData);                
            }
        },

        _getPropertyByPrecedence: function(name, defaultValue) {
            var property = defaultValue;

            if(!_.isUndefined(this.options[name])) {
                property = this.options[name];
            } else if(!_.isUndefined(this[name])) {
                property = this[name];
            }

            if(ObservableViewModel.mergeProperties[name]) {
                if (_.isArray(property) ) {
                    property = _.union(defaultValue, this[name] || [], this.options[name] || []);
                } else {
                    property = $.extend(true, {}, defaultValue, this[name], this.options[name]);
                }
            }
            
            return property;

        },

        getSubViewModel: function(name) {
            var viewModel;
            if(this.subViewModels) {
                viewModel = this.subViewModels[name];
            }

            return viewModel;
        },

        addSubViewModel: function(name, vm) {
            this.subViewModels = this.subViewModels || {};
            this.subViewModels[name] = vm;
        },

        getModel: function(model) {
            return this.models[model];
        },
        create: Utils.create,

        // events engine (needed for View <-> Model validation errors)
        
        coreEvents: {
            'error *' : 'dataError',
            'all *' : 'errorHandler'
        },
        
        _errorEventPattern: /^(error:|warning:)(.+)$/,
        
        errorHandler : function( eventName, model, error ) {
            if (this._errorEventPattern.exec(eventName)) {
                this.trigger( eventName, model, error);
            }
        },
        
        dataError : function( model, error, options ) {
            this.trigger('error', model, error, options);
        },
        
        _populateModels: function() {
            var models = this.models = _.defaults({}, this.options.models, this.models);

            var ModelConstructor;
            for (var key in models) {
                ModelConstructor = models[key];
                if (_.isFunction(ModelConstructor)) {
                    models[key] = new ModelConstructor();
                } else if (_.isArray(ModelConstructor)) {
                    models[key] = new Collection(ModelConstructor);
                } else if (!(ModelConstructor instanceof Backbone.Model || ModelConstructor instanceof Backbone.Collection)) {
                    models[key] = new Model(ModelConstructor);
                }
            }

            this.delegateEvents(models);
        },

        defaultModel: function(models) {
            models = _.values(models || this.models || {});
            if (models && (models.length === 1)) {
                return models[0];
            }
        },

        delegateEvents : function( models, events) {
            if (!models) {
                return;
            }
            
            if (_.isFunction(events)) {
                events = events.call(this);
            }

            events = _.defaults( {}, events, this.events, this.coreEvents);
            this.undelegateEvents();
            var delegatedEvents = this._delegatedEvents = {};
            var defaultModel = this.defaultModel(models);
            
            _.each(events, function(value, key) {
                var handler = this[events[key]];
                var match = key.match(eventSplitter);
                var eventName = match[1];
                var modelName = match[2] || defaultModel;
                
                var eventProducers;
                if (modelName === '*') {
                    eventProducers = _.values(models);
                }
                else {
                    if (!models[modelName]) {
                        throw new Error('Model "' + modelName + '" does not exist');
                    }
                    eventProducers = [ models[modelName] ];
                }
                                
                _.each(eventProducers, function(eventProducer) {
                    if (modelName !== '*' || _.isFunction(eventProducer.on)) {
                        eventProducer.on(eventName, handler, this);

                        var list = delegatedEvents[modelName] || (delegatedEvents[modelName] = []);
                        list.push({
                            name: eventName,
                            handler: handler,
                            producer: eventProducer
                        });
                    }
                }, this);                
            });
        },

        undelegateEvents : function(model) {
            var events;
            if (model) {
                events = this._delegatedEvents[model] || [];
            } else {
                events = _.flatten(_.values(this._delegatedEvents || {}));
                delete this._delegatedEvents;
            }
            for (var i = 0, l = events.length; i < l; ++i) {
                var event = events[i];
                event.producer.off(event.name, event.handler);
            }
        },

        // Binding

        dataBindings: [],

        _bindData: function() {
            this._binding = new Binding();
            this._binding.bindAll(this);
        },

        _instantiateSubViewModels: function( options ) {
            // TODO: check effectiveness
            var subViewModel;
            for (var key in this.subViewModels) {
                subViewModel = this.subViewModels[key];
                if (_.isFunction(subViewModel)) {
                    this.subViewModels[key] = this.create(_.uniqueId('_viewmodel'), subViewModel, {}); 
                }
                else if (_.isArray(subViewModel)) {
                    this.subViewModels[key] = this.create(_.uniqueId('_viewmodel'), CollectionViewModel, {
                        models: {
                            data: new Collection(subViewModel)
                        }
                    });
                } 
                else if (_.isObject(subViewModel) && _.has(subViewModel,'id') && _.has(subViewModel, 'class') && _.keys(subViewModel).length === 2) {
                    this.subViewModels[key] = this.create(subViewModel.id, subViewModel['class'], {});
                }
                else if (!(subViewModel instanceof ViewModel || subViewModel instanceof CollectionViewModel || subViewModel instanceof ObservableViewModel)) {
                    this.subViewModels[key] = this.create(_.uniqueId('_viewmodel'), ViewModel, subViewModel); 
                }
            }
        },

        _processValidationPaths: function() {
            var validations = this.getConfig('validations');
            _.each(validations, this._processSinglePath, this);
        },

        _processSinglePath: function(validations, path) {
            _.each(validations, function(rule) {
                this._processSingleValidation(rule, path);
            }, this);
        },

        _processSingleValidation: function(rule, path) {
            var rules = this.getConfig('rules') || {};
            var ruleName = _.keys(rule)[0];

            var validation = _.extend({}, KOValidation.rules[ruleName], rules[ruleName]);

            var customRule = {
                validation: validation
            };

            customRule.validation.params = rule[ruleName];

            var observable = this.getValueByPath(path, true);
            observable = observable.extend(customRule);

            this.setValueByPath(path, observable, true);
        },

        _processRba: function() {
            var rbaUrl = this.getConfig('rbaUrl');
            if (rbaUrl) {
                var model = new RESTModel( null, { url: rbaUrl } );
                var self = this;
                return model.fetch( {success: function( model, response ) {
                    self.set(response);
                }});
            }
        },

        destroy: function() {
            this.off();            
            this.clean();
            this.undelegateEvents();
            this._binding.unbind();
            this._unbindSubViewModelEvents();
        },

        _unbindSubViewModelEvents: function() {
            if (this.subViewModels) {
                _.each(this.subViewModels, function(subViewModel) {
                    if(subViewModel && (typeof subViewModel.off === 'function')) {
                        subViewModel.off(null, null, this);                        
                    }
                }, this);
            }  
        },

        clean: function() {
            
        },
        shouldRegister: function() {
            return true;
        },
        //Storage
        shouldRestore: function() {
            return true;
        },
        shouldPersist: function() {
            return true;
        },
        persistent: [],
        restoreData: function(moduleID) {
            var storedData = StorageUtil.get(moduleID) || {};
            var storedPersistenData = {};
            var setValByPath = function(obj, path, val){
                var propsStack = path.split('.');
                while(propsStack.length>1){
                    var prop = propsStack.shift();
                    if (!obj.hasOwnProperty(prop)){
                        obj[prop] = {};
                    }
                    obj = obj[prop];
                }
                obj[propsStack.shift()] = val;
            };
            for(var i= 0, len = this.persistent.length; i < len ; i++){
                var path = this.persistent[i];
                var val = Utils.getValueByPath(storedData,path);
                setValByPath(storedPersistenData,path,val);
            }
            this.set(storedPersistenData);
        },
        persist: function(moduleID, key, value) {
            var storedData = StorageUtil.get(moduleID) || {};
            var splitKey = key.split('.');
            var obj = storedData;
            for(var i= 0, len = splitKey.length; i< (len -1) ; i++){
                obj[splitKey[i]] = obj[splitKey[i]] || {};
                obj = obj[splitKey[i]];
            }
            obj[splitKey[splitKey.length-1]] = value;
            StorageUtil.set(moduleID, storedData);
        }
    });

    _.extend(ObservableViewModel.prototype,{
        _manipulateCollectionData : function (coll, pageData) {
            return _.map(pageData,function(model) { return (model.toJSON ? model.toJSON() :model) ; });
        },
        collectionMapper : function(bindPropName, collection/*, options*/) {
            this.addObservableCollection(collection,bindPropName);
        },
        addObservableCollection : function (collection , bindPropName) {

            var self = this;
            var observableVM = this.data;
            observableVM[bindPropName] = KO.observableArray();
            observableVM[bindPropName].modelName = _.find(_.map(this.models,function(coll,name){ return ((collection  === coll) ? name : false);}), function(v){return v});
            observableVM[bindPropName].bindPropName = bindPropName;

            var onCollectionChanged = function(coll) {
                var result, currPage = coll.getPageNum();
                if (coll.isAccumelated()){
                    var to = (currPage+1) * coll.pagination.pageSize;
                    to = Math.min(coll.pagination.maxIndex, to);
                    result = coll.getRows(0, to);
                }
                else {
                    result = coll.getPage(currPage);
                }
                observableVM[bindPropName](self._manipulateCollectionData(coll,result.data));
            };
            var onDataReady = function(pagginInfo , coll) {
                onCollectionChanged(coll);
            };
            if (collection.on){
                collection.on('dataReady', onDataReady);
                collection.on('reset', onCollectionChanged);
                //collection.on('change add remove', onCollectionChanged);
            }
        },
        getPagination : function (params) {

            if (!params || !params.items || !params.items.modelName || !params.items.bindPropName){
                throw 'To create a pagination extension you must provide an item object that was created by calling addObservableCollection.';
            }
            var coll = this.models[params.items.modelName];
            var bindPropName = params.items.bindPropName;
            if (!coll || !(coll instanceof Backbone.Collection)){
                throw 'To create a pagination a valid collection object must be used';
            }
            var pagination = {
                prev: function () {
                    coll.prev();
                },
                next: function () {
                    coll.next();
                },
                accPrev: function () {
                    coll.accPrev();
                },
                accNext: function () {
                    coll.accNext();
                },
                pageNum: KO.computed({
                    read: function() {
                        var x= this.data[bindPropName]();//used so that knockout will understand that we base our answer on the models.
                        return coll.getPageNum();
                    },
                    write: function(pageNum) {
                        if (typeof pageNum === 'string'){
                            pageNum = parseFloat(pageNum);
                        }
                        coll.gotoPage(pageNum);
                    },
                    owner: this
                }),
                pageSize: KO.computed(function() {
                    var x = this.data[bindPropName]();//used so that knockout will understand that we base our answer on the models.
                    return coll.pagination.pageSize;
                },this),
                hasPrev: KO.computed(function() {
                    var x = this.data[bindPropName]();//used so that knockout will understand that we base our answer on the models.
                    return coll.hasPrev();
                },this),
                hasNext: KO.computed(function() {
                    var x = this.data[bindPropName]();//used so that knockout will understand that we base our answer on the models.
                    return coll.hasNext();
                },this),
                totalPages: KO.computed(function() {
                    var x = this.data[bindPropName]();//used so that knockout will understand that we base our answer on the models.
                    return coll.getTotalPagesNumber();
                },this),
                totalSize: KO.computed(function() {
                    var x = this.data[bindPropName]();//used so that knockout will understand that we base our answer on the models.
                    return coll.pagination.maxIndex;
                },this),
                pageStart: KO.computed(function() {
                    var x = this.data[bindPropName]();//used so that knockout will understand that we base our answer on the models.
                    return coll.pagination.pageStart;
                },this)
            };
            return pagination;
        }
    });

    var eventSplitter = /^\s*(\S*)\s*(\S*)?\s*$/;

    return ObservableViewModel;
});
/**
Base UXF <em>View</em> that <strong>all other Views extend</strong>. Provides an extensive set of common methods and behaviour.

Extends the Backbone.View. It doesn't determine anything about your HTML or CSS for you, 
and can be used with any JavaScript templating library. 
The general idea is to organize your interface into logical views, backed by view-models (which can be backed by models),
each of which can be updated independently when the view-model/model changes, without having to redraw the page. 
Instead of digging into a JSON object, looking up an element in the DOM, and updating the HTML by hand, 
you can bind your view's <code>render</code> function to the view-model's <code>change</code> event and now everywhere that model data is displayed in the UI,
it is always immediately up to date.

@class Lightsaber.Core.View
@namespace Lightsaber.Core
@module Lightsaber.Core
@extends Backbone.View

@constructor
@param {Object} options constructor's only parameter
@param {String|HTML Element|jQuery Object} options.el the element to attach to
@param {Lightsaber.Core.ViewModel} options.viewModel <em>ViewModel</em> that the <em>View</em> is going to use
@param {Object} options.config main configuration parameter
@param {String} options.config.vmKeys mapping of expected name of <em>ViewModel</em> 
@param {String} options.config.vmKeysChangeEvents mapping of expected event name of <em>ViewModel</em> 
property changes to its actual name in the specific <em>ViewModel</em> that this <em>View</em>
receives at runtime.

**/
define('src/core/view/View',[
	'underscore',
	'jquery',
	'backbone',
	'require',
	'src/core/model/Model',
	'src/core/model/RESTModel',
	'src/core/viewModel/ViewModel',
    'src/core/viewModel/ObservableViewModel',
	'src/core/binding/Binding',
	'src/core/util/Utils',
    'single!src/core/formatter/Formatter',
    'knockout',
    'knockout.mapping'
], function(_, $, Backbone, require, Model, RESTModel, ViewModel, ObservableViewModel, Binding, Utils, Formatter, KO, KOMapping) {

	
	

	var commonConfig = {
		autoRender: true,
		autoRefresh: false,
		rootCSS: ''
	};

	var actionsRegex = /action\.\b/;
	
	/**
	 * Assigned view-model's property <code>change</code> event
	 * @event
	 * @name change
	 * @memberOf Lightsaber.Core.View
	 * @param {Object} [event]
	 * the change event object
	 */
	
	/**
	 * Assigned view-model's <code>visible</code> change event
	 * @event
	 * @name change:config:visible
	 * @memberOf Lightsaber.Core.View
	 * @param {Object} [event]
	 * the visible event object
	 */
	
	/**
	 * Assigned view-model's <code>enable</code> change event
	 * @event
	 * @name change:config:enable
	 * @memberOf Lightsaber.Core.View
	 * @param {Object} [event]
	 * the enable event object
	 */
	
	var View = Backbone.View.extend({
	
		publicMethods : ['remove','getResourceBundle','setTemplate','setId','setRootCSS','addClass','removeClass','toggleClass','hasClass','setConfig','getConfig'],
		
        /**
		Default values of *View* `config` options. 

		After initialization configuration options can be gotten/set through 
        {{#crossLink "Lightsaber.Core.View/getConfig:method"}}{{/crossLink}} and
        {{#crossLink "Lightsaber.Core.View/setConfig:method"}}{{/crossLink}} methods.

        @property {Object} config
        @default {}
		**/
		config: {},

		placeholders: {},
		
        /**
		Configuration property that maps expected *ViewModel* properties to the actual ones.
		@property {Object} vmKeys
		**/
		vmKeys: {},
		/***
		 * Used for setting the listeners for VM data model changes according to the correct key.
		 */
		vmKeysChangeEvents : {},
		
		_isElProvided: false,
		
		/***
		 * Used as a UXF View ID prefix created with data-uxf-view
		 */
		INNER_VIEW_ID_PREFIX: 'uxf_view_',
		
		/**
		 * Performs the initial configuration of a View with a set of options.
		 * Keys with special meaning (viewModel, collection, id, className), are
		 * attached directly to the view.
		 * @param {Object} options Options for a new View. 
		 */
		_configure: function(options) {

			var templateFalse = this._isTemplateFalse(options);
			// in case we want to use the current DOM as the HTML template, only works for static templates
			if (templateFalse) {
				this._configureTemplateFromHTML(options);
			}

            this.template = options.template || this.template;
            this.optionsMap = options.optionsMap || this.optionsMap || {};
            this.vmKeysChangeEvents = _.extend({}, this.vmKeysChangeEvents, options.vmKeysChangeEvents);
			// set attributes values
			options.attributes = _.extend({}, this.attributes, options.attributes || {});
			Backbone.View.prototype._configure.call(this, options);

			// Backbone.View._configure assigned this.options
			options = this.options;
			
			// setting the keys we will be using for the viewmodel data and config
			this.vmKeys  = _.extend({}, this.vmKeys, options.vmKeys || {});

			// set configuration
			this._config = new Model();
            if(options.scope) {
                this.setConfig('scope', options.scope);
            }

			this.___id = options.___id;

			this.___parent = options.___parent;

			var config = $.extend(true, {}, commonConfig, this.config, options.config || {});

			config.tagName || (config.tagName = this.tagName);
			config.id || (config.id = this.id);
			var className = config.className || (config.className = this.className);
			var el = config.el || this.el;
			// avoid setElement call, Backbone calls it itself
			if (config.el) delete config.el;
			this.setConfig(config);
			if(el) {
				this.el = el;
				this._isElProvided = true;
			}
			this._config.on('change', function(config) { this.configChanged(config._changed); }, this);

			// calculate class attribute
			className && (this.attributes['class'] = className);

            this._initViewModel(options);

			this.insertMethod = options.insertMethod || config.insertMethod;

			_.bindAll(this, '_getLocaleString');

			this._bindEvents();

			// Remove model direct property
			delete this.model;

			this.subViews = _.extend(this.subViews || {}, config.subViews || options.subViews);
			// if subViews were given as an object literal (deprecated), convert it to an array.
			if (!_.isArray(this.subViews)) {
				var subViewsArr = [];
				_.each(this.subViews, function(subViewDetails, key) {
					subViewsArr.push(subViewDetails);
				}, this);
				this.subViews = subViewsArr;
			}

			this._subViews = {};
			this.binding = new Binding();
		},
		_isTemplateFalse: function(options) {
			var el = options.el || (options.config && options.config.el);
			if (!el || el.nodeName === '#comment') {
				return;
			}

			if ((typeof el === "string") || !(el instanceof jQuery)) {
				el = $(el);
				if (options.config && options.config.el) {
					options.config.el = el;	
				}
				else {
					options.el = el;	
				}
			}

			var attributeAccessor = (el instanceof jQuery) ? 'attr' : 'getAttribute';
			var templateFalse = (options.config  && options.config.template === false);
			if (!templateFalse) {
				templateFalse = el[attributeAccessor]('data-template');
				if (templateFalse && templateFalse === 'false') {
					templateFalse = true;
				}
			}
			return templateFalse;
		},

		getParent: function() {
            return this.___parent;
        },

        /**
         * Initialize the viewModel. Can be override when creating a Widget/View that create the viewModel based on different configuration.
         * @param options
         * @private
         */
        _initViewModel: function(options) {
            // Add viewModel as direct property of view
            this.viewModel = options.viewModel || this.viewModel;
            if(!this.viewModel){
                throw new Error("viewModel property is required.");
            }
        },

		/**
		* Configuring the View's template from the el instead of the default template
		**/
		_configureTemplateFromHTML : function(options) {
			options.config = options.config || {};
			options.config.insertMethod = 'replace';
			options.insertMethod = 'replace';
			var el = (options.config.el  ? options.config.el : options.el) ;

			// secondary templates are only supported by CollectionView
			var secondary = el.find('[data-uxf-secondary-template]');
			if (secondary.length > 0) {
				var secTemplate = secondary[0].outerHTML;
				options.config.viewOptions = options.config.viewOptions ? options.config.viewOptions : {} ;
				
				if (options.config.viewOptions.config) {
					options.config.viewOptions.config.template = secTemplate;
						
				} else {
					options.config.viewOptions.config = {'template' : secTemplate };
				}
				
				el.empty();
			}
			if (options.___processUnderscore === false || options.config.processUnderscore === false) {
				options.config.template = el[0].outerHTML;
			} else {
				options.config.template = _.unescape(el[0].outerHTML);	
			}
			
		},

		/**
		 * helper method to get the view model data by key.
		 */
		_getVMData : function(key) {
			var vmKey = this.vmKeys[key], normalizedVmKey = vmKey;
			var result, data;

			if (!vmKey) {
				normalizedVmKey = key;
			}			

			if(!this.viewModel.observe) {
				result = this.viewModel.get(normalizedVmKey);				
			} else {
				result = this.viewModel.getValueByPath(normalizedVmKey);	
			}

			return result;
		},
		
		/**
		 * helper method to set the view model data by key.
		 */
		_setVMData : function(key, val) {
			var vmKey = this.vmKeys[key], normalizedVmKey = vmKey;

			if (!vmKey) {
				normalizedVmKey = key;
			}			

			if(!this.viewModel.observe) {
				this.viewModel.set(normalizedVmKey, val);				
			} else {
				this.viewModel.setValueByPath(normalizedVmKey, val, true);
			}
		},
		
		/**
		 * Delegates an action to its viewModel. If action is not mapped in vmKeys then action is used.
		 */
		delegateVmAction : function( action, params) {
			var vmKeyValue = this.vmKeys['action.' + action];
			if (vmKeyValue) {
				this.viewModel.handleAction.apply( this.viewModel, _.union([vmKeyValue], _.rest(arguments)));				
			} else {
				this.viewModel.handleAction.apply( this.viewModel, arguments);
			}
		},
		
		/**
		 * helper method to get the view model config by key.
		 */
		_getVMConfig : function(key) {
			var vmKey = this.vmKeys[key];
			if (vmKey) {
				return this.viewModel.getConfig(vmKey);				
			} else {
				return this.viewModel.getConfig(key);
			}
		},


		_bindEvents: function() {
			if (this.getConfig('autoRefresh')) {
				this.viewModel.on('change', this.onChange, this);
			}
			this.viewModel.on('change:config:visible', this.onVisibleChange, this);
			this.viewModel.on('change:config:enabled', this.onEnableChange, this);
			// binding events for changes on mapped entries
			for (var name in this.vmKeysChangeEvents) {
				var functionName = this.vmKeysChangeEvents[name];
				var viewFunction = this[functionName];
				if (viewFunction && _.isFunction(viewFunction)) {
					this.viewModel.on("change:"+this.vmKeys[name], viewFunction , this);   					
				}
			}
		},

		constructor: function() {
			//keep current events as temp and clear from view - backbone delegateEvents will have no events
			var options = arguments[0] || {};
			this._preConstructor(options);
			this._createOrigEvents(options);
			Backbone.View.apply(this, arguments);
			this._postConstructor(options);
		},
		
		// Copy all events to temporary object and clear events before backbone apply
		// done due to memory leak in case of events assignment at the time of View creation
		_createOrigEvents : function(options) {      				
			var config = options.config || {};			
			this.origEvents = _.extend({},this.events, config.events);
			config.events = null;
			this.events = null;
		},
		/**
		 * This is a pre-constructor function.
		 * This function is also a hook for any further actions that need to be taken care of,
		 * or to override the functionality mentioned above.
		 */
		_preConstructor: function() {
			return;
		},
		/**
		 * This is a post constructor function. In the View level it handles the <code>auto-render</code>
		 * property as defined in it's view-model object. If <code>auto-render</code> is true it will
		 * call to <code>this.render()</code> function and will render the DOM.
		 * This function is also a hook for any further actions that need to be taken care of,
		 * or to override the functionality mentioned above.
		 */
		_postConstructor: function() {
			// if autoRender == true, calls render()
			if(this.getConfig("autoRender")) {
				this.render();
			}
		},

		render: function() {
			this.augmentViewModel(); // hook
			this.preRender(); // hook
			this._buildRoot(); // includes template handling
			this._processRbaConfig();
			this.binding.bindDOM(this); // bind declarative DOM
			this._handleSubViews(); // inserts subViews into DOM
            this._applyDataBindings();
			this._handleDelegateEvents(); //bind original events
			this.enhanceMarkup(); // hook
			this.postRender(); // hook
			this._processTemplateViews();
			return this;
		},

		// Restore events from temporary object create in constructor and merge with current events
		// if exist
		_handleDelegateEvents:function () {       
			this.events = _.extend({}, this.origEvents, this.events);
			delete this.origEvents;
			this.delegateEvents();
		},

		addViewModel: function(events, callback, viewModel) {
            this.viewModels = this.viewModels || [];
            this.viewModels.push(viewModel);
        },
		
        /**
        > **Note** that it is **developer's** responsibility to actually **call** `destroy` method.
        > 
        > **It is not called automatically!**

        Cleans up and removes the *View* by:

        1. ubind all data bindings
        2. unsubscribing from all *ViewModel* events
        3. removing any Knockout bindings from the `this.root` element
        4. calling enhanced *Backbone View's* `remove` method
        5. unsubscribing from any self-listening events
        6. removing *Sub-Views* and calling their `destroy` methods
        7. removing *Inline Views* (create via `data-uxf-view` attribute) and calling their `destroy` methods

        @method destroy
        **/
		destroy : function(clearVM) {
			this.selfDestroy(clearVM);
			if(this.subViews) {
                for(var i in this.subViews) {
                    this.subViews[i].viewInstance && this.subViews[i].viewInstance.destroy();
                    delete this.subViews[i].viewInstance;
                    delete this.subViews[i];
                }
            }
            if(this._subViews) {
                for(var i in this._subViews) {
                    this._subViews[i].instance && this._subViews[i].instance.destroy();
                    delete this._subViews[i].instance;
                    delete this._subViews[i];
                }
            }

            if(this.___children) {
                for (var i = this.___children.length - 1; i >= 0; i--) {
                    if(this.___children[i]) {
                        this.___children[i].destroy();
                        delete this.___children[i];
                    }
                };

                delete(this.___children);
            }

            if(this.viewModels) {
                for (var i = this.viewModels.length - 1; i >= 0; i--) {
                    if(this.viewModels[i]) {
                        this.viewModels[i].off(null, null, this);
                        delete this.viewModels[i];
                    }
                };
            }
		},

		selfDestroy: function(clearVM) {
            this.binding.unbind();
            
            if (clearVM)
                Backbone.Events.off.call( this.viewModel, null, null, this);
            else
                this.viewModel.off(null, null, this);
            if(this.root && this.viewModel.observe) {
                KO.cleanNode(this.root);
            }

            if(this.placeholders) {
            	this.placeholders = null;
            }

            this.remove();            	
            this.off();
            this.undelegateEvents();            
            this.__parent = null;        
        },

		delegateEvents: function(events) {
            if (!(events || (events = _.result(this, 'events')))) {
                return Backbone.View.prototype.delegateEvents.apply(this, arguments);
            }

            for (var key in events) {
                var method = events[key];
                if (!_.isFunction(method)) {                    
                    if(/action\.\b/.test(method)) {
                        method = method.split('.')[1];
                        events[key] = this._augmentSingleEvent(events, key, method);
                    } else {
                        method = this[events[key]];
                    }
                }
                if (!method) {
                    continue;
                }
            }
            
            return Backbone.View.prototype.delegateEvents.apply(this, arguments);
        },

        _augmentSingleEvent: function(events, key, method) {
            return function() {      
                this.delegateVmAction(method);
            };
        },

		remove: function() {
			var saved = this.$el;
			this.$el = this.$root? this.$root: this.$el;
			Backbone.View.prototype.remove.call(this);
			this.$el = saved;
			return this;
	    },

		_buildRoot: function() {
			var $inline = this.$('>[type="template/html"]');
			if(!this.templateAttr) {
				var self = this;
				$inline.each(function(index, element) {
					var $element = $(element);
					var templateName = $element.data('uxf-template');
					
					if(templateName === undefined || templateName === 'template') {
						self.template = $element.html() || self[templateName];
					}
					else {
						if(self[templateName] && (typeof self[templateName] === 'function')) {
							self[templateName] = _.template($element.html()) || self[templateName];
						}
						else if(self[templateName] && (typeof self[templateName] === 'string')) {
							self[templateName] = $element.html() || self[templateName];
						}
					}
					
					$element.remove();
				});
			}
			
			if(this.template) {
				this._handleTemplate();
			}
			else {
				this._createRootMarkup();
			}
		},

        _applyDataBindings: function() {
            var $parent, $root, $placeholder;
            if(this.root && this.viewModel.observe && !this.getConfig('cancelBinding')) {
                KO.cleanNode(this.root);
                var bindingContext = this.viewModel.options.bindingContext;
                var context = this._createContext(bindingContext);
                
                if(bindingContext) {
                	KO.applyBindingsToDescendants(context, this.el);
                } else {
                    $parent = this.$root.parent();
                    $root = this.$root;
                    $placeholder = $('<div></div>').insertBefore($root);
                    $root.detach();
                	KO.applyBindings(context, this.root);
                    $placeholder.replaceWith($root);					
                }
                this._cleanContextArtifacts(context);
            }      
        },
        
        _handleInlineView: function(element, viewProps, context, bindingContext) {
            var scope = this.getConfig('scope') || this.scope;
            var Component = Utils.getValueByPath(scope, viewProps.name);
            var viewModel = this._createVMForInlineView(context, bindingContext, viewProps);
            var config, component;
            this._connectViewModels(viewModel);

	        // Support KO virtual elements as well as regular ones
            if(element.nodeName === '#comment') {
            	config = _.extend({
	                viewModel: viewModel
            	}, viewProps);
	            //component = this.create(viewProps.id, Component, config);
	            component = this.create(viewProps.id, Component, {
	            	viewModel: viewModel,
	            	config: config
	            });
	            KO.virtualElements.prepend(element, component.root);
            } else {
            	config = _.extend({
            		el: element,
	                viewModel: viewModel
            	}, viewProps);
            	// this.create(viewProps.id, Component, config);
            	this.create(viewProps.id, Component, {
            		el: element,
            		viewModel: viewModel,
            		config: config
            	});
            }
		},
		_handleInlineWidgets: function(element, viewProps, context, bindingContext) {
			// Empty by design. No inline widgets in Views.
			return;
		},
		_createVMForInlineView: function(context, bindingContext, viewProps) {
            var viewModel = this.viewModel;
            if (viewProps.initVM) {
            var ParentViewModel = this.viewModel.constructor;

            var viewModel = new ParentViewModel({
                data: context,
                bindingContext: bindingContext
            });
            }

			return viewModel;
		},
		_connectViewModels: function(viewModel) {
            // TODO: limit to only "old" UXF views
            this.viewModel.on('all', function(name, data) {
            	viewModel.trigger(name, data);
            });


		},

        _createContext: function(observable) {

            var Context = this._getKnockoutContext(observable);
            var viewHandler = _.bind(this._handleInlineView, this);
            var widgetHandler = _.bind(this._handleInlineWidgets, this);
            viewHandler.view = this;
            widgetHandler.view = this;
           	Context.prototype = this._createContextPrototype(observable);

            var context = new Context(this.vmKeys, viewHandler, widgetHandler);
            return context;
        },

        _getKnockoutContext: function(observable){
            var clickHandler = _.bind(this._clickHandler, this);
            var rbaHandler = _.bind(this._rbaHandler, this);

            var getResourceBundle = _.bind(this.getResourceBundle, this);
            var _handleVMKeyForContext = this._handleVMKeyForContext;

            var viewModelData = this._getViewModelData();
            var _data = _.extend({}, viewModelData, {});
            var contextObject = {
                bindContext: _.extend(this.getBindContext(), {
                    getVMData: function( key ) {
                        if (KO.isObservable(key))
                            return key();
                        return key;                        
                    }
                })
            };
            var formatter = _.bind(Formatter.formatCurrentBindingContext, _.extend({}, Formatter, contextObject));
            var avoidNamingConflict = _.bind(Utils.KO.getCustomExtendedContextObservable, this);
            var i18n = _.bind(function(msg, args){
                var resourceBundle = getResourceBundle();
                if(resourceBundle) {
                    msg = resourceBundle.getString(msg, args);
                }
                if(_.isUndefined(msg) || _.isNull(msg)) {
                    msg = '';
                }
                return msg;
            },this);
            
            var unboundViewInvoke = function(toInvoke) {
            		var parameters = Array.prototype.slice.call(arguments, 1);
            		var retVal;
            		
            		if(this[toInvoke]) {
            			retVal = this[toInvoke].apply(this, parameters);
            		}
            		
            		return retVal;
            	};

            var viewInvoke = _.bind(unboundViewInvoke, this);

            var viewContextHandler = _.bind(function(){return this;}, this);
            var Context = function(vmKeys, viewHandler, widgetHandler) {
                this.__viewContextHandler__ = viewContextHandler;
                this.__viewhandler__ = viewHandler;
                this.__widgethandler__ = widgetHandler;
                this.__rbaHandler__ = rbaHandler;
                this.__clickhandler__ = clickHandler;
                this.__vmKeys__ = vmKeys;
                this.__getResourceBundle__ = getResourceBundle;
                this.__getFormatter__ = formatter;
                this.format = avoidNamingConflict(this.format, formatter);
                this.viewInvoke = avoidNamingConflict(this.viewInvoke, viewInvoke,1);
                _.each(vmKeys, _handleVMKeyForContext, this);
                this.i18n = avoidNamingConflict(this.i18n, i18n);
            };

            Context.prototype = this._createContextPrototype(observable);

            return Context;
        },

        _createContextPrototype: function(observable) {
        	var context = observable;
        	var path = this.getConfig('vmPath');
        	var adjustedContext;

        	if(!observable) {
        		context = this.viewModel.get(true);   
        	}

        	if(path) {
        		adjustedContext = this.viewModel.getValueByPath(path, true);
        		adjustedContext['$root'] = context;
        		context = adjustedContext;
        	}

        	return context;
        },        

        /*_applyDataBindings: function() {
            var bindingContext = this.viewModel.__bindingContext__;
            var context, vmPath;

            if(this.root && this.viewModel.observe) {
            	KO.cleanNode(this.root);
            	vmPath = this.getConfig('vmPath');

            	if(!bindingContext) {
	            	bindingContext = this.viewModel.get(true);
	            	context = this.viewModel.getValueByPath(vmPath, true);

	            	bindingContext = new KO.bindingContext(bindingContext);
	            	bindingContext.$root = this._extendContext(bindingContext.$root);
	            	context = bindingContext.createChildContext(bindingContext.$rawData);
            	} else {
            		context = bindingContext;
            		context = this._extendContext(context);
            	}

            	KO.applyBindings(context, this.root);
            	this._cleanContextArtifacts(context);
            }   
        },

		_handleInlineView: function(element, viewProps, context, bindingContext) {
	       	var scope = this.getConfig('scope') || this.scope;
        	var Component = Utils.getValueByPath(scope, viewProps.name);
        	
        	var viewModel = new ObservableViewModel({
                data: context,
                bindingContext: bindingContext
            });

            this.viewModel.on('all', function(name, data) {
            	viewModel.trigger(name, data);
            });

            if(element.nodeName === '#comment') {
	            var component = this.create(viewProps.id, Component, {
	                viewModel: viewModel
	            });

	            KO.virtualElements.prepend(element, component.root);
            } else {
            	this.create(viewProps.id, Component, {
            		el: element,
	                viewModel: viewModel
	            });
            }
		},

		_extendContext: function(context) {
        	var extendedContext = KO.utils.extend(context, {
    			__viewhandler__: _.bind(this._handleInlineView, this),
    			__clickhandler__: _.bind(this._clickHandler, this),
    		    __vmKeys__: this.vmKeys,
    		    __getResourceBundle__: _.bind(this.getResourceBundle, this)
        	});

        	_.each(this.vmKeys, this._handleVMKeyForContext, extendedContext);

        	return extendedContext;
        },*/

        _handleVMKeyForContext: function(path, key) {
            var keyParts = key.split('.');
            var observableProp;
            path = KO.unwrap(path);
            if(keyParts && keyParts.length > 1 && keyParts[0] === 'data') {
            	observableProp = Utils.getValueByPath(this, path, true);
                if (observableProp) {
                    this[keyParts[1]] = KO.computed({
                    	read: function() {
	                        return KO.unwrap(observableProp);
	                    },
	                    write: function(value) {
	                    	observableProp(value);
	                    },
	                    deferEvaluation: true
                    });
                }
            }
        },  

        _cleanContextArtifacts: function(context) {
            delete context.__vmKeys__;
        },

        _clickHandler: function(method, element, data, context, bindingContext, event) {
            var args;
            if(typeof(method) === 'object'){
                args = method.args;
                method = method.method;
            }
            if (typeof(method) === 'function'){
                method.call(this,element, data, context, bindingContext, event, args);
            }
            else {
                this[method](element, data, context, bindingContext, event, args);
            }
        },

        _rbaHandler: function(element, data, context, bindingContext) {
        	this.placeholders = this.placeholders || {};

        	if(data && data.id) {
        		this.placeholders[data.id] = {
        			el: element,
        			context: context,
        			bindingContext: bindingContext
        		};      		
        	}
        },

        _handleRBAData: function(rbaData) {
        	_.each(rbaData, this._loadRBAViewAndViewModel, this);		
        },

        _loadRBAViewAndViewModel: function(data, placeholder) { 
        	var rba = this.getConfig('rba') || {}; // may include various settings for DynamicView/DynamicViewModel       	
        	var context = this;

        	var view = rba.view || 'src/ui/dynamic/DynamicView';
        	var viewModel = rba.viewModel || 'src/ui/dynamic/DynamicViewModel';

        	if(typeof view === 'string' && typeof viewModel === 'string') {
	        	requirejs([view, viewModel], function(RBAView, RBAViewModel) {
	        		context._createRBA(RBAView, RBAViewModel, data, placeholder);
	        	});
        	} else if(typeof view === 'string' && typeof viewModel === 'function') {
	        	requirejs([view], function(RBAView) {
	        		context._createRBA(RBAView, viewModel, data, placeholder);
	        	});
        	} else if(typeof view === 'function' && typeof viewModel === 'string') {
	        	requirejs([viewModel], function(RBAViewModel) {
	        		context._createRBA(view, RBAViewModel, data, placeholder);
	        	});
        	} else if(typeof view === 'function' && typeof viewModel === 'function') {
	        	context._createRBA(view, viewModel, data, placeholder);
        	}

        },

        _createRBA: function(RBAView, RBAViewModel, data, placeholder) {
        	var rba = this.getConfig('rba') || {}; // may include various settings for DynamicView/DynamicViewModel
        	var placeholderConfig = this.placeholders[placeholder];

    		var viewModel = this._createRBAViewModel(RBAViewModel, rba, placeholderConfig, placeholder);
    		this._createRBAView(RBAView, rba, placeholderConfig, viewModel, placeholder);
    		 
    		viewModel.load(data, {});
        },

        _createRBAViewModel: function(RBAViewModel, rba, placeholderConfig, placeholder) {
        	var viewModel = this.create(placeholder, RBAViewModel, {});

    		return viewModel;
        },

        _createRBAView: function(RBAView, rba, placeholderConfig, viewModel, placeholder) {        	
        	var configuratorConfig = _.pick(rba, 'configurator', 'builders', 'validators', 'resolvers', 'deps', 'validation', 'templates');

        	if(!_.isUndefined(configuratorConfig.configurator)) {
        		configuratorConfig = configuratorConfig.configurator;
        	} else {
        		configuratorConfig = _.extend({}, configuratorConfig);        		
        	}

        	var templateScope =  this.getConfig('scope') || this.scope;

        	var view = this.create(placeholder, RBAView, {
        	    el: $(placeholderConfig.el),
        	    viewModel: viewModel, 
        	    config: {
        	    	configurator: configuratorConfig,
        	    	scope: templateScope
        	    }
        	}); 

        	return view;
        },

		_handleSubViews: function() {
			this.root && this.subViews && this.addSubView(this.subViews);
			this.trigger('subviews:added');
		},

		/**
		 * Adds the given sub-view object to the current view.
		 * @methodOf Lightsaber.Core.View#
		 * @name addSubViews
		 * @param {Object|Array} subViewDetails
		 * an object represents configuration of a sub-view, or an array of such.
		 * @param {Object} subViewDetails.viewInstance
		 * an instance of a view.
		 * @param {String} [subViewDetails.el=undefined]
		 * a selector that specifies the position of the view inside the template or HTML.
		 * @param {String} [subViewDetails.insertMethod=undefined]
		 * a directive on how to insert the sub-view when given an 'el' placeholder.
		 * Can get either "append", "prepend" or "replace".
		 */
		addSubView: function(subViewDetails/*viewInstance, el, insertMethod*/) {
			if (subViewDetails) {
				if (_.isArray(subViewDetails)) {
					_.each(subViewDetails, function(subViewDetails) {
						this.addSubView(subViewDetails)
					}, this);
					return;
				}
				if (this.root) {
					var subViewInstance = subViewDetails.viewInstance;
					if (subViewInstance) {
						//DOM insertion options. By default, behave according to instance's el existence.
						var insertMethod =
							subViewDetails.insertMethod || (subViewInstance._isElProvided ? "replace" : "append");
						var subViewEl = subViewDetails.el;
						if (subViewEl) {
							var $foundEl;
							if (($foundEl = this.$(subViewEl)).length > 0) {
								this._insertElement(insertMethod, $foundEl, subViewInstance.$el);
							}
							else {
								subViewEl = null;
							}
						}
						if (!subViewEl) {
							this._insertSubView(subViewInstance);
						}
						subViewInstance.enhanceMarkup();
						this._subViews[subViewInstance.cid] = {
							el: subViewEl,
							insertMethod: insertMethod,
							instance: subViewInstance
						};
					}
					// viewType feature - shelved
					else if (subViewDetails.viewType || subViewDetails.viewOptions) {
						throw new Error("'viewType' + 'viewOptions' is no longer supported. Must pass 'viewInstance'");
					}
				}
				else { // View has not been rendered yet
					// pushing this subView configuration into the subViews array
					this.subViews.push(subViewDetails);
				}
			}
		},

		_handleTemplate: function(refresh) {
			var data = this._createTemplateData();
			var filledTemplate = this.getPopulatedTemplate(this.template, data);
			this.placeRoot(filledTemplate, refresh? true : false);
			this._normalizeRootDomEl();
		},

		_normalizeRootDomEl: function() {
			this.$root.find('[data-ls-bind]').each(function() {
				$(this).attr('data-ls-bind', $(this).attr('data-ls-bind').replace(/\s/g,''));
			});
		},

        /**
        Allows injection of static data into the context that is used to render main *View* template.

        Intended to be overridden by extending classes.

        @method _createTemplateData
        @protected
        @return {Object} object (`{}` by default) to be injected into the context
        **/
		_createTemplateData : function() {
			return {};
		},
		
		/**
		 * Populate template with provided data and viewModel's data.
		 * @methodOf Lightsaber.Core.View#
		 * @name getPopulatedTemplate
		 * @param {String|Function} template
		 * a template, can be a string or a template compiled in advance (preferred for efficiency reasons)
		 * @param {Object} [data={}]
		 * data will be used to populate the temlate
		 * @param {Boolean|Lightsaber.ViewModel} [viewModel=true]
		 * use data of default ViewModel. When false ViewModel data will not be used. When another ViewModel is
		 * specified it will be used instead of default one.
		 */
        getPopulatedTemplate: function(template, data, viewModel) {
            if(typeof template === 'string') {
                template = _.template(template);
            }
            var templateData = this.getTemplateData(data, viewModel);
        	var templateStr = template(templateData);
            return templateStr;
        },

        /**
		 * get the JSON object with the data for the template. this is the input data combined with the
		 * viewmodel data and the mapping for the specific view.
		 * mapping and default values will be set according to the configuration of the view
		 * 
		 * @methodOf Lightsaber.Core.View#
		 * @name getTemplateData
		 * @param {Object} [data={}]
		 * data will be used to populate the temlate
		 * @param {Boolean|Lightsaber.ViewModel} [viewModel=true]
		 * use data of default ViewModel. When false ViewModel data will not be used. When another ViewModel is
		 * specified it will be used instead of default one.
         */
        getTemplateData: function(data, viewModel) {
           if (_.isBoolean(data) || data instanceof ViewModel) {
            	viewModel = data;
            	data = {};
            }
            else if(data === undefined) {
            	data = {};
            }

            var viewModelData = this._getViewModelData(viewModel);
            var _data = _.extend({}, viewModelData, data);

            var contextObject = {
            	bindContext: _.extend(this.getBindContext(), {
            		getVMData: function( key ) {
            			return Utils.getValueByPath(_data, key);
            		}
            	})
            };

            return _.extend(_data, {'i18n': this._getLocaleString, 'format' : _.bind(Formatter.formatCurrentBindingContext, _.extend({}, Formatter, contextObject) )});
        },

        _getViewModelData : function(viewModel) {
            // TODO: add to template view's data once framework supports it
            // fills data & i18n
            var viewModelData;
            if (_.isUndefined(viewModel) || viewModel === true) { // by default use current ViewModel
                viewModelData = this.viewModel.get();
            } else if (viewModel === false) { // if third argument is false don't use any ViewModel
                viewModelData = {};
            } else { // if ViwModel is specified - use it
                viewModelData = viewModel.get();
            }

            var path = this.getConfig('vmPath');

            if(path) {
                viewModelData = Utils.getValueByPath(viewModelData, path);
            }
            // we will now call the mapping and add this on top of the viewmodel data
            var value, defaultValue, mappedName = null;
            for (var name in this.vmKeys) {
                if (name.substring(0,5) == "data.") {
                    mappedName = this.vmKeys[name];
                    // adding mapping in case we have a different field (we will not do this for standard fields from the config)
                    if (name != "data." + mappedName ) {
                        // adding the mapped data on the same field as the name would have been if not mapped
                        viewModelData[name.substring(5)] = this._getVMData(name);
                    }
                    // checking for default values for null fields
                    if (viewModelData[mappedName] == null) {
                        if ((defaultValue = this.getConfig(name)) != null) {
                            viewModelData[mappedName] = defaultValue;
                        }

                    }
                }
            }
            return viewModelData;
        },
       
       _processTemplateViews : function() {
        	if (!this.$root.data('uxf-processed')){
        		var templateScope =  this.getConfig('scope') || this.scope;
        		var attrView = this.$root.data('uxf-view');
        		if(!attrView) {
        			this.$root.find('[data-uxf-view]').each(_.bind(this._processTemplateView, this, templateScope));
        		}
        		else {
        			this._processTemplateView(templateScope, 0, this.$root);
        		}	
        	}	
        },

        _processTemplateView : function(templateScope, index, templateView) {
        	var $viewElement = $(templateView);
        	var processed = $viewElement.data('uxf-processed');
        	if(processed != true) {
        		$viewElement.attr('data-uxf-processed', 'true');
        		var viewName = $viewElement.data('uxf-view');
            	
            	var config = this._getConfigForTemplateView($viewElement);	
        		var viewModel = this._getViewModelForTemplateView($viewElement, config, templateScope);	
				var vmKeys = this._getVmKeysForTemplateView($viewElement);
        		var View = this._getPath(templateScope, viewName);
        		var uxf_view_id = $viewElement.data('uxf-view-id');
        		if(!uxf_view_id){
        			uxf_view_id = this.INNER_VIEW_ID_PREFIX + index;
        		}
        		config.scope = $.extend({}, this.scope, config.scope, this.getConfig('scope'));
        		this.create(uxf_view_id,View,{
        			config : config,
        			viewModel : viewModel,
					vmKeys : vmKeys
        		});
        	}        	
        },
        
        _getConfigForTemplateView : function($viewElement) {
        	var configName = $viewElement.data('uxf-config');
        	var config;
        	if(typeof configName === 'object') {
        		config = configName;
        	}
        	else if(configName && configName.indexOf('\{') >= 0) {
        		config = eval("(" + configName + ")") || {};
        	}
        	else if(configName){
        		config = this.getConfig(configName);      		
        	}
        	
        	if(!config) {
    			var script = $viewElement.find('>[type="config/json"]');
        		if(script && script.length === 1) {
        			config = eval("(" + script.html() + ")");
        		}
        		else {
        			config = {};
        		}
        		script.remove();
    		}  
        	
        	if(!config) {
    			config = {};
    		}  
        	        	
    		config.el = $viewElement;    		
    		return config;
        },
        
        _getViewModelForTemplateView : function($viewElement, config, templateScope) {
        	var viewModel;
    		var viewModelName = config.viewModel || $viewElement.data('uxf-viewmodel');
    		if(viewModelName && (typeof viewModelName !== 'string')) {
    			viewModel = config.viewModel;
    		}
    		else {
    			if ( templateScope && templateScope[viewModelName] ) { // looks for view model instance in scope
    				viewModel = templateScope[viewModelName];
    			} else if ( viewModelName && this.getConfig(viewModelName) && !_.isString(this.getConfig(viewModelName))) { //looks for instance in the view config
    				viewModel = this.getConfig(viewModelName)
    			} else if ( viewModelName && this.getConfig(viewModelName) && this.viewModel.getSubViewModel(this.getConfig(viewModelName)) ) { // looks for sub view model with the configured view model name in the view
    				viewModel = this.viewModel.getSubViewModel(this.getConfig(viewModelName));
    			} else if ( this.viewModel.getSubViewModel(viewModelName) ) { // looks for sub view model with that name
    				viewModel = this.viewModel.getSubViewModel(viewModelName);
    			} else { // assign the parent view model as view model
    				viewModel = this.viewModel;
    			}
    		}
    		
    		return viewModel;
        },

		_getVmKeysForTemplateView : function($viewElement) {
        	var vmKeysStr = $viewElement.data('uxf-vmkeys');
        	var vmKeys;
        	if(vmKeysStr && vmKeysStr.indexOf('\{') >= 0) {
        		vmKeys = eval("(" + vmKeysStr + ")") || {};
        	} 
    		return vmKeys;
        },
        
        _getPath : function(object, path) {
        	var pathElements = path.split('\.');
        	for(var i = 0; i < pathElements.length; i++) {
        		object = object[pathElements[i]];
        	}
        	return object;
        },

		getResourceBundle: function() {
			// currently i18n resource bundle reference is kept in ViewModel.
			// Change if decided to bring it to View			
			var rb = this.getConfig('resourceBundle') || this.viewModel.getConfig('resourceBundle');
			//if (!rb) throw new Error("resourceBundle is missing for i18n template parsing");
			return rb;
		},

		_getLocaleString: function(key, args) {
			return this.getResourceBundle().getString(key, args);
		},

			

		_createRootMarkup: function() {
			this._elInnerHtml = this.$el.html();
			this.placeRoot(this._getNewRootElem());
			this._elInnerHtml && this.$root.append(this._elInnerHtml);
		},

		_getNewRootElem: function() {
	        var el = document.createElement( this.getConfig('tagName') || 'div' );
			return el;
		},

        /**
        Refreshes (by calling to all relevant methods from `render` - *View's* lifecycle) the *View*.
        **/
		_refresh: function() {
			if (this.root) {
				if (this.template) {
					this._handleTemplate("refresh");
					this.binding.bindDOM(this); // bind declarative DOM
					this._injectSubViews();
					this.enhanceMarkup();
				}
			}
			else {
				this.render();
			}
		},

		_injectSubViews: function() {
			var subView;
			for (var cid in this._subViews) {
				subView = this._subViews[cid];
				if (subView.el) {
					this._insertElement(subView.insertMethod, this.$(subView.el), subView.instance.$el);
				} else {
					this._insertSubView(subView.instance);
				}
			}
		},

		_insertSubView: function(subViewInstance) {
			this.$root.append(subViewInstance.el);
		},

		_insertElement: function(insertMethod, $placeholderEl, $insertedEl) {
			!($placeholderEl instanceof $) && ($placeholderEl = $($placeholderEl)); //ensures it's a jQuery object
			!($insertedEl instanceof $) && ($insertedEl = $($insertedEl)); //ensures it's a jQuery object
			switch (insertMethod) {
				case "append":
					$placeholderEl.append($insertedEl);
					break;
				case "prepend":
					$placeholderEl.prepend($insertedEl);
					break;
				case "replace":
					if($placeholderEl && $placeholderEl.get(0) && (this.getConfig('copyAttributes') !== false)) {
						var attributes = _.clone($placeholderEl.get(0).attributes);
						var i = attributes.length;
						var clazz = $insertedEl.attr('class');
						while(i--) {
							if(attributes[i].name === 'class') {
								if(clazz && !$placeholderEl.hasClass(clazz)) {
									attributes[i].value += ' ' + clazz;
								}
							}
							$insertedEl.attr(attributes[i].name, attributes[i].value);
						}	
					}
					$placeholderEl.replaceWith($insertedEl);
					break;
				case "html":
					$placeholderEl.html($insertedEl);
			}
		},

		/**
		No-op.
		`postRender` is part of *View* lifecycle and may be overridden 
		by extending classes.
        @method postRender
        @protected
        **/
		postRender: function() { this._postRender(); },
		/**
		@deprecated
        @private
        **/
		_postRender: function() {}, // deprecated, postRender should be used

		/**
        @method enhanceMarkup
        @protected
        **/
		enhanceMarkup : function() { this._enhanceMarkup(); },
		/**
		No-op.
		`_enhanceMarkup` is part of *View* lifecycle and may be overridden 
		by extending classes.
		@deprecated 9.3.0
        @method _enhanceMarkup
        @protected
        **/
		_enhanceMarkup : function() {}, // deprecated, enhanceMarkup should be used

		/**
		No-op.
		`preRender` is part of *View* lifecycle and may be overridden 
		by extending classes.
        @method preRender
        @protected
        **/
		preRender: function() { this._preRender(); },
		/**
		No-op.
		`augmentViewModel` is part of *View* lifecycle and may be overridden 
		by extending classes.
        @method augmentViewModel
        @protected
        **/
		augmentViewModel: function() {},
		/**
		@deprecated
        @private
        **/
		_preRender: function() {}, // deprecated, preRender should be used

		/**
		 * Getter or setter for DOM attributes of root element.
		 * @methodOf Lightsaber.Core.View#
		 * @name attr
		 * @param {String} key The name of the attribute to get or set.
		 * @param {String} value A value to set for the attribute.
		 * @returns {View} The View object.
		 * @example
		 *     // set attribute value
		 *     view.attr('data-role', 'listview');
		 *     // set several attributes values
		 *     view.attr({
		 *       'data-corners': false,
		 *       'data-icon': 'home'
		 *     });
		 *     // get attribute value
		 *     var icon = view.attr('data-icon');
		 *     // get all attributes
		 *     var attrs = view.attr();
		 */
		attr: function(key, value /*, options*/) {
			// determine type of arguments
			if (arguments.length === 0) {
				// get all attributes
				return _.clone(this.attributes);
			} else if (_.isString(key)) {
				// getter
				if (arguments.length === 1)
					return this.attributes[key];
				// setter
				this.attributes[key] = value;
				this.$root && this.$root.attr(key, value);
			} else {
				// key is an object with key-value pairs
				_.extend(this.attributes, key);
				this.$root && this.$root.attr(key);
			}
			return this;
		},


		/**
		 * Sets the configuration value of a given attribute.
		 * @methodOf Lightsaber.Core.View#
		 * @name setConfig
		 * @param {String} key The key that represents the property name.
		 * @param {String} value The value to be assigned with the given key
		 * @param {Object} [options] options.suppressSetters If set to <code>true</code>,
		 * @returns {String} The configuration value
		 */
        /**
        Returns the value of a configuration property defined by `key`.

        @method setConfig
        @param {String} key key that represents the property
        @param {String} value the value to be assigned to the configuration property
        @param {Object} [options] `options.suppressSetters` If set to `true`
        **/
		setConfig: function(key, value, options) {
			// do nothing if already called
			if (this._setConfigGuard) return this;

			var attrs;
			if (_.isObject(key) || key == null) {
				attrs = key;
				options = value;
			} else {
				attrs = {};
				attrs[key] = value;
			}

			// call specific setters when needed
			if (!(options && options.suppressSetters)) {
				this._setConfigGuard = true;
				if (attrs.template) attrs.template = this.setTemplate(attrs.template).template;
				if (attrs.root) attrs.root = this.setRoot(attrs.root).root;
				if (attrs.el) attrs.el = this.setElement(attrs.el).el;
				if (attrs.rootCSS) attrs.rootCSS = this.setRootCSS(attrs.rootCSS).rootCSS;
				if (attrs.id) this.setId(attrs.id);
				this._setConfigGuard = false;
			}

			this._config.set(attrs, options);
			return this;
		},

		/**
		Returns the value of a configuration property defined by `key`.

		@method getConfig
		@param {String} key key that represents the property
		@returns {...} configuration property value
		**/
		getConfig: function(key) {
			return arguments.length === 0 ? this._config.toJSON() : this._config.get(key);
		},

		/**
		 * Hook function that is called when View config is changed.
		 * Override it to
		 * @methodOf Lightsaber.Core.View#
		 * @name configChanged
		 * @param {Object} changed
		 *    Hash map of changed config properties. READONLY! (by efficiency reasons it is a reference to
		 *    internal object). If you need modifiable object use <code>changes = _.clone(changes);</code>
		 * @example
		 * WidgetView = Lightsaber.Core.View.extend({
		 *   // ...
		 *   configChanged: function(changed) {
		 *     if (_.has(changed, 'template')) {
		 *       this.refresh();
		 *     }
		 *   }
		 * });
		 */
		configChanged: function(changed) {},

		/**
		 * Sets the template to this view in runtime.
		 * @methodOf Lightsaber.Core.View#
		 * @name setTemplate
		 * @param {String|Function} template The template as string or a result of parsing
		 * it using Underscore.template(templateString) function.
		 * @returns {View} The View object
		 */
		setTemplate: function(template) {
			this.template = _.isFunction(template) ? template : _.template(template);
			this.templateAttr = true; // Note that template was passed as attribute
			this.setConfig({ template: this.template }, { suppressSetters: true });
			return this;
		},

		initTemplate: function(templateName) {
		    var template = this.getConfig(templateName);
		    if(!template) {
		        template = this[templateName];
		    }
		    if(typeof template === 'function') {
		        this[templateName] = template;
		    } else {
		        this[templateName] = _.template(template);
		    }
		},
		/**
		 * Replaces the view's element (<code>this.el</code> property) by given DOM element,
		 * including event re-delegation.
		 * @methodOf Lightsaber.Core.View#
		 * @name replaceElement
		 * @param {Object|String} element New DOM element or jQuery object or HTML string.
		 * @param {boolean} [delegate=true] Indicates whether to delegate events or not.
		 * @returns {View} The View object
		 */
		replaceElement: function(element, delegate) {
			
			var $element = $(element);
			if(this._isElProvided && this.$el && this.$el.get(0) && (this.getConfig('copyAttributes') !== false)) {
				var attributes = _.clone(this.$el.get(0).attributes);
				var i = attributes.length;
				var clazz = $element.attr('class');

				while(i--) {
					if(attributes[i].name === 'class') {
						if(clazz && !this.$el.hasClass(clazz)) {
							attributes[i].value += ' ' + clazz;
						}
					}

					$element.attr(attributes[i].name, attributes[i].value);
				}	
			}		
				
			return this._replaceElWithElement(element, delegate, $element);
		},
		_replaceElWithElement: function(element, delegate, $element) {
			this.$el.replaceWith($element);			
			return this.setElement(element, delegate);
		},
		
		/**
		 * This function applies a certain view or DOM element to a different DOM element,
		 * The function will also create the cached <code>$el</code> reference and move the
		 * view's delegated events from the old element to the new one.
		 * @methodOf Lightsaber.Core.View#
		 * @name setElement
		 * @param {Object|String} element New DOM element or jQuery object or HTML string.
		 * @param {boolean} [delegate=true] Indicates whether to delegate events or not.
		 * @returns {View} The View object
		 */
		setElement: function(element, delegate) {
			Backbone.View.prototype.setElement.apply(this, arguments);
			this.setConfig({ el: undefined }, { suppressSetters: true , silent: true});
			this.setConfig({ el: this.el }, { suppressSetters: true });
			return this;
		},

		/**
		 * Configures the root element with the input attributes, sets (<code>this.root</code> property) and associates the root with el.
		 * @methodOf Lightsaber.Core.View#
		 * @name placeRoot
		 * @param {Object|String} root New DOM element or jQuery object or HTML string.
		 * @param {boolean} [replace=false] Defines whether to replace the root in DOM or only set it in current view.
		 * @param {boolean} [applyAttributes=true] Defines whether to delegate HTML attributes.
		 * @returns {View} A reference to current View instance
		 */
		placeRoot: function(root, replace, applyAttributes) {
			this[replace === true ? "replaceRoot" : "setRoot"](root, applyAttributes);
			!replace && this._handleRootRelation();			
			return this;
		},

		/**
		 * Replaces the view's root (<code>this.root</code> property) by given root
		 * @methodOf Lightsaber.Core.View#
		 * @name replaceRoot
		 * @param {Object|String} root New DOM element or jQuery object or HTML string.
		 * @param {boolean} [applyAttributes=true] Defines whether to delegate HTML attributes.
		 * @returns {View} A reference to current View instance
		 */
		replaceRoot: function(root, applyAttributes) {
			root = $(root);
			if (this._isElProvided) {
				this.$root.replaceWith(root);
			} else {
				this.replaceElement(root);
			}
			return this.setRoot(root, applyAttributes);

		},

		/**
		 * This function sets the root of the View's DOM structure (<code>this.root</code>).
		 * And will apply the given attributes on the root's HTML mark-up.
		 * @methodOf Lightsaber.Core.View#
		 * @name setRoot
		 * @param {Object|String} root DOM element or jQuery object or HTML string.
		 * @param {boolean} [applyAttributes=true] Defines whether to delegate HTML attributes.
		 * @returns {View} The View object
		 */
		setRoot: function(root, applyAttributes) {
			var attrs = applyAttributes === false ? false : this.attr();
			var id = this.getConfig('id');
			var rootCSS = this.getConfig('rootCSS');
			root = this._enhanceRootMarkup(root);	
			if(typeof root === 'string'){
				root = root.replace(/(\r\n|\n|\r)/gm, "");
			}
			this.$root = $(root);
			attrs && this.$root.attr(attrs);
			attrs && rootCSS && this.$root.addClass(rootCSS);
			attrs && id && this.$root.attr({ id: id });
			this.root = this.$root[0];
			this._checkVisible();
			this._checkEnable();
			this.setConfig({ root: this.root }, { suppressSetters: true });
			return this;
		},
		_enhanceRootMarkup : function(root) {
			// Default implementation. Allows extending View's additional control over root's markup.
			return root;
		},

		_handleRootRelation: function() {
			if (this._isElProvided && this.insertMethod != "replace") {
				this._insertElement(this.insertMethod || "append", this.$el, this.$root);
			}
			else {
				this.replaceElement(this.root);
			}
		},

		/**
		 * Checks if view is initialized with <code>visible: false</code>
		 */
		_checkVisible: function() {
			if (this.viewModel.getConfig('visible') === false) {
				this.$root.hide();
			}
		},
		
		/**
		 * Checks if view is initialized with <code>enable: false</code>
		 */
		_checkEnable: function() {
			if(this.viewModel.getConfig('enabled') === false) {
				this.onEnableChange({value: false});
			}
		},
		
		/**
		 * Sets the root CSS class - root class per widget as a namespace.
		 * Changing the rootCSS will remove the previous rootCSS and replace it with
		 * the new rootCSS. There will always be the rootCSS on the top element.
		 * @methodOf Lightsaber.Core.View#
		 * @name setRootCSS
		 * @param {String} rootCSS The root CSS class name
		 * @returns {View} View The View object
		 */
		setRootCSS: function(rootCSS) {
			if (this.$root) {
				this.$root.removeClass(this.rootCSS);
				this.$root.addClass(rootCSS);
			}
			this.rootCSS = rootCSS;
			this.rootCSSPattern = new RegExp('\\b' + rootCSS + '\\b');
			this.setConfig({ rootCSS: rootCSS }, { suppressSetters: true });
			return this;
		},
		
		/**
		 * Sets the <code>id</code> attribute of <code>this.$root</code> of the View
		 * @methodOf Lightsaber.Core.View#
		 * @name setId
		 * @param {String} id The id to be set.
		 * @returns {View} The View object
		 */
		setId: function(id) {
			var attr = { id: id };
			if (this.$root) {
				this.$root.attr(attr);
			}
			this.setConfig(attr, { suppressSetters: true });
			return this;
		},
		
		/**
		 * Adds the specified class(es) to <code>this.$root</code> of the View.
		 * Note that this method does not replace a class. It simply adds the class, 
		 * appending it to any which may already be assigned to the element.
		 * In addition, more than one class may be added at a time, separated by a space, 
		 * to <code>this.$root</code>, for example:
		 * @example
		 * 		myCoolView.addClass("myClass yourClass");
		 * 
		 * @methodOf Lightsaber.Core.View#
		 * @name addClass
		 * @param {String} className The class name to be set.
		 * @returns {View} The View object
		 */
		addClass: function(className) {
            if (this.$root){
			 this.$root.addClass(className);
            }
			return this;
		},

		/**
		 * Remove a single class, multiple classes, or all classes from <code>this.$root</code> of the View.
		 * If a class name is included as a parameter, then only that class will be removed.
		 * If no class names are specified in the parameter, all classes will be removed.
		 * More than one class names may be removed at a time, separated by a space, from <code>this.$root</code>, for example:
		 * @example
		 * 		myCoolView.removeClass("myClass yourClass");
		 * 
		 * @methodOf Lightsaber.Core.View#
		 * @name removeClass
		 * @param {String} [className] One or more space-separated classes to be removed from the 
		 * class attribute of <code>this.$root</code>.
		 * @returns {View} The View object
		 */
		removeClass: function(className) {
			// it is not allowed to alter rootCSS class
			className = className.replace(this.rootCSSPattern, '');
            if (this.$root){
			 this.$root.removeClass(className);                
            }
			return this;
		},

		/**
		 * Add or remove one or more classes from <code>this.$root</code>, 
		 * depending on either the class's presence or the value of the switch argument.
		 * This function takes one or more class names as its parameter. 
		 * If <code>this.$root</code> already has the class, then it is removed.
		 * If <code>this.$root</code> does not have the class, then it is added.
		 * @methodOf Lightsaber.Core.View#
		 * @name toggleClass
		 * @param {String} className One or more class names (separated by spaces) to be toggled.
		 * @returns {View} The View object
		 */
		toggleClass: function(className) {
			// it is not allowed to alter rootCSS class
			className = className.replace(this.rootCSSPattern, '');
			this.$root.toggleClass(className);
			return this;
		},
		
		/**
		 * Determine whether <code>this.$root</code> is assigned the given class.
		 * @param {String} className The class name to search for.
		 * Elements may have more than one class assigned to them. In HTML, this is represented by separating the class names with a space
		 * @returns {boolean} true If the class is assigned to an element, even if other classes also are
		 * @example
		 * 		<div id="mydiv" class="foo bar"></div>
		 * 		boolean answer = myDivView.hasClass('foo'); 
		 * @methodOf Lightsaber.Core.View#
		 * @name hasClass
		 * @param {String} className 
		 */
		hasClass: function(className) {
			return this.$root.hasClass(className);
		},


		/**
		 * Handles the <code>change</code> event.
		 * By default, calls View's _refresh() method.
		 * @methodOf Lightsaber.Core.View#
		 * @name onChange
		 * @param {Object} [event] The event object.
		 */
		onChange: function (event) {
			this._refresh();
		},
		
		/**
		 * It handles the change of the <code>visible</code> property in the view-model.
		 * This function designed to be hooked by a derived class. 
		 * Current implementation toggles the display of <code>this.$root</code>.
		 * @methodOf Lightsaber.Core.View#
		 * @name onVisibleChange
		 * @param {Object} [event] The event object.
		 */
		onVisibleChange: function(event) {
			if (this.$root) {
				if (event.value === true) {
					this.$root.show();
				} 
				else {
					this.$root.hide();
				}
			}
		},

        /**
        No-op.

        Handles the change of the `enable` property of the *ViewModel*.

        Intended to be overridden by extending classes.

        @method onEnableChange
        @protected
        **/
		onEnableChange: function() {},
		
		/**
		 * Populates the view's place holders using the provided rbaData.
		 * @methodOf Lightsaber.Core.View#
		 * @name processRbaData
		 * @param {Object} rbaData      The provided data
		 * @param {Object} [rbaContext] The Rba context to use
		 */
		processRbaData: function( rbaData, rbaContext) {
			rbaContext = _.defaults( {}, rbaContext, this.options && this.options.config && this.options.config.rbaContext);

			var placeholders = this.$root.find('[data-uxf-rba]');

			if(placeholders.length > 0) {
	        	_.each( rbaData, function( value, ph) {
	        			var refs = {}, objs = {}, deps = [];
	        			
	        			// view
	        			var viewID = value.viewID || 'src/core/view/View';
	        			objs.view = this._getObject( viewID, rbaContext);
	        			if (!objs.view)
	        				deps.push( viewID );
	        			refs.viewConfig = this._getObject( 'refs.' + ph + '.viewConfig', rbaContext);
	        			
	        			// viewModel
	        			var viewModelID = value.viewModelID || 'src/core/viewModel/ViewModel';
						refs.viewModel = this._getObject( 'refs.' + ph + '.viewModel', rbaContext);
						if (!refs.viewModel) {
		        			objs.viewModel = this._getObject( viewModelID, rbaContext);						
		        			if (!objs.viewModel)
		        				deps.push( viewModelID );
						}
						refs.vmData = this._getObject( 'refs.' + ph + '.vmData', rbaContext);

						// model
	        			var modelID = value.modelID || 'src/core/model/Model';
						refs.model = this._getObject( 'refs.' + ph + '.model', rbaContext);
						if (!refs.model) {
		        			objs.model = this._getObject( modelID, rbaContext);
		        			if (!objs.model)
		        				deps.push( modelID );
						}
	        			
						// template
	        			var templateID = value.templateID;
						refs.template = this._getObject( 'refs.' + ph + '.template', rbaContext);
	        			if (!refs.template && templateID) 
	        				deps.push( 'text!' + templateID );
	        			
	        			this._processRba( value, ph, deps, objs, refs, rbaContext );
	        	}, this);				
			} else if(!_.isEmpty(this.placeholders)) {
				this._handleRBAData(rbaData);
			}
    	},
    	
    	
		/**
		 * Process the a single RBA
		 */
    	_processRba: function( value, ph, deps, objs, refs, rbaContext ) {
			var self = this;
			self.___children || ( self.___children = []);
			
    		require( deps, function( /*DynView, DynViewModel, DynModel, template*/ ) {
    			var i = 0;
    			var DynView = objs.view? objs.view: arguments[i++];
    			var DynViewModel = (objs.viewModel || refs.viewModel)? objs.viewModel: arguments[i++];
    			var DynModel = (objs.model || refs.model)? objs.model: arguments[i++];
    			var template = refs.template || arguments[i++];

    			// initialize the model
    			var model = refs.model? refs.model: new DynModel( value.modelData, value.modelConfig );

    			// initialize the view model
    			var vmInit =  { data: refs.vmData || value.vmData, config: value.vmConfig, models: {} };
    			vmInit.models[ value.vmModelName || 'model' ] = model;
    			_.extend( vmInit, value.vmOptions, rbaContext[ph]? rbaContext[ph].vmOptions: null);
    			var viewModel = refs.viewModel? refs.viewModel: new DynViewModel( vmInit );

    			// initialize the view
    			var start = rbaContext && rbaContext.el? $(rbaContext.el): self.$el;
    			var el = (start.attr('data-uxf-rba') == ph)? start: start.find('[data-uxf-rba="' + ph + '"]');
    			if (!el || !el.length)
    				return;
    			
    			var viewConfig = _.extend( 
    					{ 	el: el,
    						insertMethod: 'append',
    						autoRender : true
    					},
    					value.viewConfig,
    					refs.viewConfig? refs.viewConfig: {},
    					template? {template: template}:{} );
    			var vInit = _.extend( 
    					{ config: viewConfig, viewModel: viewModel }, 
    					value.viewAttributes? { attributes: value.viewAttributes} : {},
    					value.viewVmKeys? { vmKeys: value.viewVmKeys} : {},
    					value.viewOptions, rbaContext[ph]? rbaContext[ph].viewOptions: null );
    			var view = new DynView( vInit );
    			self.___children.push(view);
    		}  );

    	},

    	
    	/**
    	 * Fetches rba data from the protected service and calls processRbaData.
    	 * 
		 * @methodOf Lightsaber.Core.View#
		 * @name processRbaUrl
    	 * @param {String} rbaUrl     The Rba service's Url
    	 * @param {Object} [rbaContext] The Rba context to use
    	 */
    	processRbaUrl: function( rbaUrl, rbaContext ) {
    		var model = new RESTModel( null, { url: rbaUrl } );
    		var self = this;
    		return model.fetch( {success: function( model, response ) {
    			self.processRbaData( model.toJSON(), rbaContext );
    			rbaContext && rbaContext.callback && rbaContext.callback(response);
    			self.trigger('rba:loaded');
    		}});
    	},
		
		/**
		 * Processes the RBA configuration
		 */
		_processRbaConfig: function() {
			if (this.options && this.options.config) {
				if (this.options.config.rbaUrl)
					this.processRbaUrl( this.options.config.rbaUrl );
				else if (this.options.config.rbaData)
					this.processRbaData( this.options.config.rbaData );
			}
		},
		
		/**
		 * Gets an object from the RBA configuration
		 */
		_getObject: function( path, context) {
			if (path && context) {
				var segs = path.split('.');
				return _.reduce( segs, function(memo, seg) { return memo? memo[seg]: undefined; }, context );
			}
		},
		
		getBindContext: function() {
			return _.extend(_getBindContext(this), this.getConfig("bindContext") || {});
		},

        switchClass: function(addClassNames, removeClassNames ,callbackFunc){
            var elm = this.$root;
            elm.off("transitionend");
            elm.one("transitionend", function(){
                if (_.isFunction(callbackFunc)){
                    callbackFunc();
                }
            });

            var baseStyle = _getElementStyles(elm[0]);
            elm.removeClass(removeClassNames).addClass(addClassNames);

            var delay =  elm.css('transition-delay');
            delay = parseFloat(delay) * 1000;
            setTimeout(function(){//_getElementStyles return the current used values of the elements.
                //We must wait few mill-second more than the transition-delay to let the animation take effect.
                var animatedStyle = _getElementStyles(elm[0]);
                if ($.isEmptyObject(_styleDifference(baseStyle,animatedStyle))){//no change made to the element. this mean that the transition has ended, or to be precised hasn't started yet.
                    elm.trigger("transitionend");
                }
            },delay + 100);
            return this;
        },
        getGroupId : function(VmConstructor){
            var mappingObj = (this.options && this.options.vmGroupId) || '';
            if (_.isString(mappingObj))
            {
                return mappingObj + '.';
            }
            if (mappingObj.hasOwnProperty(VmConstructor.moduleID)){
                return mappingObj[VmConstructor.moduleID] + '.';
            }
            return null;
        }
	});
	
	_.extend(View.prototype, Utils.Factory, Utils.Common);
	
	var _getBindContext = function( view ) {
		var options = {
			getVMData: _.bind(view._getVMData, view),
			getResourceBundle: _.bind(view.getResourceBundle, view)
		};
		return options;
	};

    var _getElementStyles = function ( elem ) {
        var key, len,
            style = elem.ownerDocument.defaultView ?
                elem.ownerDocument.defaultView.getComputedStyle( elem, null ) :
                elem.currentStyle,
            styles = {};

        if ( style && style.length && style[ 0 ] && style[ style[ 0 ] ] ) {
            len = style.length;
            while ( len-- ) {
                key = style[ len ];
                if ( typeof style[ key ] === "string" ) {
                    styles[ $.camelCase( key ) ] = style[ key ];
                }
            }
        }

        return styles;
    };
    var _styleDifference = function ( oldStyle, newStyle ) {
        var diff = {}, name, value;
        var noneComparedStyles = {border: 1,	borderBottom: 1, borderColor: 1, borderLeft: 1,
            borderRight: 1, borderTop: 1, borderWidth: 1, margin: 1, padding: 1 ,
            transitionDuration:1, WebkitTransitionDuration:1, oTransitionDuration:1 	}
        for ( name in newStyle ) {
            value = newStyle[ name ];
            if ( oldStyle[ name ] !== value ) {
                if ( !noneComparedStyles[ name ] ) {
                    if ( $.fx.step[ name ] || !isNaN( parseFloat( value ) ) ) {
                        diff[ name ] = value;
                    }
                }
            }
        }
        return diff;
    };

	/**
	 * @methodOf Lightsaber.Core.View#
	 * @name extend
	 * 
	 */
	View.extend = Utils.extend;
	View.mergeProperties = {'scope': 'merge', 'publicMethods':'merge','config':'merge', 'vmKeys':'merge', 'vmKeysChangeEvents':'merge'};

	View.getViewActions = function() {
        return this.prototype.publicMethods;
	};

	return View;

});

/**
@deprecated
**/
define('src/core/application/Application',[
    'backbone',
    'src/core/util/Utils',
    'src/core/util/StorageUtil'
], function(Backbone, Utils, StorageUtils) {

    'use srtict';
    
    var Application = Backbone.View.extend({
    	constructor : function(options) {
    		this.areaCode = options.id || 'lsapp';
    		this.context = StorageUtils.get(this.areaCode) || {};
    		Backbone.View.apply(this, arguments);
    	},
    	
    	navigate : function(route, options) {
    		StorageUtils.set(this.areaCode, this.context);
    		this.options.router.navigate(route, options);    		
		},
		
    	destroy : function() {
    		
    	},
    	
    	create: Utils.create
    });

    Application.extend = Utils.extend;
    
    return Application;

});
/**
 Responsible for Widgets internal flow.

 @class Lightsaber.Core.WidgetInternalFlow
 @namespace Lightsaber.Web
 @module Lightsaber.Web
 @extends Backbone.View

 @requires jquery
 @requires backbone
 @requires Lightsaber.Utils

 @since 9.1.0

 @constructor
 @param {Object} options main configuration object
 **/
define( 'src/core/application/WidgetInternalFlow',[
    'jquery',
    'underscore',
    'src/core/view/View',
    'src/core/util/Utils'
], function ( $, _, LightsaberCoreView, Utils ){
    
    var EXCEPTIONS = {
        ARGUMENTS: {
            MISSING: {
                VIEW_ROUTES: 'You must initialize the class with a viewRoutes array.',
                WIDGET: 'You must initialize the class with a widget object.',
                ID: 'Each viewRoute must have an id defined.',
                UXF_POINT: 'Each viewRoute must have a reference to a DOM elment using uxfPoint or el.',
                METHOD: 'Incorrect method assignment. Please check your configuration'
            },
            DUPLICATE: {
                UXF_POINT: 'Multiple el definition. Use uxfPoint or el not both.',
                ID: 'You have created duplicate keys with the same amount. Please check id : ',
                DEFAULT: 'Only 1 viewRoute per placeholder is allowed to be the default viewRoute.',
                NONE_DEFAULT: 'All viewRoutes for a single placeholder are defiend as false. Please set one of them as true or as undefined.'
            }
        },
        RELATION: {
            PLACEHOLDER: 'Each placeholder must have a viewRoutes related to it.',
            DOM: 'Requesting to show a view that is not attached to any DOM element.'
        }
    };

    /**
     Check if the current browser support css transition.
     @returns {boolean} true if support otherwise false.
     @private
     */
    var _isBrowserSupportTransition = function (){
        var s = document.createElement( 'p' ).style;
        return 'transition' in s ||
            'WebkitTransition' in s ||
            'MozTransition' in s ||
            'msTransition' in s ||
            'OTransition' in s;
    };

    /**
     Parse viewRoute keys in the format of key/:p1/:p2 and format them to the KeyParam object.
     @param keyAndParams
     @returns {{
          key: string         The key name,
          params: (*|Array)   List of params
     }}
     @constructor
     */
    var KeyParam = function ( keyAndParams ){
        var keyList = keyAndParams.split( '/:' );
        var key = keyList.shift();
        return {
            key: key,
            params: keyList
        };
    };
    /**
     A digest viewRoute object created based on the viewRoute and used internally in the WidgetInternalFlow
     allowing it a quicker understanding and reference when the developer request to load a viewRoute based on its key
     @param viewRoute
     @param keyParams
     @returns {*}
     @constructor
     */
    var DigestViewRoute = function ( viewRoute, keyParams ){
        return $.extend( {_digestHelper: $.extend( keyParams, {paramsLength: keyParams.params.length} )}, viewRoute,
            {
                toViewRoute: function (){
                    var digestViewRoute = _.clone( this );
                    var omitPropList = _.reduce( this, function ( memo, value, key ){
                        if ( _.isFunction( value ) ) {
                            memo.push( key )
                        }
                        return memo
                    }, [] ); //list of all functions
                    omitPropList.push( '_digestHelper' );
                    var valuesList = digestViewRoute._digestHelper.dynamicParamsValue;
                    var viewRoute = _.omit( digestViewRoute, omitPropList );

                    var paramsNameList = digestViewRoute._digestHelper.params;

                    viewRoute.params = viewRoute.params || {};
                    _.each( paramsNameList, function ( name, idx ){
                        viewRoute.params[name] = valuesList ? valuesList[idx] : undefined;
                    } );

                    return viewRoute
                },
                setDynamicParamsValue: function ( values ){
                    this._digestHelper.dynamicParamsValue = values;
                }
            }
        );
    };

    var WidgetInternalFlow = function ( options ){
        this.options = options || {};
        this.config = $.extend( {}, {viewRoutesKeySplitter: '#!'}, options.config );

        this.initialize.apply( this, arguments );
    };

    _.extend( WidgetInternalFlow, {
        extend: Utils.extend,
        mergeProperties: {
            config: 'merge'
        }
    } );

    _.extend( WidgetInternalFlow.prototype, Backbone.Events, {
        /**
         The Initialize the WidgetInternalFlow object.
         */
        initialize: function (){
            this._checkReceivedData();
            this._digestViewRoute();
            this._checkViewRoutesConfig();
        },
        /**
         @private
         Check the received options and make sure they meet the minimum requirements.
         If none mandatory information is missing fill it with default values.
         */
        _checkReceivedData: function (){
            this.viewRoutes = this.options.viewRoutes;
            this.myWidget = this.options.widget;

            if ( !_.isArray( this.viewRoutes ) ) {
                throw EXCEPTIONS.ARGUMENTS.MISSING.VIEW_ROUTES;
            }
            if ( _.isUndefined( this.myWidget ) ) {
                throw EXCEPTIONS.ARGUMENTS.MISSING.WIDGET;
            }
            if ( _.isUndefined( this._digestViewRouteHash ) ) {
                this._digestViewRouteHash = {};
            }
            if ( _.isUndefined( this._viewRouteHistory ) ) {//hold the history of viewRoutes load request.
                this._viewRouteHistory = new Utils.HistoryStack();
            }
        },
        /**
         * Create the _digestViewRouteHash based on the received viewRoutes.
         * @private
         */
        _digestViewRoute: function (){
            //The _digestViewRouteHash is a hashtable with the viewRoute key as the key.
            // each object in the hashtable is an array of viewRoute with extra internal property used for quick reference.
            for ( var i = 0 ; i < this.viewRoutes.length ; i++ ) {
                var viewRoute = this.viewRoutes[i];
                if ( _.isUndefined( viewRoute.id ) ) {
                    throw EXCEPTIONS.ARGUMENTS.MISSING.ID;
                }
                if ( _.isUndefined( viewRoute.uxfPoint ) && _.isUndefined( viewRoute.el ) ) {
                    throw EXCEPTIONS.ARGUMENTS.MISSING.UXF_POINT;
                }
                if ( !_.isUndefined( viewRoute.uxfPoint ) && !_.isUndefined( viewRoute.el ) ) {
                    throw EXCEPTIONS.ARGUMENTS.MISSING.DUPLICATE.UXF_POINT;
                }
                viewRoute.el = viewRoute.el || '[data-uxf-point="' + viewRoute.uxfPoint + '"]';

                var keyParams = new KeyParam( viewRoute.id );
                //check if we have such a key in the digest hash.
                if ( !this._digestViewRouteHash.hasOwnProperty( keyParams.key ) ) {
                    this._digestViewRouteHash[keyParams.key] = [];
                }
                //check if we have a duplicate key with the same amount of params
                else if ( this._getDigestViewRoute( keyParams ) ) {
                    throw EXCEPTIONS.ARGUMENTS.MISSING.DUPLICATE.ID + viewRoute.id;
                }

                var digestedViewRoute = new DigestViewRoute( viewRoute, keyParams );
                this._digestViewRouteHash[keyParams.key].push( digestedViewRoute );
            }
        },
        /**
         * Check that the viewRoutes match all configuration restrictions.
         * @private
         **/
        _checkViewRoutesConfig: function (){
            //Check that per each placeholder only a single isDefault = true is defined and at-lease one of the viewRoutes is not defined with isDefault = false
            var placeHolderHash = this._getPlaceholdersHash();
            _.each( placeHolderHash, function ( placeHolderDigestViewRoutes ){
                var defaultVR = this._getDefaultDigestViewRoute( placeHolderDigestViewRoutes );
                if ( _.isUndefined( defaultVR ) ) {
                    throw EXCEPTIONS.RELATION.PLACEHOLDER;
                }
            }, this );
            return true;
        },
        /**
         Find the default viewRoutes from the list of digested viewRoutes received.
         @param placeHolderDigestViewRoutes - list of DigestViewRoutes that are related to a single placeholder.
         @returns DigestViewRoutes
         @private
         */
        _getDefaultDigestViewRoute: function ( placeHolderDigestViewRoutes ){
            if ( placeHolderDigestViewRoutes.length === 0 ) {
                throw EXCEPTIONS.RELATION.PLACEHOLDER;
            }

            var defaultViewRoutesArr = _.where( placeHolderDigestViewRoutes, {isDefault: true} );
            if ( defaultViewRoutesArr.length > 1 ) {
                throw EXCEPTIONS.ARGUMENTS.DUPLICATE.DEFAULT;
            }
            else if ( defaultViewRoutesArr.length === 0 ) {
                defaultViewRoutesArr = _.where( placeHolderDigestViewRoutes, {isDefault: undefined} );
                if ( defaultViewRoutesArr.length === 0 ) {
                    throw EXCEPTIONS.ARGUMENTS.DUPLICATE.NONE_DEFAULT;
                }
            }

            return defaultViewRoutesArr[0];
        },
        /**
         @private
         Extract the DigestViewRoute object based on the KeyParam object.
         @param {Object|KeyParam} keyParamsObj
         @return a DigestViewRoute object
         **/
        _getDigestViewRoute: function ( keyParamsObj ){
            var viewRouteFinder = function ( digestedVR ){
                return digestedVR._digestHelper.paramsLength === keyParamsObj.params.length;
            };
            return _.find( this._digestViewRouteHash[keyParamsObj.key], viewRouteFinder );
        },
        /**
         @private
         Extract the digest viewRoutes based on the requested keys.
         @param {Array|String} keyAndParams : list of viewRoutes keys and their dynamic values
         @return a DigestViewRoute object filled with dynamicParamsValue based on the received params in keyAndParams
         **/
        _getDigestViewRoutesByKey: function ( keyAndParams ){

            if ( _.isString( keyAndParams ) ) {
                keyAndParams = keyAndParams.split( this.config.viewRoutesKeySplitter );
            }

            var digestViewRoutes = [];
            _.each(keyAndParams,function ( keyAndParam ){
                var keyParamsObj = new KeyParam( keyAndParam );
                var digestViewRoute = this._getDigestViewRoute( keyParamsObj );
                if (digestViewRoute){
                    digestViewRoute.setDynamicParamsValue( keyParamsObj.params );
                    digestViewRoutes.push(digestViewRoute);
                }
            }, this );
            return digestViewRoutes;
        },
        /**
         @private
         Load an array of digestViewRoutes.
         @param {Object} digestViewRoutes : list of DigestViewRoute
         @param {boolean} force : indicate if the viewRoute should be created.
         @param {Object} loadCallback : Callback function called when each of the digested viewRoutes are loaded.
         **/
        _loadDigestViewRoute: function ( digestViewRoutes, force, loadCallback ){

            if ( !_.isArray( digestViewRoutes ) ) {
                digestViewRoutes = [digestViewRoutes];
            }

            _.each( digestViewRoutes, function ( digestViewRoute ){
                this._loadSingleDigestViewRoute( digestViewRoute, force, loadCallback );
            }, this );
            this.trigger('change:viewRoute',digestViewRoutes);
        },
        /**
         Load a single DigestViewRoutes
         @param digestViewRoutes - a DigestViewRoute object
         @param {boolean} force : indicate if the viewRoute should be created.
         @param {Object} loadCallback : Callback function called when each of the digested viewRoutes are loaded.
         @private
         */
        _loadSingleDigestViewRoute: function ( digestViewRoute, force, loadCallback ){
            if ( _.isUndefined( digestViewRoute ) ) {
                return;
            }
            var viewRoute = digestViewRoute.toViewRoute();

            if ( _.isString( viewRoute.method ) ) {
                var func = this.myWidget[viewRoute.method] || this.myWidget.options[viewRoute.method];
                if ( _.isFunction( func ) ) {
                    func.call( this, viewRoute );
                }
                else {
                    throw EXCEPTIONS.ARGUMENTS.MISSING.METHOD;
                }
            }
            else {
                this._loadViewRoute( viewRoute, force );
            }
            if ( _.isFunction( loadCallback ) ) {
                loadCallback( digestViewRoute );
            }
        },
        /**
         Find the placeholder unique name
         @param $element
         @returns {*}
         @private
         */
        _getPlaceholderDomUniqueName: function ( $element ){
            var placeHolderName = $element.attr( 'data-uxf-point' );
            if ( _.isUndefined( placeHolderName ) ) {
                placeHolderName = $element.attr( 'id' );
            }
            return placeHolderName;
        },
        /**
         @private
         Go over the viewRoutes list and create a placeholder hash table where the key is the DOM element and the value is an array of digestViewRoutes
         **/
        _getPlaceholdersHash: function (){
            var placeHolderHash = {};
            _.each( this._digestViewRouteHash, function ( digestViewRoutes ){
                _.each( digestViewRoutes, function ( digestViewRoute ){

                    var $el = this.myWidget.$el.find( digestViewRoute.el );
                    var key = this._getPlaceholderDomUniqueName( $el );

                    if ( _.isUndefined( placeHolderHash[key] ) ) {
                        placeHolderHash[key] = [];
                    }
                    placeHolderHash[key].push( digestViewRoute );
                }, this );
            }, this );
            return placeHolderHash;
        },
        /**
         @private
         Take an array of DigestViewRoute and add for each none called place holder the default DigestViewRoute
         @param {Object} digestViewRoutes : list of DigestViewRoute
         **/
        _addNoneCalledPlaceHoldersDefaultDigestViewRoutes: function ( digestViewRoutes ){
            var placeHolderHash = this._getPlaceholdersHash();
            var hasDigestViewRouteInList = function ( digestViewRote ){//check if the digestViewRote is a member of the digestViewRoutes list
                return _.find( digestViewRoutes, function ( digestVR ){
                    return digestVR === digestViewRote;
                } );
            };
            _.each( placeHolderHash, function ( placeHolderDigestViewRoutes ){
                if ( !_.find( placeHolderDigestViewRoutes, hasDigestViewRouteInList ) ) {//no viewRoute was found for placeholderKey
                    digestViewRoutes.push( this._getDefaultDigestViewRoute( placeHolderDigestViewRoutes ) );
                }
            }, this );
            return digestViewRoutes;
        },
        /**
         build the default information for the viewRoute animation information
         @param config
         @returns
             {
                time int - AMount of mill seconds for the animation.
                enterClassName string -  Class name that is added to the $root element when the view is loaded.
                exitClassName string - Class name that is added to the $root element when the view is removed.
                refreshClassName string -Class name that is added to the $root element when the view is reloaded.
                displayClassName string - Class name that is added to the $root element when the view is loaded and has reached his final destination.
                async Boolean - Indicate if the enter and animation should be done together or after the exit animation.
             }
         @private
         */
        _buildAnimationConfig: function ( config ){
            var defaults = {
                time: 1000,
                enterClassName: 'uxf-state-enter',
                exitClassName: 'uxf-state-exit',
                refreshClassName: 'uxf-state-refresh',
                displayClassName: 'uxf-state-display',
                async: true //indicate if the exit and enter animation should be done at the same time or one after the other.
            };
            return  $.extend( {}, defaults, config );
        },
        /**
         build the default information for the viewRoute object
         @param viewRouteObj
         @returns ViewRoute
         @private
         */
        _buildViewRoutesConfig: function ( viewRouteObj ){
            if ( !this._viewRouteCache ) {
                this._viewRouteCache = {};
            }
            if ( !this._placeholderViews ) {//hold the current displayed views.
                this._placeholderViews = {};
            }

            //Expect viewRouteObj to have to following properties
            //key - Unique identifier for wall widget viewRoutes
            //id - View Unique identifier
            //el -  jQuery search format that reference to the widget DOM element that wrap the place holder.
            //view - requireJS path to the view object.
            //cached - a Boolean value indicate if the Object should be destroyed once it move from the current state (Default = false)
            //history - If false will not be tracked (Default true)
            //animation - Animation configuration
            if ( _.isUndefined( viewRouteObj.id ) ) {
                viewRouteObj.id = _.uniqueId( this.cid );
            }
            if ( _.isUndefined( viewRouteObj.el ) ) {
                throw EXCEPTIONS.RELATION.PLACEHOLDER;
            }
            if ( !viewRouteObj.hasOwnProperty( 'cached' ) ) {
                viewRouteObj.cached = false;
            }
            if ( !viewRouteObj.hasOwnProperty( 'history' ) ) {
                viewRouteObj.history = true;
            }

            viewRouteObj.animationConfig = this._buildAnimationConfig( viewRouteObj.animationConfig );
            return viewRouteObj;
        },
        /**
         Create the View instance.
         @param viewRouteObj - viewRoute object holding all the information
         @param viewComponent - constructor function of the View
         @returns the new class' instance
         @private
         */
        _createView: function ( viewRouteObj, viewComponent ){
            var viewObj = this.myWidget.create( viewRouteObj.viewId || viewRouteObj.id, viewComponent, {
                viewModel: viewComponent.prototype.viewModel || this.myWidget.viewModel, //if no view model is defined we use the widget viewModel
                cached: viewRouteObj.cached,
                history: viewRouteObj.history,
                animationConfig: viewRouteObj.animationConfig,
                el: this.myWidget.$el.find( viewRouteObj.el ),
                viewRouteKey: viewRouteObj.id,
                routesParams: viewRouteObj.params
            } );
            return viewObj
        },
        /**
         Load a view based on the ViewRoute information
         @param viewRouteObj - The viewRoute
         @param force - Indicate if the view should be created
         @private
         */
        _loadViewRoute: function ( viewRouteObj, force ){

            if ( _.isUndefined( force ) ) {
                force = false;
            }
            this._buildViewRoutesConfig( viewRouteObj );

            var self = this;
            requirejs( [viewRouteObj.path], function ( View ){
                var viewObj = self._viewRouteCache[viewRouteObj.id];
                if ( _.isUndefined( viewObj ) || !viewObj.options.cached || force ) {
                    viewObj = self._createView( viewRouteObj, View );
                }
                self._showView( viewObj );
            } );
        },
        /**
         Display the created view.
         @param viewObj
         @private
         */
        _showView: function ( viewObj ){
            var animationConfig = viewObj.options.animationConfig;
            if ( viewObj.$el.length === 0 ) {
                throw EXCEPTIONS.RELATION.DOM;
            }
            var currPlaceHolderName = this._getPlaceholderDomUniqueName( viewObj.$el );
            var currObj = this._placeholderViews[currPlaceHolderName];
            var self = this;

            if ( currObj === viewObj ) {
                this._showDisplayedView( viewObj, animationConfig );
            }
            else {
                if ( currObj && !currObj.options.cached ) {
                    delete this._viewRouteCache[currObj.options.viewRouteKey];
                }
                this._viewRouteCache[viewObj.options.viewRouteKey] = viewObj;
                this._placeholderViews[currPlaceHolderName] = viewObj;

                //change the animation
                if ( !currObj ) {//no object to exit
                    this._enterAnimation( viewObj, animationConfig );
                }
                else {
                    if ( animationConfig.async ) {
                        this._exitAnimation( currObj, animationConfig, function (){
                            if ( !currObj.options.cached && _.isFunction( currObj.destroy ) ) {
                                currObj.destroy();
                            }
                        } );
                        this._enterAnimation( viewObj, animationConfig );
                    }
                    else {
                        this._exitAnimation( currObj, animationConfig, function (){
                            if ( !currObj.options.cached && _.isFunction( currObj.destroy ) ) {
                                currObj.destroy();
                            }
                            self._enterAnimation( viewObj, animationConfig );
                        } );
                    }
                }
            }
        },
        /**
         Take the current displayed view and re-display it.
         @param viewObj
         @param animationConfig
         @private
         */
        _showDisplayedView: function ( viewObj, animationConfig ){
            if ( _.isFunction( viewObj.refresh ) ) {
                viewObj.refresh();
            }
            this._enterAnimation( viewObj, animationConfig, true /*refresh*/ );
        },
        /**
         Display the view with the defined enter animation.
         @param viewObj
         @param animationObj
         @param refresh
         @param enterDoneCallback
         @private
         */
        _enterAnimation: function ( viewObj, animationObj, refresh, enterDoneCallback ){

            if ( !viewObj ) {//no element to enter
                if ( enterDoneCallback ) {
                    enterDoneCallback();
                }
                return;
            }

            var self = this;
            var callback = function (){
                viewObj.removeClass( animationObj.enterClassName ).removeClass( animationObj.refreshClassName ).addClass( animationObj.displayClassName );
                viewObj.trigger( 'change:visible', {value: true} );//send event that the animation has finished
                if ( enterDoneCallback ) {
                    enterDoneCallback.call( self, viewObj );
                }
            };

            if ( _isBrowserSupportTransition() ) {
                if ( refresh ) {
                    viewObj.switchClass( animationObj.refreshClassName, [animationObj.enterClassName, animationObj.exitClassName].join( ' ' ), callback );
                }
                else {
                    viewObj.switchClass( animationObj.enterClassName, [animationObj.refreshClassName, animationObj.exitClassName, animationObj.displayClassName].join( ' ' ), callback );
                }
            }
            else {//Browser that do not support css transaction (IE 8/9) will use jQuery UI.
                viewObj.removeClass( animationObj.enterClassName ).removeClass( animationObj.exitClassName );
                if ( refresh ) {
                    viewObj.addClass( animationObj.refreshClassName, animationObj.time, callback );
                }
                else {
                    viewObj.addClass( animationObj.enterClassName, animationObj.time, callback );
                }
            }
        },
        /**
         * Exit the view with the defined exit animation.
         * @param viewObj
         * @param animationObj
         * @param refresh
         * @param enterDoneCallback
         * @private
         */
        _exitAnimation: function ( viewObj, animationObj, exitDoneCallback ){
            var self = this;
            if ( !viewObj ) {//no element to exit
                if ( exitDoneCallback ) {
                    exitDoneCallback.call( self );
                }
                return;
            }
            var callback = function (){
                viewObj.trigger( 'change:visible', {value: false} );//send event that the animation has finished
                if ( exitDoneCallback ) {
                    exitDoneCallback.call( self, viewObj );
                }
                viewObj.removeClass( animationObj.exitClassName );
            };

            if ( _isBrowserSupportTransition() ) {
                viewObj.switchClass( animationObj.exitClassName, [animationObj.enterClassName, animationObj.refreshClassName, animationObj.displayClassName].join( ' ' ), callback );
            }
            else {//Browser that do not support css transaction (IE 8/9) will use jQuery UI.
                viewObj.removeClass( animationObj.enterClassName ).removeClass( animationObj.refreshClassName ).removeClass( animationObj.displayClassName );
                viewObj.addClass( animationObj.exitClassName, animationObj.time, callback );
            }
        },

        /**
         Load a viewRoute/s based on the viewRoutesKeys parameter.
         Each viewRoute in the list is added to the history stack (if not defined as history=false).
         @param viewRouteKeys - hold the key to identify the viewRoute or the action that must be called. Possible values are:
         'key' - simple key identifier
         'key/:value/:value2' - a key identifier and 2 values that should be grouped into a single object and passed as a parameter to the loading action or to the viewRote object as options property.
         @param force - Optional parameter, Indicate if the View should be recreate event if defined as cached view (default false)
         */
        load: function ( viewRouteKeys, force ){
            var digestViewRoutes = this._getDigestViewRoutesByKey( viewRouteKeys );
            var self = this;
            this._loadDigestViewRoute( digestViewRoutes, force, function ( digestViewRoute ){
                self._viewRouteHistory.push( digestViewRoute );
            } );
        },
        /**
         Load a group of viewRoute/s based on the viewRoutesKeys parameter.
         All viewRoutes in the list are added to the history as a single action.
         Note: All placeholders that didn't had a viewRoute assigned to them will be loaded with their default viewRoute
         @param viewRouteKeys - list of viewRoute array or a string with #! as an array delimiter.
         @param force - Optional parameter, Indicate if the View should be recreate event if defined as cached view (default false)
         */
        navigate: function ( viewRouteKeys, force ){
            var digestViewRoutes = this._getDigestViewRoutesByKey( viewRouteKeys );
            digestViewRoutes = this._addNoneCalledPlaceHoldersDefaultDigestViewRoutes( digestViewRoutes );
            this._loadDigestViewRoute( digestViewRoutes, force );
            this._viewRouteHistory.push( digestViewRoutes );
        },
        /**
         Load the previous displayed viewRoutes in the history stack
         */
        prev: function (){
            var digestViewRoutes = this._viewRouteHistory.prev();
            this._loadDigestViewRoute( digestViewRoutes, false );
        },
        /**
         Load the next displayed viewRoutes in the history stack
         */
        next: function (){
            var digestViewRoutes = this._viewRouteHistory.next();
            this._loadDigestViewRoute( digestViewRoutes, false );
        }
    } );

    return WidgetInternalFlow;
} );
/**
Represents a self-contained business component.

@class Lightsaber.Core.BusinessWidget
@namespace Lightsaber.Core
@module Lightsaber.Core
@extends Lightsaber.Core.View

@requires Lightsaber.Core.View

@since 9.1.0

@constructor
@param {Object} options main configuration object
**/
define('src/core/application/BusinessWidget',[
    'jquery',
    'underscore',
    'src/core/view/View',
    'src/core/util/Utils',
    'knockout',
    'src/core/application/WidgetInternalFlow'
], function($,_,LightsaberCoreView,Utils, KO, WidgetInternalFlow) {

    

    /**
    Returns *ViewModel* instance.

    @method _getViewModelInstance
    @private
    return {ViewModel} ViewModel instance
    **/
    var _getViewModelInstance = function() {
        if (typeof(this.viewModel) === 'function') {
            return this.create('rootViewModel', this.viewModel, {});
        }
        return this.viewModel;
    };

    var BusinessWidget = LightsaberCoreView.extend({
        isBusinessWidget: true,

        getMetaData: function () {
            return metaData;
        },
        
        /**
        Inner component actions mapping.
         
        @property {Object} actionMap
        @protected

        @example

        ```json
        actionMap: {
            'loginForm.userNameInput' : {
                'hide' : 'hideUsername' // public
                'clear' : '_clearUserName' // private
            }
        }
        ```

        **/
        actionMap: {},

        /**
        @private
        **/
        _configure: function(options) {            
            this.contentData = options.contentData;
            this.viewModel = _getViewModelInstance.call(this);
            this.executionContext = options.executionContext || {};
            this._super(options);
        },

        render:function(){
            this._super();
            this._initInnerFlowArtifacts();
            this._processRules();
            return this;
        },

        _initInnerFlowArtifacts: function() {
            var viewRoutes = this.options.viewRoutes || this.viewRoutes;

            if(!_.isUndefined(viewRoutes)) {
                this._internalFlow = new WidgetInternalFlow($.extend(this.options, {widget: this}));
                var self = this;
                this._internalFlow.on('change:viewRoute',function(viewRouteObj){
                    self.trigger('change:viewRoute',viewRouteObj);
                });
            }
        },

        /**
        Call mode's handler function.
        **/
        loadMode: function(mode) {
            var modeHandler = this.modes[mode];

            if(this._mode !== mode) {
                if(modeHandler && (typeof this[modeHandler] === 'function')) {
                    this._mode = mode;
                    this[modeHandler]();
                }                
            }
        },


        viewRoutesLoad: function(viewRouteKeys, force){
            this._internalFlow.load(viewRouteKeys, force);
        },

        viewRoutesNavigate:function(viewRouteKeys, force){
            this._internalFlow.navigate(viewRouteKeys, force);
        },

        viewRoutesPrev:function(){
            this._internalFlow.prev();
        },

        viewRoutesNext:function(){
            this._internalFlow.next();
        },

        _processRules : function(){
            var rules = this.rules;
            var appContext = requirejs.appContext;
            if (rules && appContext){
                var self = this;
                for(var i= 0, len = rules.length; i < len ; i++){
                    KO.computed(function(){
                        var first = KO.computedContext.isInitial();
                        var result = self[this.evaluator](appContext, first);
                        if (result)
                        {
                            self.trigger('outcome:' + this.outcome);
                        }
                    },rules[i]);
                }
            }
        },
        getFromContext: function(moduleId, ModelConsturctor, options) {
            var result;

            if (this.executionContext && this.executionContext.getModule && moduleId) {
                result = this.executionContext.getModule(moduleId);
            }
            if (!result && ModelConsturctor){
                result = this.create(moduleId, ModelConsturctor, options);
            }
            return result;
        },

        _handleInlineWidgets: function(element, widgetProps, context, bindingContext) {
            var Widget, name, path, scope, config, component;

            if (_.has(widgetProps, 'path') && _.has(widgetProps, 'name')) {
                Widget = requirejs(widgetProps.path);
                name = widgetProps.id || widgetProps.name;
            } else if (_.has(widgetProps, 'name')) {
                scope = this.getConfig('scope') || this.scope;
                Widget = scope[widgetProps.name];
                name = widgetProps.id || widgetProps.name;
            } else {
                throw new Error('Incorrect widget binding parameters: must inlcude either name or path AND name.');
            }

            // Support KO virtual elements as well as regular ones
            if(element.nodeName === '#comment') {

                var component = this.create(name, Widget, {el: element, config: widgetProps});

                KO.virtualElements.prepend(element, component.root);
            } else {
                
                this.create(name, Widget, {el: element, config: widgetProps});
            }    
        }
    });

    return BusinessWidget;

});
/**
Base Hub <em>Topic</em> component - not intended to be used directly, rather extended by various specific <em>Topic</em> components. 

@class Lightsaber.Core.HubBaseTopic
@namespace Lightsaber.Core
@module Lightsaber.Core
@extends Object

@requires underscore
@requires Backbone
@requires Lightsaber.Utils

@since 9.0.0
@private

@constructor
@param {Object} options main configuration object
@param {Object} [options.mode='pubsub'] work mode
**/
define('src/core/hub/HubBaseTopic',[
    'underscore', 
    'backbone',
    'src/core/util/Utils',
    'src/core/viewModel/ViewModel'
], function(_, Backbone, Utils, LightsaberCoreViewModel) {

    


    var HubBaseTopic = LightsaberCoreViewModel.extend({

        WRITE_ONLY: 'pub',
        READ_ONLY: 'sub',
        READ_WRITE: 'pubsub',

        CHANGE_ACTION_NAME: '$change',
        SUBSCRIBE_ACTION_NAME: '$subscribe',

        /**
        Main-entry method. Initializes the topic.
        
        @method initialize
        @param {Object} options main configuration object
        @param {Object} [options.mode='pubsub'] work mode
        **/
        initialize: function(options) {
            this.options = options || {};
            this.mode = this.options.mode || this.mode || this.READ_WRITE;
            this.vmKeys = this.options.vmKeys;
        },

        /**
        Returns whether the topic is write-only.
        
        @method isWriteOnly
        @return {Boolean} is topic write-only
        **/
        isWriteOnly: function() {
            return this.mode === this.WRITE_ONLY;
        },


        /**
        Returns whether the topic is read-only.
        
        @method isReadOnly
        @return {Boolean} is topic read-only
        **/
        isReadOnly: function() {
            return this.mode === this.READ_ONLY;
        },

        /**
        Destroys the topic.

        Calls *Backbone.Events* `off` method (that it mixed in from), to remove any listeners attached to the
        *Topic*.
        
        @method destroy
        **/
        destroy: function() {
            this.off();
        },

        /**
        Unsubscribes a handler from the topic.
        
        @method unsubscribe
        @param {Function} handler the initial handler that was attached to the topic
        @param {Object} context the initial context that was used for the binding of the handler to the topic
        **/
        unsubscribe: function(handler, context) {
            this.off(null, handler, context);
        },

        /**
        No-op.

        Publishes data to the topic.

        Expected to be overridden by extending classes.
        
        @method publish
        **/
        publish: function() {},
        
        /**
        No-op.

        Subscribes to the topic.

        Expected to be overridden by extending classes.
        
        @method subscribe
        **/
        subscribe: function() {}

    });

    return HubBaseTopic;

});
/**
Generic Hub <em>Topic</em> component. 

@class Lightsaber.Core.HubTopic
@namespace Lightsaber.Core
@module Lightsaber.Core
@extends Lightsaber.Core.HubBaseTopic

@requires Lightsaber.Core.HubBaseTopic
@requires Lightsaber.Core.TopicVmMapper
@requires Lightsaber.Utils

@since 9.0.0

@constructor
@param {Object} options main configuration object
@param {Object} [options.mode='pubsub'] work mode
@param {Object} options.vmId *ViewModel* ID
@param {Object} options.vmKeys `vmKeys` configuration - mapping of pre-defined properties to specific ones on the specific *ViewModel*
**/
define('src/core/hub/HubTopic',[
    'src/core/hub/HubBaseTopic',
    'src/core/util/Utils'
], function(HubBaseTopic, Utils) {

    var PrivateMethods = {

        /**
        Sets *ViewModel* to be used by the topic.

        @method setViewModel
        @param {Lightsaber.Core.ViewModel} viewModel *ViewModel*
        **/
        setViewModel: function(viewModel) {
            this.subViewModels = this.subViewModels || {};
            if (!this.subViewModels.viewModel) {
                this.subViewModels.viewModel = viewModel;
                PrivateMethods.createDataBindings.call(this);
                this._bindData();
            }
        },

        generateTopicData: function(data, action) {
            var topicData = Utils.clone(_.omit(this.get(), 'subViewModels'));
            var _data = {
                action: action,
                data: topicData
            };
            if (action === this.SUBSCRIBE_ACTION_NAME) {
                _data.changedAttributes = topicData;
                _data.prevAttributes = {};
                _data.changedAttributes = {};
            } else if (action === this.CHANGE_ACTION_NAME) {
                _data.changedAttributes = Utils.clone(data.changed);
                _data.prevAttributes = Utils.clone(_.omit(data.target.data.previousAttributes(), 'subViewModels'));
            }
            return _data;
        },

        parsePath: function(path) {
            var isColonSeparatedPath = path.indexOf(':') > -1;
            if (!isColonSeparatedPath) {
                return path;
            }
            var parts = path.split(':');
            var viewModels = parts[0].split('.');
            var attr = parts[1];
            return 'subViewModels.' + viewModels.join('.subViewModels.') + '.' + attr;
        },

        createDataBindings: function() {
            this.dataBindings = [];            
            var topicKey;
            var dataBindingOptions = {
                options: {
                    twoWay: !this.isReadOnly()
                }
            };
            if ( !_.isUndefined(this.vmKeys) ) {
                _.each(_.keys(this.vmKeys), function(vmKey) {
                    if (vmKey.indexOf('data.') !== 0) {
                        return;
                    }
                    topicKey = vmKey.substring(5);
                    var dataBinding = _.extend({}, dataBindingOptions);
                    if (_.isString(this.vmKeys[vmKey])) {
                        dataBinding[topicKey] = 'subViewModels.viewModel.' + PrivateMethods.parsePath.apply(this, [this.vmKeys[vmKey]]);
                    }
                    else if (_.isObject(this.vmKeys[vmKey])) {
                        dataBinding[topicKey] = ['subViewModels.viewModel.subViewModels', this.vmKeys[vmKey].vm, this.vmKeys[vmKey].key].join('.');
                    }
                    this.dataBindings.push(dataBinding);
                }, this);
            } else {
                _.each(_.keys(this.subViewModels.viewModel.get()), function(vmKey) {
                    dataBinding = {
                        options: {
                            twoWay: !this.isReadOnly()
                        }
                    }
                    dataBinding[vmKey] = 'subViewModels.viewModel.' + vmKey;
                    this.dataBindings.push(dataBinding);
                }, this);
            }
        },

        getVmAction: function(topicAction) {
            return this.vmKeys ? this.vmKeys['action.' + topicAction] : topicAction;
        },

        getTopicActions: function() {
            var actionPrefix = 'action.';
            var topicActions = [];
            _.each(_.keys(this.vmKeys || []), function(key) {
                if (key.indexOf(actionPrefix) === 0) {
                    topicActions.push(key.substring(actionPrefix.length))
                }
            });
            return topicActions;
        }

    };

    var HubTopic = HubBaseTopic.extend({

        viewModel: undefined,

        /**
        Main-entry method. Initializes the topic.
        
        @method initialize
        @param {Object} options main configuration object
        @param {Object} [options.mode='pubsub'] work mode
        @param {Object} options.vmId *ViewModel* ID
        @param {Object} options.vmKeys `vmKeys` configuration - mapping of pre-defined properties to specific ones on the specific *ViewModel*
        **/
        initialize: function(options) {
            this._super(options);
            this.vmId = this.options.vmId;
            this.on('change', function(data) {
                this.trigger('__change', PrivateMethods.generateTopicData.apply(this, [data, this.CHANGE_ACTION_NAME]));
            }, this);            
        },


        /**
        Subscribes to the topic.

        @method subscribe
        @param {Object} options subscription parameter
        @param {Function} options.handler subscription handler function
        @param {Object} options.context subscription handler function execution context
        @param {Object} [options.silent=false] whether to make *ViewModel* update silent
        **/
        subscribe: function(options) {
            requirejs([this.vmId], _.bind(function(viewModel) {
                var actions;
                PrivateMethods.setViewModel.apply(this, [viewModel]);
                if ( _.indexOf(options.actions, 'change') > -1 || !options.actions) {
                    // registers to topic change event if explicitly specified in actions or if no 'actions' option was provided                    
                    this.on('__change', options.handler, options.context);
                }
                if (this.vmKeys) {
                    actions = options.actions ? _.intersection(PrivateMethods.getTopicActions.call(this), options.actions) : PrivateMethods.getTopicActions.call(this);
                    var vmAction;
                    _.each(actions, function(action) {
                        vmAction = PrivateMethods.getVmAction.call(this, [action]);
                        this.subViewModels.viewModel.on('action:' + vmAction, function(args) {
                            var topicData = _.omit(this.get(), 'subViewModels');
                            var mergedTopicdata = PrivateMethods.generateTopicData.apply(this, [{}, action]);
                            mergedTopicdata.args = args;

                            this.trigger('__action:' + action, mergedTopicdata);
                        }, this);
                        this.on('__action:' + action, options.handler, options.context);
                    }, this);
                }
                if (!options.silent) {
                    var topicData = _.omit(this.get(), 'subViewModels');
                    (_.bind(options.handler, options.context))(PrivateMethods.generateTopicData.apply(this, [{}, this.SUBSCRIBE_ACTION_NAME]));
                }
            }, this));
        },

        /**
        Publishes data to the topic.
        
        @method publish
        @param {...} data data to be published to the topic
        @param {String} action action to be handled when the data is published
        **/
        publish: function(data, action) {
            requirejs([this.vmId], _.bind(function(viewModel) {
                PrivateMethods.setViewModel.apply(this, [viewModel]);
                data = _.pick(data, _.keys(this.get()));
                this.set(data);
                if (action) {
                    var vmAction = PrivateMethods.getVmAction.apply(this, [action]);
                    if ( vmAction ) {
                        this.subViewModels.viewModel.handleAction(vmAction);
                    }
                }
            }, this));
        },

        /**
        Destroys the topic.

        Callse `_super` and then calls {{#crossLink "Lightsaber.Core.ViewModel/off:method"}}{{/crossLink}} to remove any listeners attached to the topic's
        *ViewModel*.
        
        @method destroy
        **/
        destroy: function() {
            this._super();
            if (this.viewModel) {
                this.viewModel.off(null, null, this);
            }
        }

    });

    return HubTopic;

});
/**
Generic Security <em>Topic</em> component. 

@class Lightsaber.Core.SecurityTopic
@namespace Lightsaber.Core
@module Lightsaber.Core
@extends Lightsaber.Core.HubBaseTopic

@requires Lightsaber.Core.HubBaseTopic
@requires Lightsaber.Core.LSRESTDataSource

@since 9.0.0

@constructor
@param {Object} options main configuration object
@param {Object} [options.mode='pubsub'] work mode
**/
define('src/core/hub/SecurityTopic',[
    'src/core/hub/HubBaseTopic',
    'src/core/dataSource/LSRESTDataSource'
], function(HubBaseTopic,LSRESTDataSource) {
   
    

    var SecurityTopic = HubBaseTopic.extend({

        /**

        **TOKEN_UPDATED_EVENT** event.
        
        @property {String} TOKEN_UPDATED_EVENT
        @default `'tokenUpdated'`
        @static
        **/
        /**

        **TOKEN_TIMEOUT_EVENT** event.
        
        @property {String} TOKEN_TIMEOUT_EVENT
        @default `'tokenTimeout'`
        @static
        **/
        TOKEN_UPDATED_EVENT: 'tokenUpdated',
        TOKEN_TIMEOUT_EVENT: 'tokenTimeout',        

        /**
        Main-entry method. Initializes the topic and sets listener on {{#crossLink "Lightsaber.Core.LSRESTDataSource"}}{{/crossLink}} to 
        notify of any security errors.
        
        @method initialize
        @param {Object} options main configuration object
        @param {Object} [options.mode='pubsub'] work mode
        **/
        initialize: function(options) {
            this._super(options);
            LSRESTDataSource.on(LSRESTDataSource.TOKEN_UPDATE_EVENT, function(data) {
                this.trigger(this.TOKEN_UPDATED_EVENT, {token: data.token});
            }, this);
            LSRESTDataSource.on(LSRESTDataSource.ERROR, function(data) {
                data.type = LSRESTDataSource.TOKEN_INVALID;
                this.trigger('error', data);
            },this); 
        },

        /**
        Subscribes to the topic. Subscribes to {{#crossLink "Lightsaber.Core.SecurityTopic/TOKEN_UPDATED_EVENT:property"}}{{/crossLink}} event.

        @method subscribe
        @param {Object} options subscription parameter
        @param {Function} options.handler subscription handler function
        @param {Object} options.context subscription handler function execution context
        **/
        subscribe: function(options) {
            this.on(this.TOKEN_UPDATED_EVENT, options.handler, options.context);
        },

        /**
        Publishes data to the topic. Data in this case is the security token being set on {{#crossLink "Lightsaber.Core.LSRESTDataSource"}}{{/crossLink}}
       
        @method publish
        @param {...} data data to be published
        @param {Boolean} data.persist should token be persisted to the session storage
        @
        **/
        publish: function(data) {
            var persist = !_.isUndefined(data.persist) ? data.persist : true;
            LSRESTDataSource.prototype.setToken(data.token,persist);
        }

    });

    return SecurityTopic;

});
/**
Generic Hub <em>Error Topic</em> component. 

@class Lightsaber.Core.ErrorTopic
@namespace Lightsaber.Core
@module Lightsaber.Core
@extends Lightsaber.Core.HubBaseTopic

@requires Lightsaber.Core.HubBaseTopic

@since 9.0.0

@constructor
@param {Object} options main configuration object
@param {Object} [options.mode='pubsub'] work mode
**/
define('src/core/hub/ErrorTopic',[
    'src/core/hub/HubBaseTopic'
], function(HubBaseTopic) {
   
    

    var ErrorTopic = HubBaseTopic.extend({

        /**
        Publishes data to the topic.
        
        @method publish
        @param {...} data data to be published to the topic
        **/

        /**
        Generic error event.
        
        @event error
        @param {...} data data that was published to the topic
        **/
        publish: function(data) {
            this.trigger('error', data);
        },

        /**
        Subscribes to the topic.

        @method subscribe
        @param {Object} options subscription parameter
        @param {Function} options.handler subscription handler function
        @param {Object} options.context subscription handler function execution context
        **/
        subscribe: function(options) {
            this.on('error', options.handler, options.context);
        }

    });

    /**

    **UNREGISTERED_TOPIC** Error type.
    
    @property {String} UNREGISTERED_TOPIC
    @default `'unregistered'`
    @static
    **/
    /**

    REGISTERED_TOPIC Error type.
    
    @property {String} REGISTERED_TOPIC
    @default `'registered'`
    @static
    **/
    /**    

    **UNKONWN_PAYLOAD** Error type.
    
    @property {String} UNKONWN_PAYLOAD
    @default `'unkownPayload'`
    @static
    **/
    /**

    **INVALID_PAYLOAD** Error type.
    
    @property {String} INVALID_PAYLOAD
    @default `'invalidPayload'`
    @static
    **/
    /**

    **READ_ONLY_TOPIC** Error type.
    
    @property {String} READ_ONLY_TOPIC
    @default `'readOnly'`
    @static
    **/
    /**

    **WRITE_ONLY_TOPIC** Error type.
    
    @property {String} WRITE_ONLY_TOPIC
    @default `'writeOnly'`
    @static
    **/
    _.extend(ErrorTopic, {        
        UNREGISTERED_TOPIC: 'unregistered',
        REGISTERED_TOPIC: 'registered',
        UNKONWN_PAYLOAD: 'unkownPayload',
        INVALID_PAYLOAD: 'invalidPayload',
        READ_ONLY_TOPIC: 'readOnly',
        WRITE_ONLY_TOPIC: 'writeOnly'
    });

    return ErrorTopic;

});
/**
Business Widget <em>Hub</em> component. Intended for 3rd party components' interactions.

@class Lightsaber.Core.BusinessWidgetHub
@namespace Lightsaber.Core
@module Lightsaber.Core
@extends Object
@singleton true

@requires underscore
@requires backbone
@requires Lightsaber.Core.HubBaseTopic
@requires Lightsaber.Core.SecurityTopic
@requires Lightsaber.Core.ErrorTopic

@since 9.1.0

@constructor
**/
define('src/core/hub/BusinessWidgetHub',['underscore', 
        'backbone', 
        'src/core/hub/HubTopic',
        'src/core/hub/SecurityTopic',
        'src/core/hub/ErrorTopic'
        ], function(_, Backbone, HubTopic, SecurityTopic, ErrorTopic) {
    

    var BusinessWidgetHub = function() {
        this._initialize();
    };

    _.extend(BusinessWidgetHub.prototype, {

        _topics: {},

        /**
        Main-entry method. Initializes the *Hub*.
        
        @method initialize
        **/
        _initialize: function() {
            this._setTopic('error', new ErrorTopic());
            this._setTopic('security', new SecurityTopic());
            var securityTopic = this._getTopic('security');
            securityTopic.on('error', function(data) {
                this.publish('error', data);
            },this);
        },

        /**
        Returns a *Topic* instance.
        
        @method _getTopic
        @private
        @param {String} topicName *Topic* name
        @return {Object} return *Topic* instance
        **/
        _getTopic: function(topicName) {
            return this._topics[topicName];
        },

        /**
        Sets a *Topic* to *Hub*.
        
        @method _setTopic
        @private
        @param {String} topicName *Topic* name
        @param {Object} topic *Topic* instance
        **/
        _setTopic: function(topicName, topic) {
            this._topics[topicName] = topic;
        },

        /**
        Removes a *Topic* from *Hub*.
        
        @method _removeTopic
        @private
        @param {String} topicName *Topic* name
        **/
        _removeTopic: function(topicName) {
            var topic = this._getTopic(topicName);
            topic.destroy();
            delete this._topics[topicName];
        },

        /**
         Returns whether a *Topic* is a Read only topic.

         @method isTopicReadOnly
         @param {String} topicName *Topic* name
         @return {Object} return true if read only, false if not and undefined if the topic is not registered.
         **/
        isTopicReadOnly: function(topicName){
            if ( !this.isRegistered(topicName) ) {
                return undefined;
            }
            var topic = this._getTopic(topicName);
            return topic.isReadOnly();
        },

        /**
         Returns whether a *Topic* is a Write only topic.

         @method isTopicWriteOnly
         @param {String} topicName *Topic* name
         @return {Object} return true if write only, false if not and undefined if the topic is not registered.
         **/
        isTopicWriteOnly: function(topicName){
            if ( !this.isRegistered(topicName) ) {
                return undefined;
            }
            var topic = this._getTopic(topicName);
            return topic.isWriteOnly();
        },

        /**
        Returns whether a *Topic* is registered
        
        @method isRegistered
        @param {String} topicName *Topic* name
        @return {Boolean}
        **/
        isRegistered: function(topicName) {
            return !_.isUndefined(this._getTopic(topicName));
        },

        /**
        Registers a *Topic* to *Hub*.
        
        @method register
        @param {String} topicName *Topic* name
        @param {Object} [options] *Topic* configuration object
        @param {Object} [options.vmKeys] vmKeys object  
        @param {String} [options.vmId] view model require path
        @param {String} [options.mode] *Topic* mode

        @example

        ```javascript
        Hub.register('myTopic', {
            vmId: 'app/vms/myViewModel',
            vmKeys: {
                'action.myAction' : 'myAction',
                'data.custId' : 'customerId',
                'data.customerName' : 'customerName'
            },
            mode: 'pubsub'
        });
        ```
        **/
        register: function(topicName, options) {
            if ( _.isArray(topicName) ) {
            	_.each(topicName, function(_topic) {
                    this.register(_topic.name, _topic);
                }, this);
            } else {
                if ( this.isRegistered(topicName) ) {
                    this.publish('error', {type: ErrorTopic.REGISTERED_TOPIC, topicName: topicName});
                } else {
                    this._setTopic(topicName, new HubTopic({
                        mode: options.mode,
                        vmId: options.vmId,
                        vmKeys: options.vmKeys
                    }));
                }
            }
        },

        /**
        Unregisters *Topic* from *Hub*.
        
        @method unregister
        @param {String} topicName *Topic* name
        **/
        unregister: function(topicName) {
            if ( _.isArray(topicName) ) {
                for (var i=0; i<topicName.length; i++) {
                    this.unregister(topicName[i]);
                }
            } else if ( this.isRegistered(topicName) ) {
                this._removeTopic(topicName);
            }
        },

        /**
        Subscribes a handler to a *Hub's* *Topic*
        
        @method subscribe
        @param {string} topicName *Topic* name
        @param {object} options options
        @param {function} [options.handler] callback function
        @param {object} [options.context] context object
        @param {boolean} [options.silent=false] shouldn't callback be fired on subscribe
        
        @example

        ```javascript
        var myObject = {
            balance: 1234,
            getBalance: function() {
                return this.balance;
            }
        };

        Hub.subscribe('myTopic', {
            handler: myObject.getBalance,
            context: myObject
        });
        ```
        **/
        subscribe: function(topicName, options) {
            
            if ( !this.isRegistered(topicName) ) {
                this.publish('error', {type: ErrorTopic.UNREGISTERED_TOPIC, topicName: topicName});
            } else {
                var topic = this._getTopic(topicName);
                if ( topic.isWriteOnly() ) {
                    this.publish('error', {type: ErrorTopic.WRITE_ONLY_TOPIC, topicName: topicName});
                } else {
                    topic.subscribe({
                        handler: options.handler,
                        context: options.context,
                        actions: options.actions,
                        silent: options.silent
                    });
                }
            }
        },

        /**
        Unsubscribes from a *Hub's* *Topic*
        
        @method unsubscribe
        @param {string} topicName *Topic* name
        @param {object} options options
        @param {function} [options.handler] callback function
        @param {object} [options.context] context object
        
        @example

        ```javascript
        var myObject = {
            balance: 1234,
            getBalance: function() {
                return this.balance;
            }
        };

        // remove subscription to handler
        Hub.unsusbcribe('myTopic', {
            handler: myObject.getBalance,
        });

        // or alternatively remove all subscriptions under particular context
        Hub.unsusbcribe('myTopic', {
            context: myObject
        });       
        ```  
        **/
        unsubscribe: function(topicName, options) {
            if ( !this.isRegistered(topicName) ) {
                this.publish('error', {type: ErrorTopic.UNREGISTERED_TOPIC, topicName: topicName});
                return;
            } 
            else {
                var context = options.context || null;
                var handler = options.handler || null;              
                var topic = this._getTopic(topicName);
                topic.unsubscribe(handler,context);
            }
        },

        /**
        Publishes data to *Topic*.
        
        @method publish
        @param {String} name topicName
        @param {Object} topicData topic data
        @param {String} [action] action to be handled after publish
        **/
        publish: function(topicName, topicData, action) {
            if ( !this.isRegistered(topicName) ) {
                this.publish('error', {type: ErrorTopic.UNREGISTERED_TOPIC, topicName: topicName});
            } else {
                var topic = this._getTopic(topicName);              
                if ( topic.isReadOnly() ) {
                    this.publish('error', {type: ErrorTopic.READ_ONLY_TOPIC, topicName: topicName});    
                } else {
                    topic.publish(topicData,action);
                }
            }
        },

        /**
        Applies bindings betweeen two *Topics*.
        
        @method bindTopics
        @param {String} topicAName topicA name
        @param {String} topicBName topicB name      
        @param {Object} topicMapping mapping data
        **/
        bindTopics: function(topicAName, topicBName, topicMapping) {
            var unregisteredTopic = false;
            _.each([topicAName, topicBName], function(topicName) {
                if ( !this.isRegistered(topicName) ) {
                    this.publish('error', {type: ErrorTopic.UNREGISTERED_TOPIC, topicName: topicName});             
                    unregisteredTopic = true;
                }
            },this);

            if (unregisteredTopic) {
                return;
            }

            var topicA = this._getTopic(topicAName);
            var topicB = this._getTopic(topicBName);

            if ( topicMapping && topicMapping.bindings ) {

                this.subscribe(topicAName, {
                    handler: function(data) {
                        var _data = data.changedAttributes;
                        var mapper = topicMapping.aToB ? topicMapping.aToB : topicMapper;
                        this.publish(topicBName, mapper(_data, topicMapping.bindings));
                    },
                    actions: ['change'],
                    silent: true,
                    context: this
                });
                this.subscribe(topicBName, {
                    handler: function(data) {       
                        var _data = data.changedAttributes;
                        var mapper = topicMapping.bToA ? topicMapping.bToA : topicMapper;
                        this.publish(topicAName, mapper(_data, _.invert(topicMapping.bindings)));
                    },
                    actions: ['change'],                    
                    silent: true,
                    context: this
                });
            }
        },

        /**
        Resets *Hub*. Removes all registered *Topics*.
        
        @method reset
        **/
        reset: function() {
            _.each(_.keys(this._topics), function(topicName) {
                this._removeTopic(topicName);
            }, this);
            this._initialize();
        }

    }, Backbone.Events);

    var topicMapper = function(data, mapping) {
        var _data = {};
        for (var prop in data) {
            if (mapping[prop]) {
                _data[mapping[prop]] = data[prop];
            }
        }
        return _data;                   
    };

    return new BusinessWidgetHub();

});
/**
Empty implementation intended for extension by the application.

The usage is to create a class that returns an object with methods, where each method is a *FlowManager*-ready 
condition function. That is to say - it receives, **in closure**, the `options` configuraiton object that *RulesAggregator*
receives upon instantiation and, based on the data returns `true`, `false` or alternative target ID (which is the ID of the
step in flow configuration JSON).

*RulesAggregator* (or multiple) is provided as configuration option to the {{#crossLink "Lightsaber.Core.Router"}}{{/crossLink}}:

```javascript
var router = new Lightsaber.Core.Router({
    routes: {
        'mainpage': 'index.html',
        ...
    },
    flows: flows,
    rulesAggregators: {
        'aggregator': CustomRulesAggregator,
        'default': MyRulesAggregator
    }
});
```

Example of a custom *RulesAggregator* (as *RequireJS* module, in this case), using the passed step configuration object and (by including
it in a closure) initial configuration passed to the *RulesAggregator* constructor:

```javascript
define([
    'underscore'
], function(_) {
    var CustomRulesAggregator = function(options) {
        return {
            flowCondition: function(stepConfig) {
                var result = false;
                
                if(options.vm.get('test') === stepConfig.id) {
                    result = true;
                }

                return result;
            }
        };
    };

    return CustomRulesAggregator;    
});
```

> **Note** that each function also receives step (on which the work is being "done"), augmented with *FlowManager* state, as its only parameter.

@class RulesAggregator
@namespace Lightsaber.Core
@module Lightsaber.Core
@extends Object

@since 9.0.1

@requires underscore
@requires Lightsaber.Utils
@requires Lightsaber.Core.RulesAggregator

@constructor
@param {Object} [options] configuration object, currently disregarded (since this is an empty implementation)

**/
define('src/core/controller/RulesAggregator',[
    'underscore', 
    'src/core/util/Utils'
], function(_, Utils) {

	var RulesAggregator = function(options) {
		return {
		};
	};

	return RulesAggregator;
	
});
/**
<em>Flow RulesExecutor</em> - executes rules defined in flow configuration JSON, by using functions from defined <em>RulesAggregator(s)</em>.

@class RulesExecutor
@namespace Lightsaber.Core
@module Lightsaber.Core
@extends Object

@since 9.0.1


@requires underscore
@requires Lightsaber.Utils
@requires Lightsaber.Core.RulesAggregator

@constructor
@param {Object} [options] configuration object
@param {Array} [options.rulesAggregators] an alternative RulesAggregators instances or constructor functions to those defined on *Router*
**/
define('src/core/controller/RulesExecutor',[
    'underscore', 
    'src/core/util/Utils',
    'src/core/controller/RulesAggregator'
], function(_, Utils, RulesAggregator) {

	var RulesExecutor = function(options) {	
		var rulesAggregators = [];
		
		if (options.rulesAggregators) {
			for (var i = 0; i < options.rulesAggregators.length; i++) {
				rulesAggregators.push(new options.rulesAggregators[i](options));
			};
		} else {
			rulesAggregators = [new RulesAggregator(options)];
		}

		/**
		Pluggable array of classes that contain methods to be used by the *RulesExecutor* to evaluate rules.

		@property {Array} rulesAggregators 
		**/
		this.rulesAggregators = rulesAggregators;

		/**
		Main execution method.

		Method goes over all rules of the provided step and evaluates them

		@method execute
		@param {Object} actionConfig augmented action configuration for which the rules are evaluated
		**/
		this.execute = function(actionConfig, step) {
			var rules, nextStepConfig = actionConfig;
			if(actionConfig.rules) {
				rules = actionConfig.rules;
				if(rules && rules.length > 0) {
					for (var i = 0; i < rules.length; i++) {
						var evaluationResult = this._evaluateRule(rules[i], actionConfig, step);
						if(typeof evaluationResult === 'string') {
							nextStepConfig = {
								target: evaluationResult
							};
						} else if (typeof evaluationResult === 'object'){
							nextStepConfig = evaluationResult;
						} else {
							if(evaluationResult && rules[i].target) {
								nextStepConfig = rules[i];
								break;
							} else if((evaluationResult === false) && !_.isUndefined(rules[i].onFalse)) {
								if(rules[i].onFalse === '') {
									nextStepConfig = {};
								} else {
									nextStepConfig = {
										target: rules[i].onFalse
									};
								}							
							}
						}
					};
				}
			}

			return nextStepConfig;
		};

		/**
		Main execution method.

		Method goes over all aggregators and evaluates the rule on the first *RulesAggregator* that has it.

		@method _evaluateRule
		@protected
		@param {Object} rule rule to be evaluated
		@param {Object} actionConfig augmented step configuration for which the rules are evaluated
		**/
		this._evaluateRule = function(rule, actionConfig, step) {
			var result, rulesAggregator;

			if(rule.condition) {
				result = this._evaluateRuleCondition(rule.condition);
			}
			else if(rule.conditionFunction) {
				for (var i = 0; i < this.rulesAggregators.length; i++) {
					rulesAggregator = this.rulesAggregators[i];
					if(rulesAggregator[rule.conditionFunction]) {
						result = rulesAggregator[rule.conditionFunction](actionConfig, step);
						break;
					}
				};
			}

			return result;
		};

		this._evaluateRuleCondition = function(condition) {
			return condition; // temporary
		};
	};

	return RulesExecutor;

});
/**
<em>FlowManager</em> component - not intended to be used directly. Used internally by <em>Router</em>.

The main purpose of the *FlowManager* component is to manage the internal navigational state and execute actions as they are
defined in flows configuration JSON object.

@class Lightsaber.Core.FlowManager
@namespace Lightsaber.Core
@module Lightsaber.Core
@extends Object

@requires jQuery
@requires Underscore
@requires Backbone
@requires Lightsaber.Utils
@requires Lightsaber.StorageUtil
@requires Lightsaber.Core.RulesExecutor
@requires Lightsaber.Core.ViewModel
@requires Lightsaber.Core.LocalStorageDataSource
@requires Lightsaber.Core.Model

@private

@constructor
@param {Object} [options] *FlowManager* main configuration object
@param {Object} [options.router] *Router* reference

**/
define('src/core/controller/FlowManager',[
    'jquery', 
    'underscore', 
    'backbone', 
    'src/core/util/Utils', 
    'src/core/util/StorageUtil',
    'src/core/controller/RulesExecutor',
    'src/core/viewModel/ViewModel',
    'src/core/dataSource/LocalStorageDataSource',
    'src/core/model/Model'
], function($, _, Backbone, Utils, StorageUtil, RulesExecutor, ViewModel, LocalStorageDataSource, Model) {

    var FlowManager = function(options) {   
        return {
            FLOW_NAMESPACE: '_flow',
            FLOW_CONFIG: /(.*?)(\[)(.*?)(\])(.*)/,
            MATCH_PATTERN: 3,
            REPLACE_PATTERN: '$3',
            FLOW_MANAGER_ID: 'flowmanager',
            vm : new ViewModel(),

            router: options.router,
            options: options,
            targetAttribute: options.targetAttribute || 'url',

            /**
            Resets (cleans) registered flows, to allow re-registration of new ones.

            @method resetFlows
            **/
            resetFlows: function() {
                this.flowsMap = null;
                this.flowPathConfig = null;
                this.currentPosition = null;
            },

            /**
            Registers flow in the *FlowManager*.
    
            Flow configuration object has structure that **may** contain the following (where `url` and `el` are
            replaced by only `el` when on *Mobile*) :
   
            @method registerFlow
            @param {Object} flow flow configuration object
            @param {String} flow.id ID of the flow - must be **unique withing application**
            @param {Array} flow.actions array of flow-level actions, with structure similar to:

            ```json
            "actions": {                    
                "start": "step1",           
                "cancel": {                 
                    "target": "dashboard",  
                    "rules": [              
                        {
                            "conditionFunction": "<name of the function"
                            "target": "home"                       
                        },
                        ...
                    ]
                }           
            }
            ```

            > For more information and extensive examples, please see *FlowManager Guide* in the *Docs* section. 

            @param {Boolean} [flow.external=false] whether the flow is external (uses "entire" HTML pages or 
            only fragments inside one)

            **/
            registerFlow: function(flow) {
                var targetAttribute = flow.targetAttribute || this.targetAttribute;
                
                this._createFlowsMap(flow);
                this._initFlowState(flow);
                this._createRouteObject(flow);
            },

            /**
            Creates flows map for faster access by flow ID.

            @method _createFlowsMap
            @private
            @param {Object} flow flow configuration object
            **/
            _createFlowsMap: function(flow) {
                var step;

                this.flowsMap = this.flowsMap || {};
                this.flowsMap[flow.id] = this.flowsMap[flow.id] || {};

                for(var i = 0; i < flow.steps.length; i++) {
                    step = flow.steps[i];
                    this.flowsMap[flow.id] = flow;
                    this.flowsMap[flow.id].stepsMap = this.flowsMap[flow.id].stepsMap || {};
                    this.flowsMap[flow.id].stepsMap[step.id] = step;
                }
            },

            /**
            Initializes current flow internal (to *FlowManager*) state. Resets paths, current flow position etc.

            @method _initFlowState
            @private
            @param {Object} flow flow configuration object
            **/
            _initFlowState: function(flow) {
                var action = 'start', step = this.flowsMap[flow.id], target;

                this.flowPathConfig = this.flowPathConfig || {};
                this.flowPathConfig[flow.id] = this.flowPathConfig[flow.id] || {};
                this.flowPathConfig[flow.id].steps = this.flowPathConfig[flow.id].steps || [];

                while(true) {
                    target = step.actions[action];
                    action = 'next';
                    if(target) {
                        if(typeof target === 'string') {
                            step = this.flowsMap[flow.id].stepsMap[target];
                        } else if(typeof target === 'object') {
                            step = this.flowsMap[flow.id].stepsMap[target.target]
                        }                   
                        this.flowPathConfig[flow.id].steps.push(step);
                    } else {
                        break;
                    }
                }
            },

            /**
            Creates route object, object that contains all the necessary information to actually "navigate".

            @method _createRouteObject
            @private
            @param {Object} flow flow configuration object
            **/
            _createRouteObject: function(flow) {
                var routeObject;

                if($.mobile) {
                	var routeObject;

                	if(flow.external) {
                		routeObject = {
                			handler: (function(flow, context){
                				return function(route, routeObject, options, targetID) {
                					routeObject.path = context.flowsMap[flow.id].stepsMap[targetID][context.flowsMap[flow.id].targetAttribute];
                				};
                			}(flow, this))
                		};
                		this.router.registerSingleRoute(flow.id + this.flowsMap[flow.id].separator + ':step', routeObject, this.router.options);
                	}
                } else {
	                if(flow.external) {
	                    routeObject = {
	                        handler: (function(flow, context){
	                            return function(route, routeObject, options, targetID) {
	                                routeObject.path = context.flowsMap[flow.id].stepsMap[targetID][context.flowsMap[flow.id].targetAttribute];
	                                if(options.queryParams) {
	                                    if($.mobile) {
	                                        routeObject.path = '?' + options.queryParams + routeObject.path;
	                                    }   
	                                    else {
	                                        routeObject.path += '?' + options.queryParams;
	                                    }
	                                }
	                            };
	                        }(flow, this))
	                    };
	                    this.router.registerSingleRoute(flow.id + '/:step', routeObject, this.router.options);
	                }
	            }
            },

            /**
            Main "navigation" method - augments navigation.

            @method _gotoStep
            @private
            @param {Object} actionConfig combined flow configuration along with augmented information on actions
            @param {Boolean} start whether the action is "start"
            @param {Boolean} replace whether the navigation, where applicable, should replace the previous (originating) entry
            in browser's history
            **/
            _gotoStep: function(actionConfig, start, replace) {
                var flow, params, separator;

                if($.mobile) {
                	separator = '_';
                } else {
                	separator = '/';
                }

                var currentPosition = this._getPosition();

                if(start || currentPosition) {
                    params = {
                        queryParams: '[' + actionConfig.flowID + '/' + actionConfig.targetID + ']',
                        fragment: actionConfig.fragment
                    };
                }

                if(actionConfig.type) {
                    if(actionConfig.type === 'navigate') {
                        if(start && actionConfig.start !== false) {
                            this.router.navigate(actionConfig.flowID + separator + actionConfig.targetID, params);
                        } else {
                            this.resetFlowData();
                            this.router.navigate(actionConfig.targetID, params);
                        }
                    } else if(actionConfig.type === 'load') {
                        actionConfig.context.load(actionConfig.targetID, {requested: true});
                    } else {
                        actionConfig.context.load('[' + actionConfig.flowID + '/' + actionConfig.targetID + ']', {requested: true});
                    }
                } else {
                    flow = this.flowsMap[actionConfig.flowID];
                    if(flow && !flow.external) {
                        actionConfig.context.load('[' + actionConfig.flowID + '/' + actionConfig.targetID + ']', {requested: true, replace: replace});
                    } else {
                        this.router.navigate(actionConfig.flowID + separator + actionConfig.targetID, params);
                    }
                }

                if($.mobile) {
                	if(!actionConfig.cleanupStep) {
						this._setPosition(actionConfig);
					}
                }

                if(this.flowPathConfig && this.flowPathConfig[actionConfig.flowID]) {
                    this.flowPathConfig[actionConfig.flowID].currentPosition = actionConfig;
                }
            },

            /**
            Removes parameters from the location hash.

            @method _removeParameter
            @private
            @param {String} url URL
            @param {String} parameter parameter
            **/
            _removeParameter: function(url, parameter)
            {
                var urlparts= url.split('?');

                if (urlparts.length>=2)
                {
                    var urlBase=urlparts.shift(); //get first part, and remove from array
                    var queryString=urlparts.join("?"); //join it back up

                    var prefix = encodeURIComponent(parameter)+'=';
                    var pars = queryString.split(/[&;]/g);
                    for (var i= pars.length; i-->0;)               //reverse iteration as may be destructive
                    if (pars[i].lastIndexOf(prefix, 0)!==-1) {   //idiom for string.startsWith
                        pars.splice(i, 1);
                    }
                    url = urlBase+'?'+pars.join('&');
                }
                
                return url;
            },

            /**
            Main "start flow" method.

            @method _gotoStep
            @private
            @param {Object} actionConfig augmented flow configuration object
            @param {Boolean} replace whether the navigated step should replace originating one (including page that invokes `startFlow`)
            in browser's history
            **/
            _startFlow: function(actionConfig, replace) {
                this._gotoStep(actionConfig, true, replace);
            },

            /**
            Main "navigation" method. Invoked by *Module* / *Application* to augment the flow configuration with meta-information
            about the step and allow navigation.

            @method executeAction
            @private
            @param {String} action action to be taken
            @param {Object} config configuration
            @param {Lightsaber.Core.ViewModel} vm flow's *ViewModel*
            @param {Object} context *Module* / *Application*, depending on calling context
            @param {Boolean} replace whether the navigated step should replace originating one (including page that invokes `startFlow`)
            in browser's history
            **/

            /**
            Triggered **on the flow's ViewModel** when a step is managed. Accordion to the event that the step is
            used in ('next', 'prev' etc.).

            @event flow:<event>
            @param {Object} stepConfig step's configuration object (as defined in flows JSON)
            @param {Object} flowConfig flow configuration
            @param {Object} context navigation context
            @param {Object} options additional configuration options (like `replace`)
            **/
            executeAction: function(action, config, context, options) {
                var actionConfig, replace, vm;

                if(!_.isUndefined(options)) {
                    vm = options.viewModel;
                    replace = options.replace;
                }
                
                this.vm = vm || this.vm || new ViewModel();                      

                if(action) {
                    actionConfig = this._decideAction(action, config, options);  
                    if(!actionConfig || _.isUndefined(actionConfig.targetID)) {
                        return;
                    }
                    actionConfig.context = context;             
                    this[actionConfig.action].call(this, actionConfig, replace);                                        
                    this.vm.trigger('flow:' + actionConfig.event, actionConfig, this.flowPathConfig);
                }
            },

            /**
            Logical method to decide upon real target to a requested action - based on condition functions.

            @method _decideAction
            @private
            @param {String} action action to be taken
            @param {Object} config configuration
            @param {Object} options additional configuration options (like `step` - from which to start)
            **/
            _decideAction: function(action, config, options) {
                var realTarget, stepConfig, flowConfig, currentPosition, actionConfig = {}, step;

                currentPosition = this._getPosition();

                if(currentPosition) {
                    var stepConfig = this.flowsMap[currentPosition.flowID].stepsMap[currentPosition.targetID];
                    var target;

                    if(stepConfig.actions && stepConfig.actions[action]) {
                        target = stepConfig.actions[action];
                    } else if(this.flowsMap[currentPosition.flowID].actions && this.flowsMap[currentPosition.flowID].actions[action]) {
                        target = this.flowsMap[currentPosition.flowID].actions[action];
                    }
                    flowConfig = this.flowsMap[currentPosition.flowID];
                } else {        
                    if(!config) {
                        return;
                    }
                    stepConfig = this.flowsMap[config].stepsMap[action];
                    flowConfig = this.flowsMap[config];
                }
                
                switch(action) {
                    case 'next':
                        actionConfig.event = 'next';
                        actionConfig.action = '_gotoStep';
                        realTarget = this._decideRealTarget(target, flowConfig);
                        actionConfig.targetID = realTarget.target;
                        actionConfig.type = realTarget.type;
                        actionConfig.flowID = currentPosition.flowID;

                        break;
                    case 'prev':
                        actionConfig.event = 'prev';
                        actionConfig.action = '_gotoStep';
                        realTarget = this._decideRealTarget(target, flowConfig);
                        actionConfig.targetID = realTarget.target;
                        actionConfig.type = realTarget.type;
                        actionConfig.flowID = currentPosition.flowID;

                        break;
                    case 'start':
                        if(options) {
                            step = options.step;
                        }

                        actionConfig.event = 'start';
                        actionConfig.action = '_startFlow';
                        actionConfig.flowID = config;
                        if(this.flowsMap[actionConfig.flowID].actions) {
                            target = step || this.flowsMap[actionConfig.flowID].actions[action];
                        }
                        realTarget = this._decideRealTarget(target, flowConfig);
                        actionConfig.targetID = realTarget.target;
                        actionConfig.type = realTarget.type;
                        actionConfig.start = realTarget.start;
                        actionConfig.reset = realTarget.reset;
                        
                        if(!actionConfig.targetID) {                            
                            actionConfig.targetID = this.flowsMap[actionConfig.flowID].steps[0].id;
                        }

                        this.resetFlowData(actionConfig.reset);

                        break;
                    case 'goto':
                        actionConfig.event = 'goto';
                        actionConfig.action = '_gotoStep';

                        if(flowConfig.actions && flowConfig.actions['goto'] && flowConfig.actions['goto'].length > 0) {
                            target = this._mergetGotoTargets(flowConfig.actions['goto'], target);
                        }

                        realTarget = this._decideRealTarget(target, flowConfig, config);
                        actionConfig.targetID = realTarget.target;
                        actionConfig.type = realTarget.type;
                        actionConfig.flowID = currentPosition.flowID;

                        break;
                    case 'finish':
                        actionConfig.event = 'finish';
                        actionConfig.action = '_gotoStep';
                        actionConfig.flowID = currentPosition.flowID;
                        if(this.flowsMap[actionConfig.flowID].actions) {
                            target = this.flowsMap[actionConfig.flowID].actions[action];
                        }
                        realTarget = this._decideRealTarget(target, flowConfig);
                        actionConfig.targetID = realTarget.target;
                        actionConfig.type = realTarget.type;
                        actionConfig.reset = realTarget.reset;

						if($.mobile) {
							actionConfig.cleanupStep = true;
						}

                        this.resetFlowData(actionConfig.reset);

                        break;
                    case 'cancel':
                        actionConfig.event = 'cancel';
                        actionConfig.action = '_gotoStep';
                        actionConfig.flowID = currentPosition.flowID;
                        if(this.flowsMap[actionConfig.flowID].actions) {
                            target = this.flowsMap[actionConfig.flowID].actions[action];
                        }
                        realTarget = this._decideRealTarget(target, flowConfig);
                        actionConfig.targetID = realTarget.target;
                        actionConfig.type = realTarget.type;
                        actionConfig.reset = realTarget.reset;

						if($.mobile) {
							actionConfig.cleanupStep = true;
						}
						
                        this.resetFlowData(actionConfig.reset);

                        break;
                    default: 
                        actionConfig.action = action;
                        actionConfig.event = action;
                        realTarget = this._decideRealTarget(target, flowConfig);
                        actionConfig.targetID = realTarget.target;
                        actionConfig.type = realTarget.type;                        
                }

                if(actionConfig && options && options.fragment){
                    actionConfig.fragment = options.fragment
                }

                return actionConfig;
            },

            /**
            @method _mergetGotoTargets
            @private
            **/
            _mergetGotoTargets: function(first, second) {
                var union = _.union(second, first); // order is important

                var result = _.uniq(union, false, function(item) { 
                    return item.target; 
                });

                return result;
            },

            /**
            Decides upon "real" target for the provided action and step by invoking *RulesExecutor*.

            @method _decideRealTarget
            @private
            @param {String|Object} target target
            @param {Object} flowConfig flow configuration
            @param {String} step step for which to decide
            **/
            _decideRealTarget: function(target, flowConfig, step) {
                var realTarget = {};

                if(!step) {
                    if(typeof target === 'string' || !target) {
                        realTarget.target = target;
                    } if(typeof target === 'object') {
                        realTarget = this._executeRule(target, flowConfig);
                    }
                } else if(_.isArray(target)) { // goto action has been requested
                    for (var i = 0; i < target.length; i++) {
                        if(target[i].target === step) {
                            realTarget = this._executeRule(target[i], flowConfig, step);
                            break;
                        }
                    };
                }  else {
                    realTarget = this._executeRule(target, flowConfig, step);
                }         

                return realTarget;
            },

            /**
            Executes a rule by invoking *RulesExecutor*.

            @method _executeRule
            @private
            @param {Object} actionConfig augmented step configuration
            @param {Object} flowConfig flow configuration
            **/
            _executeRule: function(actionConfig, flowConfig, step) {
                this._initRulesExecutor(flowConfig); // lazy initialization - only the first time and not before
                return this.executor.execute(actionConfig, step);
            },

            /**
            Initializes *RulesExecutor*.

            @method _initRulesExecutor
            @private
            @param {Object} flowConfig flow configuration
            **/
            _initRulesExecutor: function(flowConfig) {
                var executorOptions;
                var rulesAggregators;
                var availableRulesAggregator;
                var combinedRulesAggregator;

                if(flowConfig && flowConfig.rulesAggregator && this.options.rulesAggregators) {
                    if(_.isArray(flowConfig.rulesAggregator)) { // array of aggregators
                        rulesAggregators = [];
                        for (var i = 0; i < flowConfig.rulesAggregator.length; i++) {
                            availableRulesAggregator = this.options.rulesAggregators[flowConfig.rulesAggregator[i]];
                            if(availableRulesAggregator) {
                                rulesAggregators.push(availableRulesAggregator);
                            }
                        };
                    } else {
                        rulesAggregators = [this.options.rulesAggregators[flowConfig.rulesAggregator]];
                    }

                    if(!rulesAggregators) {
                        rulesAggregators = [this.options.rulesAggregators['default']];
                    }
                }

                if(!this.executor && this.options) {
                    if(_.isArray(rulesAggregators)) {
                        combinedRulesAggregator = rulesAggregators;
                    } else if(this.options.rulesAggregator) {
                        combinedRulesAggregator = [this.options.rulesAggregator]
                    }

                    executorOptions = {
                        rulesAggregators: combinedRulesAggregator,
                        flowManager: this
                    };

                    if(this.options.rulesExecutor) {
                        if(typeof this.options.rulesExecutor === 'object') {
                            this.executor = this.options.rulesExecutor;
                        }
                        else {
                            this.executor = new this.options.rulesExecutor(executorOptions);
                        }
                    } 
                    else {
                        this.executor = new RulesExecutor(executorOptions);
                    }
                }
            },

            /**
            Resets current flow position.

            @method _resetPosition
            @private
            **/
			_resetPosition: function() {
				this.currentPosition = null;
			},

            /**
            Sets current flow position.

            @method _setPosition
            @private
            **/
			_setPosition: function(actionConfig) {
				this.currentPosition = {targetID: actionConfig.targetID, flowID: actionConfig.flowID};
			},

            /**
            Returns current flow position.

            @method _getPosition
            @private
            **/
            _getPosition: function() {
                var currentPosition, configParts;
                if($.mobile) {
                    currentPosition = this.currentPosition;
                	if(!currentPosition) {
                		configParts = this.router.getHash().split('_');

                		if(configParts && configParts.length === 2) {
                			currentPosition = {flowID: configParts[0], targetID: configParts[1]};
                		}
                	}
                } else {
            	    if(!currentPosition) {
                        var extractConfigParts = function (url){
                            var match = url.match(this.FLOW_CONFIG);
                            if (match && match.length > this.MATCH_PATTERN){
                                return match[this.MATCH_PATTERN].split('/');
                            }
                            return null;
                        }.bind(this);
                        configParts = extractConfigParts(this.router.getDecodedHash());
                        if(!configParts || configParts.length < 2) {
                            configParts = extractConfigParts(this.router.getQueryParams());
                        }
                        
                        if(configParts && configParts.length === 2) {
                            currentPosition = {flowID: configParts[0], targetID: configParts[1]};
                        }
                    }                 	
                }
                
                return currentPosition;
            },

            /**
            Returns current flow position.

            @method getPosition
            **/
            getPosition: function() {
                return this._getPosition();
            },

            /**
            Creates internal Model for flow state saving to the local storage.

            @method _createModel
            @private
            **/
            _createModel: function() {
                if(!this.model) {
                    this.model = new Model(null, {
                        url: '/uxf'
                    });
                    
                    var storageDS = new LocalStorageDataSource();
                    storageDS.storage = StorageUtil.getStorage('session');
                    this.model.setDataSource(storageDS);
                }
            },

            /**
            Returns current flow data for the provided key.

            @method getFlowData
            @param {String} key key
            @return {...} stored flow data for the provided key
            **/
            getFlowData: function(key) {
                var result, currentPosition;

                if(this.vm) {
                this._createModel();

                result = this.vm.get(key);

                if(!result) {
                    this.model.fetch({id:this.FLOW_MANAGER_ID});
                    result = this.model.get(key);

                    if(result) {
                        this.vm.set('key', result, {silent: true});
                    }
                }
                }
                        
                return result;
            },

            /**
            Resets flow data.

            @method resetFlowData
            @param {Boolean} [resetViewModel=false] whether the flow's *ViewModel* should be reset as well
            **/
            resetFlowData: function(resetViewModel) {
				$.mobile && this._resetPosition();
                if(resetViewModel) {
                    this.vm.clear();
                }
                if(this.model) {
                    this.model.destroy();
                    this.model.clear();
                }
                else {
                    this._createModel();
                }
            },

            /**
            Sets flow data by the provided key.

            @method setFlowData
            @param {String} key key
            @param {...} value data to store
            @param {Boolean} [silent=false] whether to trigger the event on the flow's *ViewModel*
            **/
            setFlowData: function(key, value, silent) {
                var currentPosition;

                this.vm = this.vm || new ViewModel();
                this._createModel();

                this.vm.set('key', value, {silent: !silent});
                
                this.model.set(key, value);             
                this.model.save( undefined, {id: this.FLOW_MANAGER_ID});
            },

            /**
            Deletes flow data by the provided key.

            @method deleteFlowData
            @param {String} key key
            **/
            deleteFlowData: function(key) {
                this._createModel();
                this.model.unset(key);              
                this.model.save( undefined, {id: this.FLOW_MANAGER_ID});
            },

            /**
            Returns state of the current flow.

            @method getFlowState
            @param {String} flowID flow's ID
            @return {Object} augmented flow configuration
            **/
            getFlowState: function(flowID) {
                var result = this.flowPathConfig;
                if(flowID) {
                    result = result[flowID];
                }
                
                return result;
            },

            /**
            Sets flow's *ViewModel*.

            @method setViewModel
            @param {Lightsaber.Core.ViewModel} viewModel *ViewModel* to use as flow's *ViewModel*
            **/
            setViewModel: function(viewModel) {
                this.vm = viewModel;
                this._createModel();
            },

            /**
            Returns flow's *ViewModel*.

            @method getViewModel
            @retun {Lightsaber.Core.ViewModel} flow's *ViewModel*
            **/
            getViewModel: function() {
                this._createModel();
                return this.vm;
            },

            /**
            Returns flow's configuration.

            @method getFlowConfig
            @param {String} flowID flow's ID
            @return {Object} flow configuration
            **/
            getFlowConfig: function(flowID) {
                return this.flowsMap[flowID];
            },

            /**
            Triggered **on the flow's ViewModel** when a step is marked.

            @event flow:step:mark
            @param {Object} stepConfig step's configuration object (as defined in flows JSON)
            @param {Object|String} mark mark
            **/
            markStepAs: function(mark, stepConfig) {
                this.vm.trigger('flow:step:mark', stepConfig, mark);
            },

            /**
            Triggered **on the flow's ViewModel** when a step is un-marked.

            @event flow:step:unmark
            @param {Object} stepConfig step's configuration object (as defined in flows JSON)
            @param {Object|String} mark mark
            **/
            unmarkStepAs: function(mark, stepConfig) {
                this.vm.trigger('flow:step:unmark', stepConfig, mark);
            }
        };
    };

    FlowManager.storage = StorageUtil.getStorage('session');    
    FlowManager.extend = Utils.extend;

    return FlowManager;
});
/**
Core <em>Router</em> component, responsible for <em>page-level</em> navigation.

*Page-level* navigation is concept that refers to one of the following:

1. On *Mobile* - navigation between *JQM* logical pages (where the page is not a "real" physical HTML file, rather
a part of it)
2. On *Mobile* **and** *Web* - navigation between physical HTML pages

For example (in this case, on *Web* touch-point), the following defines a set of routes:

```javascript
new Lightsaber.Core.Router({
    routes: {
        route1: 'page1.html',
        route2: 'page2.html'
    }
});
```

where each route has an ID (`route1`) that will be used when invoking navigation programmatically using `this.navigate('route1')` from any {{#crossLink "Lightsaber.Core.Module"}}{{/crossLink}} extending component.

There are additional ways routes may be defined, to provide finer control of the way the navigation is done:

```javascript
new Lightsaber.Core.Router({
    routes: {
        'page/:id/*someparam': 'page.html'
    }
});
```

where `:id` and `*someparam` are called path parameters and are transferred to the handling *Module* on its configuration options to {{#crossLink "Lightsaber.Core.Module/init:method"}}{{/crossLink}} method. The difference between `:param` and `*param` is greediness - `:param` is non-greedy and `*param` is (and as such is normally last in the path).

> **Note** that the ID to be used in {{#crossLink "Lightsaber.Core.Application"}}{{/crossLink}} to
> register corresponding (to the route) *Module* is exactly as defined: `'page/:id/*someparam'`.

In addition to standard, short, definition of routes - there are several more explicit options:

```javascript
new Lightsaber.Core.Router({
    routes: {
        'commonPage/:param/*anotherparam': 'commonPageHandler'
    },

    commonPage2Handler: function(route, routeObject, routeConfig) {
        console.log(route, routeObject, routeConfig);
    }
});
```

where `commonPage2Handler` is a handler function that is passed the control to the navigation.

The parameters to the handler function are: 

1. `route` - the actual route, with real values for path parameters
2. `routeObject` - the original route defintion as it is in `routes` object on the *Router*
3. `routeConfig` - additional configuration that is used by the router and contains two main settings: `external` - `true/`false` and `trigger` - `true`/`false` that control whether the navigation is external (full HTML page) and whether to notify listeners, respectively.

This allows to change the **original** route to an alternative one or perform other operations, **before** the actual navigation happens.

> **Note** that returning a **truthy** value from a handler function **aborts** the navigation.
> 
> The idea is that function that doesn't return value (as a oversight on developer's part) - in fact considered to return `undefined` - which should not (as this is a more common case) stop the navigation from happening, thus preventing a slew of hard-to-find bugs.

Even more verbose method of route definition looks like this:

```javascript
new Lightsaber.Core.Router({
    routes: {
        'commonPage/:param/*anotherparam': {
            handler: 'commonPage2Handler',
            path: 'commonPage.html',
            external: true,
            trigger: false
        }
    },

    commonPage2Handler: function(route, routeObject, routeConfig) {
        console.log(route, routeObject, routeConfig);
    }
});
```

Other options include `flows`, which is set to the flows' configuration JavaScript object and `rulesAggregators` hash that defines {{#crossLink "Lightsaber.Core.RulesAggregator"}}{{/crossLink}} aggregators.

For more information see *Application and Navigation* and *FlowManager* guides in *Docs* section.

@class Lightsaber.Core.Router
@namespace Lightsaber.Core
@module Lightsaber.Core
@extends Backbone.Router

@requires jquery
@requires underscore
@requires backbone
@requires Lightsaber.Utils
@requires Lightsaber.StorageUtil
@requires Lightsaber.Core.FlowManager 

@examples none
@guides ["Core Concepts/Application and Navigation", "Core Concepts/FlowManager Guide"]

@param {Object} [options] the <em>Router</em> configuration object
@param {Object} [options.routes] routes hash, where each route is defined as a <code>key</code> - <code>value</code> pair; for more details see explanation above 
@param {Object} [options.flows] flows' configuration object
@param {Object} [options.rulesAggregators] rules aggregators
**/
define('src/core/controller/Router',[
    'jquery', 
    'underscore', 
    'backbone', 
    'src/core/util/Utils', 
    'src/core/util/StorageUtil',
    'src/core/controller/FlowManager'
], function($, _, Backbone, Utils, StorageUtil, FlowManager) {
    var Router = Backbone.Router.extend({   
        
        /**
        Main-entry method for the *Router*.

        The method does the following:

        * creates and stores a default *key* to use for *local storage* operations
        * initializes *FlowManager* (see {{#crossLink "Lightsaber.Core.Router"}}contructor{{/crossLink}} and {{#crossLink "Lightsaber.Core.FlowManager"}}{{/crossLink}} for more information)
        * initializes `configuration` object used by *Router*
        * registers the provided *routes*

        @method initialize
        @protected
        @param {Object} options configuration options received by *Router's* constructor
        **/
        initialize : function(options) {
            this.key = _.uniqueId('lsKey_');
            this._initFlowManager(options);
            this._init(options); // deep-copies options into this.configuration
            this.registerRoutes(this.configuration.routes, options);
        },

        /**
        Initializes *Router* configuration.

        @method _init
        @private
        @param {Object} options configuration options received by *Router's* constructor
        **/
        _init : function(options) {
            this.configuration = $.extend(true, {}, options);           
            this.configuration.routes = this.configuration.routes || {};
        },

        /**
        Initializes *FlowManager*.

        The *FlowManager* class that is going to be used is the default {{#crossLink "Lightsaber.Core.FlowManager"}}{{/crossLink}}, unless `options` configuration parameter contains an alternative one, which is used in that case.        

        @method _initFlowManager
        @protected
        @param {Object} [options] Router's configuration object (the same passed to Router's constructor) (see {{#crossLink "Lightsaber.Core.Router"}}constructor{{/crossLink}})
        **/
        _initFlowManager: function(options) {
            var flowManagerOptions;

            if(!this.fm) {
                flowManagerOptions = {
                    router: this
                };

                if(options && options.rulesExecutor) {
                    flowManagerOptions.rulesExecutor = options.rulesExecutor;
                } 
                
                if(options && options.rulesAggregators) {
                    flowManagerOptions.rulesAggregators = options.rulesAggregators;
                }

                if(options && options.storageType) {
                    flowManagerOptions.storageType = options.storageType;
                }

                if(options && options.flowManager) {
                    if(typeof options.flowManager === 'object') {
                        this.fm = options.flowManager;
                    }
                    else {
                        this.fm = new options.flowManager(flowManagerOptions);
                    }
                } 
                else {
                    this.fm = new FlowManager(flowManagerOptions);
                }
            }
        },

        /**
        Registers routes (provided in `routes` hash as routes).

        The `routes` hash has the same structure as the one passed to {{#crossLink "Lightsaber.Core.Router"}}constructor{{/crossLink}}.

        @method registerRoutes
        @param {Object} routes routes to be registered
        @param {Object} options *Router's* configuration object
        **/        
        registerRoutes : function(routes, options) {
            var routeObject;
            for (var route in routes) {
                routeObject = routes[route];
                this.registerSingleRoute(route, routeObject, options);
            }
        },

        /**
        Registers single route.

        The `route` object has the same structure as the ones passed to {{#crossLink "Lightsaber.Core.Router"}}constructor{{/crossLink}} as part of `routes` hash.

        `route` is registered by creating a RegEx of its *key* part and adding it to the list of the routes. RegEx helps with future matching of routes.

        @method registerSingleRoute
        @param {Object|String} route route to be registered
        @param {Object} options route's configuration object, as passed to *Router's* configuration
        @param {Object} options *Router's* configuration object
        **/ 
        registerSingleRoute: function(route, routeObject, options) {
            if(typeof routeObject === 'string') { // Function name or path
                if((options[routeObject] && typeof options[routeObject] === 'function') || this[routeObject]) {
                    routeObject = { handler : options[routeObject] || this[routeObject] };
                }
                else {
                    routeObject = { path : routeObject };
                }
            }
            else if(typeof routeObject === 'function') { // Function
                routeObject = { handler : routeObject };
            }
            else { // Object
                
            }
            
            routeObject.handler = ((typeof routeObject.handler === 'string') ? (options[routeObject.handler] || this[routeObject.handler]) : routeObject.handler) || function(){};
            routeObject.regex = this._routeToRegExp(route); 
            
            this.routes[route] = routeObject;
        },
        
        /**
        Executes the provided action.

        Delegates to *FlowManager* implementation that is either:

        * default {{#crossLink "Lightsaber.Core.FlowManager"}}{{/crossLink}},
        * provided by means of *RequireJS* customization (through paths and plugins), or
        * provided as part of configuration object to the *Router*
        
        @method executeAction
        @param {String} action the action to execute
        @param {String|Object|Function|...} [data] the appropriate data for the action that may differ from action to action
        @param {Lightsaber.Core.ViewModel} [vm] the *ViewModel* to use as the *FlowManager's* *ViewModel*, instance of {{#crossLink "Lightsaber.Core.ViewModel"}}{{/crossLink}}
        @param {Object} [context=<executing_module>] context of the `navigate`/`load` call (normally the requesting instance of {{#crossLink "Lightsaber.Core.Module"}}{{/crossLink}})
        @param {Boolean} [options=undefined] {optional parameters, like `replace` - whether or not the }
        **/
        executeAction: function(action, data, context, options) {
            if(this.fm) {
                this.fm.executeAction(action, data, context, options);
            }
        },

        /**
        Navigates using the provided *route*.
        
        *Route* is a logical name for the route as it is defined in *Router's* configuration. Here the retrieval of the parameters from the *route*, decision on the actual route (logical or physical page) to be taken and call to handling function (if defined using `handler` property of the *route* configuration) are done.

        In addition `navigate` allows to pass an arbitrary, serializable, data along with the call. Data will be attempted to be stored on the local storage. The data can be retrieved using {{#crossLink "Lightsaber.Core.Router/getValueObject"}}getValueObject{{/crossLink}} method of the *Router*.

        @method navigate
        @param {String} route the *route* to take
        @param {Object} [config] configuration options for the *route* to use
        @param {Boolean} [config.external] whether the *route* is external ("full-page refresh")
        @param {Boolean} [config.key] key to use in the *local storage* to store data passed through with the `navigate` call
        @param {Boolean} [config.valueObject] data passed through with the `navigate` call
        **/
        navigate : function(route, config) {
            config = config || {};
            
            if($.mobile) {
                config = this._createRouteConfig(config);
            }
            else {
                config = this._createRouteConfig(config, true);
            }
            
            var routeObject = this._getRouteObject(route);      
            
            if(config.valueObject) {
                this._setValueObject(config.key, config.valueObject);
            }
            
            if(routeObject) {
                var external = config.external || routeObject.external;
                var params = this._extractParameters(routeObject.regex, route);
                params.unshift(config); 
                params.unshift(routeObject); 
                params.unshift(route);              
                var abort = routeObject.handler.apply(this, params);  
                
                if(!abort && routeObject.path) {
                    if(external) {
                        if(config.hash)//in order to support navigation with hash provided
                        {
                            routeObject.path = routeObject.path+'#'+config.hash.join('/#!/');
                        }

                        if(config.fragment)//in order to support navigation with hash provided
                        {
                            routeObject.path = routeObject.path + '#' + config.fragment;
                        }
                        
                        // Enable option to disable browser history by setting the replace flag.
                        if(config.replace) {
                            window.location.replace(routeObject.path);
                        } else {
                            window.open(routeObject.path, '_self');
                        }
                    } 
                    else {
                        if(Backbone.history.fragment !== route) {
                            Backbone.Router.prototype.navigate(routeObject.path, config);
                        }
                    }
                }   
            }
            else {
                Backbone.Router.prototype.navigate(route, config);
            }
            this.trigger('route:' + route, params);
        },

              
        /**
        Augments the configuration that is passed to `navigate` with additional properties (whether it is external
        navigation and whether an event should be triggered upon navigation).

        @method _createRouteConfig
        @private
        @param {Object} config configuration that is passed to `navigate` call
        @param {Boolean} trigger indicates whether to trigger navigation event
        @return {Object} augmented configuration object
        **/
        _createRouteConfig : function(config, external) {
            var configuration = $.extend(true, {}, config); 
            
            if(configuration.trigger === undefined) {
                configuration.trigger = true;
            }
            
            configuration.external = external;
            
            return configuration;
        },
        
        /**
        Retrieves configuration object (as it was passed during *routes* registration) based on the provided *route*. 

        The corresponding configuration object is found either by direct match (the provided *route* was registered as is - `mainpage` and `mainpage`) or by matching against computed regex (where the regex is deduced from the *routes* during registration - `mainpage/:param1/*otherparams` and `mainpage/myparam1/myother/params`).

        @method _getRouteObject
        @private
        @param {String} route *route* to find configuration for
        @return {Object} *route's* configuration object
        **/
        _getRouteObject : function(route) {
            var routeObject = this.routes[route], result;
            if(!routeObject) {
                for (var routeID in this.routes) {
                    result = this.routes[routeID];
                    if(result.regex.test(route)) {
                        routeObject = result;
                        break;
                    }
                }
            }
            
            return routeObject;
        },
        
         /**
        Stores the data passed to {{#crossLink "Lightsaber.Core.Router/navigate"}}navigate{{/crossLink}} on the local storage.

        @method _setValueObject
        @protected
        @param {String} [key=this.key] the key, defaults to generic *Router's* key to use for storage
        @param {Object|String} valueObject the value to be stored
        **/
        _setValueObject : function(key, valueObject) {
            var fkey = key || this.key;
            if (valueObject) {
                Router.storage.set(fkey, valueObject);
            }
        },
        
         /**
        Retieves the data stored with the previous call to {{#crossLink "Lightsaber.Core.Router/navigate"}}navigate{{/crossLink}}

        @method getValueObject
        @param {String} [key=this.key] the key, defaults to generic *Router's* key
        @param {Boolean} [remove=undefined] indicates whether the data should be removed after retrieval
        **/
        getValueObject: function(key, remove) {
            var fkey = key || this.key;
            var obj = Router.storage.get(fkey);
            
            if (obj && remove) {
                Router.storage.deleteKey(fkey);
            }

            return obj;
        },

        /**
        Retrieves query parameters string from the `window.location`.

        @method getQueryParams
        @return {String} query parameters string
        **/
        getQueryParams: function() {
            return window.location.search;
        },

        /**
        Retrieves hash from the `window.location`.

        @method getHash
        @return {String} hash string
        **/
        getHash : function() {
            return Backbone.history.getFragment();
        },

        /**
        Retrieves decoded hash from the `window.location`.
        
        @method getDecodedHash
        @callable
        @return {String} decoded hash string
        **/
        getDecodedHash : function() {
            return decodeURIComponent(Backbone.history.getFragment());
        },

        /**
        Retrieves state of the flow by flow's ID.

        @method getFlowState
        @param {String} flowID ID of the flow
        @return {Object} current flow's state
        **/
        getFlowState: function(flowID) {
            return this.fm.getFlowState(flowID);
        },

        /**
        Retrieves current flow's data by the provided *key*.

        @method getFlowData
        @param {String} key key by which to retrive data
        @return {Object | String} current flow's data
        **/
        getFlowData: function(key) {
            return this.fm.getFlowData(key);
        },

        /**
        Set data item (represented by `value`) by the provided *key*.

        @method setFlowData
        @param {String} key key to store the data item under
        @param {Object|String|...} value data item to be stored
        **/
        setFlowData: function(key, value) {
            this.fm.setFlowData(key, value);
        },

        /**
        Removes all stored data items.

        @method resetFlowData
        **/
        resetFlowData: function() {
            this.fm.resetFlowData();
        },

        /**
        Removes data item stored under the provided *key*.

        @method deleteFlowData
        **/
        deleteFlowData: function(key) {
            return this.fm.deleteFlowData(key);
        },

        /**
        Sets the *ViewModel* to be used by the *FlowManager*.

        @method setViewModel
        @param {Lightsaber.Core.ViewModel} viewModel *ViewModel* to be used by the *FlowManager*
        **/
        setViewModel: function(viewModel) {
            this.fm && this.fm.setViewModel(viewModel);
        },

        /**
        Get the *ViewModel* that is used by the *FlowManager*.

        @method getViewModel
        @return {Lightsaber.Core.ViewModel} *ViewModel* to be used by the *FlowManager*
        **/
        getViewModel: function() {
            return this.fm && this.fm.getViewModel();
        },

        /**
        Retrieves *flow* configuration by *flow's* ID.

        @method getFlowConfig
        @param {String} flowID flow ID
        @return {Object} *flow's* ID
        **/
        getFlowConfig: function(flowID) {
            return this.fm && this.fm.getFlowConfig(flowID);
        },

        markStepAs: function(mark, stepConfig) {
            this.fm && this.fm.markStepAs(mark, stepConfig);
        },

        unmarkStepAs: function(mark, stepConfig) {
            this.fm && this.fm.unmarkStepAs(mark, stepConfig);
        }
        
    });
    
    Backbone.History.prototype._updateHash = function(location, fragment, replace) {
        var fragmentParts;

        if(fragment.charAt(0) === '?') {
            fragmentParts = fragment.split('#');
            if (replace) {          
                location.replace(location.toString().replace(/(javascript:|#|\?).*$/, '') + fragmentParts[0] + '#' + fragmentParts[1]);
            } else {
                // location.hash = fragmentParts[0] + '#' + fragmentParts[1];
                location.href = location.toString().replace(/(javascript:|#|\?).*$/, '') + fragmentParts[0] + '#' + fragmentParts[1];
            }
        }
        else {
            if (replace) {          
                location.replace(location.toString().replace(/(javascript:|#).*$/, '') + '#' + fragment);
            } else {
                if ($.mobile) {
                    $.mobile.changePage('#' + fragment);
                } else {
                     location.hash = fragment;
                }
                //location.href = location.toString().replace(/(javascript:|#|\?).*$/, '') + '#' + fragment;
            }
        }
    };

    Router.storage = StorageUtil.getStorage('session');
    
    return Router;
});
/**
 * @class Layout
 * @type Layout
 * @name Layout
 * @memberOf Lightsaber.Core.Logger
 * @description
 * The Lightsaber's Layout class. Base class for Layout
 *
 */
define('src/core/logger/Layout',['underscore'], function(_) {

	var Layout = function() {

		_.extend(Layout.prototype, {

			loggerKey : 'logger',
			timeStampKey : 'timestamp',
			millisecondsKey : 'milliseconds',
			levelKey : 'level',
			messageKey : 'message',
			urlKey : 'url',
			getDataValues : function(loggingEvent, combineMessages) {
				var dataValues = [[this.loggerKey, loggingEvent.logger.name], [this.timeStampKey, loggingEvent.timeStamp], [this.levelKey, loggingEvent.level.name], [this.urlKey, window.location.href], [this.messageKey, combineMessages ? loggingEvent.getCombinedMessages() : loggingEvent.messages]];

				return dataValues;
			},
			format : function(loggingEvent) {
				var formatted = this.format(loggingEvent);
				return formatted;
			}
		});
	};

	return Layout;
}); 
/**
 * @class JsonLayout
 * @type Layout
 * @name JsonLayout
 * @memberOf Lightsaber.Core.Logger
 * @description
 * The Lightsaber's JSONLayout class. A default layout class that will available with logger object.
 * Example:
 * 	ConsoleAppender.setLayout( new myLogger.JsonLayout() );
 *
 */
define('src/core/logger/JSONLayout',['underscore', 'src/core/logger/Layout'], function(_, Layout) {



	var JsonLayout = function(readable, combineMessages) {
		var newLine = '\r\n';
		this.readable = readable;
		this.combineMessages = combineMessages;
		this.batchHeader = this.readable ? '[' + newLine : '[';
		this.batchFooter = this.readable ? ']' + newLine : ']';
		this.batchSeparator = this.readable ? ',' + newLine : ',';
		this.colon = this.readable ? ': ' : ':';
		this.tab = this.readable ? '\t' : '';
		this.lineBreak = this.readable ? newLine : '';
		this.customFields = [];
	};

	JsonLayout.prototype = new Layout();

	_.extend(JsonLayout.prototype, {

		isReadable : function() {
			return this.readable;
		},
		isCombinedMessages : function() {
			return this.combineMessages;
		},
		/**
		 * Return format for json object to send on server as json object
		 *
		 */
		format : function(loggingEvent) {
			
			var dataValues = this.getDataValues(loggingEvent, this.combineMessages);
			var str = '\n' + '{' + this.lineBreak;
			var i, len;

			for ( i = 0, len = dataValues.length - 1; i <= len; i++) {
				str += this.tab + '\'' + dataValues[i][0] + '\'' + this.colon + dataValues[i][1];
				if (i < len) {
					str += ',';
				}
				str += this.lineBreak;
			}

			str += '}' + this.lineBreak;
			return str;
		},
		/**
		 * Return content type for json layout as application/json
		 *
		 */
		getContentType : function() {
			return 'application/json';
		}
	});

	return JsonLayout;
});

/**
 * @class Level
 * @type Level
 * @name Level
 * @memberOf Lightsaber.Core.Logger
 * @description
 * The Lightsaber's Level class. Level can be ALL, TRACE, DEBUG, INFO, WARN, ERROR, FATAL, OFF
 *
 *
 */

define('src/core/logger/Level',['underscore'], function(_) {

	//Level Related Code
	var Level = function(level, name) {
		this.level = level;
		this.name = name;
	};

	_.extend(Level.prototype, {

		toString : function() {
			return this.name;
		},
		equals : function(level) {
			return this.level === level.level;
		},
		isGreaterOrEqual : function(level) {
			return this.level >= level.level;
		}
	});

	Level.ALL = new Level(Number.MIN_VALUE, 'ALL');
	Level.TRACE = new Level(10000, 'TRACE');
	Level.DEBUG = new Level(20000, 'DEBUG');
	Level.INFO = new Level(30000, 'INFO');
	Level.WARN = new Level(40000, 'WARN');
	Level.ERROR = new Level(50000, 'ERROR');
	Level.FATAL = new Level(60000, 'FATAL');
	Level.OFF = new Level(Number.MAX_VALUE, 'OFF');

	return Level;
});

/**
 * @class Appender
 * @type Appender
 * @name Appender
 * @memberOf Lightsaber.Core.Logger
 * @description
 * The Lightsaber's Appender class. This call will be used as a basic class for any appender.
 *
 *
 */

define('src/core/logger/Appender',['underscore', 'src/core/logger/Level'], function(_, Level) {

	var Appender = function() {

	};

	_.extend(Appender.prototype, {
		doAppend : function(loggingEvent) {
			if (loggingEvent.level.level >= Level.DEBUG.level) {
				this.append(loggingEvent);
			}
		}
	});

	return Appender;
}); 
/**
 * @class TopicAppender
 * @type TopicAppender
 * @name TopicAppender
 * @memberOf Lightsaber.Core.Logger
 * @description
 * The Lightsaber's TopicAppender class. This is Topic Appender and will log onto console
 *
 * Example :
 *
 * 		var myLogger = new Lightsaber.Core.Logger().getLogger('MyLogger');
 *		// define a new console appender
 *		var TopicAppender = new myLogger.TopicAppender();
 *
 */
define('src/core/logger/TopicAppender',['underscore', 'src/core/logger/Appender', 'src/core/logger/Level', 'src/core/logger/Layout', 'src/core/logger/JSONLayout'], function(_, Appender, Level, Layout, JsonLayout) {
	var TopicAppender = function(Topic, Hub) {

		var isSupported = true;
		var appender = this;

		if (!Topic) {
			isSupported = false;
			console.log('Topic Cannot be undefined');
		}

		var queuedLoggingEvents = [];
		var queuedRequests = [];
		var sessionId = null;

		// Session ID
		this.getSessionId = function() {
			return sessionId;
		};
		this.setSessionId = function(sessionIdParam) {
			sessionId = sessionIdParam;
			this.layout.setCustomField('sessionid', sessionId);
		};

		// layout set
		this.setLayout = function(layoutParam) {
			// if (checkCanConfigure('layout')) {
			this.layout = layoutParam;
			// Set the session id as a custom field on the layout, if not
			// already present
			if (sessionId !== null) {
				this.setSessionId(sessionId);
			}
			// }
		};

		// layout set
		this.getLayout = function() {
			return this.layout;
		};

		this.append = function(loggingEvent) {
			queuedLoggingEvents.push(loggingEvent);

			var actualBatchSize = 1;

			if (queuedLoggingEvents.length >= actualBatchSize) {
				var currentLoggingEvent;
				var batchedLoggingEvents = [];
				while (( currentLoggingEvent = queuedLoggingEvents.shift())) {
					batchedLoggingEvents.push(currentLoggingEvent);
				}
				// Queue this batch of log entries
				queuedRequests.push(batchedLoggingEvents);
			}
			var currentRequestBatch;
			function preparePostData(batchedLoggingEvents) {
				// Format the logging events
				var formattedMessages = [];
				var currentLoggingEvent;
				var postData = '';
				while (( currentLoggingEvent = batchedLoggingEvents.shift())) {
					formattedMessages.push(appender.layout.format(currentLoggingEvent));
				}
				// Create the post data string
				if (batchedLoggingEvents.length === 1) {
					postData = formattedMessages.join('');
				} else {
					postData = appender.layout.batchHeader + formattedMessages.join(appender.layout.batchSeparator) + appender.layout.batchFooter;
				}

				return postData;
			}

			function sendRequest(postData) {
				if (isSupported) {
					// var Hub = Lightsaber.Core.BusinessWidgetHub;
					Hub.publish(Topic.name, {
						logData : postData
					});
				}

			}
			// Rattle off all the requests without waiting to see the response
			while (( currentRequestBatch = queuedRequests.shift())) {
				sendRequest(preparePostData(currentRequestBatch));
			}	
		};
	};

	TopicAppender.prototype = new Appender();
	_.extend(TopicAppender.prototype, {

		layout : new JsonLayout(),
		threshold : Level.DEBUG,
		defaults : {
			timed : false,
			timerInterval : 1000,
			batchSize : 1,
			sendAllOnUnload : false,
			postVarName : 'data',
			contentType : 'application/json'
		},
		toString : function() {
			return 'TopicAppender';
		}
	});
	return TopicAppender;
});

/**
 * @class ModelAppender
 * @type ModelAppender
 * @name ModelAppender
 * @memberOf Lightsaber.Core.Logger
 * @description
 * The Lightsaber's ModelAppender class. This is Model Appender and will log onto console
 *
 * Example :
 *
 * 		var myLogger = new Lightsaber.Core.Logger().getLogger('MyLogger');
 *		// define a new console appender
 *		var ModelAppender = new myLogger.ModelAppender();
 *
 */
define('src/core/logger/ModelAppender',['underscore', 'src/core/logger/Appender', 'src/core/logger/Layout', 'src/core/logger/JSONLayout', 'src/core/logger/Level'], function(_, Appender, Layout, JsonLayout, Level) {

	var ModelAppender = function(Model) {

		var appender = this;
		var isSupported = true;
		if (!Model) {
			isSupported = false;
			console.log('Model Cannot be undefined');
		}
		var timed = this.defaults.timed;
		var batchSize = this.defaults.batchSize;
		var timerInterval = this.defaults.timerInterval;
		var sendAllOnUnload = this.defaults.sendAllOnUnload;
		var sessionId = null;
		var queuedLoggingEvents = [];
		var queuedRequests = [];
		var sending = false;
		var initialized = false;
		

		// Session ID
		this.getSessionId = function() {
			return sessionId;
		};

		this.setSessionId = function(sessionIdParam) {
			sessionId = sessionIdParam;
			this.layout.setCustomField('sessionid', sessionId);
		};

		// layout set
		this.setLayout = function(layoutParam) {
			this.layout = layoutParam;
			// Set the session id as a custom field on the layout,
			// if not
			// already present
			if (sessionId !== null) {
				this.setSessionId(sessionId);
			}
		};

		this.getLayout = function() {
			return this.layout;
		};
		// timed
		this.isTimed = function() {
			return timed;
		};

		this.setTimed = function(timedParam) {
			timed = timedParam;
		};

		// timeInterval
		this.getTimerInterval = function() {
			return timerInterval;
		};

		this.setTimerInterval = function(timerIntervalParam) {
			timerInterval = timerIntervalParam;
		};
		// BatchSize

		this.getBatchSize = function() {
			return batchSize;
		};
		this.setBatchSize = function(batchSizeParam) {
			batchSize = batchSizeParam;
		};
		// sendAllOnUnload
		this.isSendAllOnUnload = function() {
			return sendAllOnUnload;
		};
		this.setSendAllOnUnload = function(sendAllOnUnloadParam) {
			sendAllOnUnload = sendAllOnUnloadParam;
		};
		this.preparePostData = function(batchedLoggingEvents) {
			// Format the logging events
			var formattedMessages = [];
			var currentLoggingEvent;
			var postData = '';
			while (( currentLoggingEvent = batchedLoggingEvents.shift())) {
				formattedMessages.push(appender.layout.format(currentLoggingEvent));
			}
			// Create the post data string
			if (batchedLoggingEvents.length === 1) {
				postData = formattedMessages.join('');
			} else {
				postData = appender.layout.batchHeader + formattedMessages.join(appender.layout.batchSeparator) + appender.layout.batchFooter;
			}

			return postData;
		};

		this.sendRequest = function(postData) {
			if (isSupported) {
				var modelAppender = new Model({
					'Object' : postData
				}, {

				});

				modelAppender.save({

				});

			}

		};

		this.append = function(loggingEvent) {
			if (!initialized) {
				this.init();
			}

			if (isSupported) {
				queuedLoggingEvents.push(loggingEvent);
				var actualBatchSize = batchSize;

				if (queuedLoggingEvents.length >= actualBatchSize) {
					var currentLoggingEvent;
					var batchedLoggingEvents = [];
					while (( currentLoggingEvent = queuedLoggingEvents.shift())) {
						batchedLoggingEvents.push(currentLoggingEvent);
					}
					// Queue this batch of log entries
					queuedRequests.push(batchedLoggingEvents);

					if (!timed) {
						this.sendAll();
					}
				}
			}
		};
		this.init = function() {
			initialized = true;
			if (sendAllOnUnload) {
				var oldBeforeUnload = window.onbeforeunload;
				window.onbeforeunload = function() {
					if (oldBeforeUnload) {
						this.oldBeforeUnload();
					}
					if (this.sendAllRemaining()) {
						return 'Sending log messages';
					}
				};
			}
			if (timed) {
				this.scheduleSending();
			}

		};

		this.scheduleSending = function() {
			var that=this;
			setTimeout(function () { that.sendAll(); }, timerInterval);
		};

		// Send logs through Model to the server
		this.sendAll = function() {
			if (isSupported) {
				sending = true;
				var currentRequestBatch;
				// Rattle off all the requests without waiting to see the response
				while (( currentRequestBatch = queuedRequests.shift())) {
					this.sendRequest(this.preparePostData(currentRequestBatch));
				}
				sending = false;
				if (timed) {
					this.scheduleSending();
				}

			}
		};


		this.sendAllRemaining = function() {
			var sendingAnything = false;
			if (isSupported) {
				// Create requests for everything left over, batched as
				// normal
				var actualBatchSize = batchSize;
				var currentLoggingEvent;
				var batchedLoggingEvents = [];
				while (( currentLoggingEvent = queuedLoggingEvents.shift())) {
					batchedLoggingEvents.push(currentLoggingEvent);
					if (queuedLoggingEvents.length >= actualBatchSize) {
						// Queue this batch of log entries
						queuedRequests.push(batchedLoggingEvents);
						batchedLoggingEvents = [];
					}
				}
				// If there's a partially completed batch, add it
				if (batchedLoggingEvents.length > 0) {
					queuedRequests.push(batchedLoggingEvents);
				}
				sendingAnything = (queuedRequests.length > 0);
				timed = false;
				this.sendAll();
			}
			return sendingAnything;
		};

	};

	ModelAppender.prototype = new Appender();
	_.extend(ModelAppender.prototype, {

		layout : new JsonLayout(),
		threshold : Level.DEBUG,
		defaults : {
			timed : false,
			timerInterval : 1000,
			batchSize : 1,
			sendAllOnUnload : false,
			requestSuccessCallback : null,
			failCallback : null,
			postVarName : 'data',
			contentType : 'application/json'
		},
		toString : function() {
			return 'ModelAppender';
		}
	});

	return ModelAppender;
});

/**
 * @class ConsoleAppender
 * @type ConsoleAppender
 * @name ConsoleAppender
 * @memberOf Lightsaber.Core.Logger
 * @description
 * The Lightsaber's ConsoleAppender class. This is Console Appender and will log onto console
 *
 * Example :
 *
 * 		var myLogger = new Lightsaber.Core.Logger().getLogger("MyLogger");
 *		// define a new console appender
 *		var ConsoleAppender = new myLogger.ConsoleAppender();
 *
 */
define('src/core/logger/ConsoleAppender',['underscore', 'src/core/logger/Appender', 'src/core/logger/Level', 'src/core/logger/Layout', 'src/core/logger/JSONLayout'], function(_, Appender, Level, Layout, JSONLayout) {

	var ConsoleAppender = function() {

	};

	ConsoleAppender.prototype = new Appender();

	_.extend(ConsoleAppender.prototype, {

		layout : new JSONLayout(),
		threshold : Level.DEBUG,

		setLayout : function(layout) {
			if ( layout instanceof Layout) {
				ConsoleAppender.prototype.layout = layout;
			}
		},
		append : function(loggingEvent) {
			var appender = this;

			var getFormattedMessage = function() {
				var formattedMessage = appender.layout.format(loggingEvent);
				return ( typeof formattedMessage === 'string') ? [formattedMessage] : formattedMessage;
			};

			var console;

			if (( console = window.console) && console.log) {
				var formattedMessage = getFormattedMessage();

				var consoleMethodName;

				if (console.debug && Level.DEBUG.isGreaterOrEqual(loggingEvent.level)) {
					consoleMethodName = 'debug';
				} else if (console.info && Level.INFO.equals(loggingEvent.level)) {
					consoleMethodName = 'info';
				} else if (console.warn && Level.WARN.equals(loggingEvent.level)) {
					consoleMethodName = 'warn';
				} else if (console.error && loggingEvent.level.isGreaterOrEqual(Level.ERROR)) {
					consoleMethodName = 'error';
				} else {
					consoleMethodName = 'log';
				}

				if (console[consoleMethodName].apply) {
					console[consoleMethodName].apply(console, formattedMessage);
				} else {
					console[consoleMethodName](formattedMessage);
				}
			} 
		},
		group : function(name) {
			if (window.console && window.console.group) {
				window.console.group(name);
			}
		},
		groupEnd : function() {
			if (window.console && window.console.groupEnd) {
				window.console.groupEnd();
			}
		},
		toString : function() {
			return 'ConsoleAppender';
		}
	});

	return ConsoleAppender;
});

/**
 * @class LoggingEvent
 * @type LoggingEvent
 * @name LoggingEvent
 * @memberOf Lightsaber.Core.Logger
 * @description
 * The Lightsaber's LoggingEvent class.
 *
 *
 */

define('src/core/logger/LoggingEvent',['underscore'], function(_) {

	var newLine = '\r\n';
	var LoggingEvent = function(logger, timeStamp, level, messages) {
		this.logger = logger;
		this.timeStamp = timeStamp;
		this.level = level;
		this.messages = messages;
	};
	_.extend(LoggingEvent.prototype, {
		//LoggingEvent.prototype = {
	

		getCombinedMessages : function() {
			return (this.messages.length === 1) ? this.messages[0] : this.messages.join(newLine);
		}
	});
	return LoggingEvent;
}); 
/**
 * @class Logger
 * @type Logger
 * @name Logger
 * @memberOf Lightsaber.Core
 * @description
 * The Lightsaber's Logger class. Will return the instance of UXFLogger through getLogger method.
 *
 * Example :
 *
 * 		var myLogger = new Lightsaber.Core.Logger().getLogger('MyLogger');
 *
 */

define('src/core/logger/Logger',['src/core/logger/JSONLayout', 'src/core/logger/Appender', 'src/core/logger/TopicAppender', 'src/core/logger/ModelAppender', 'src/core/logger/ConsoleAppender', 'src/core/logger/Level', 'src/core/logger/LoggingEvent', 'underscore'], function(JsonLayout, Appender, TopicAppender, ModelAppender, ConsoleAppender, Level, LoggingEvent, _) {

	var Logger = function() {

		var loggers = {};
		var loggerNames = [];

		/**
		 * Create a new instance of UXFLogger.
		 * @methodOf Lightsaber.Core.Logger#
		 * @name getLogger
		 * @param {Object} Logger name for UXFLooger instance.
		 * @returns A new instance.
		 */
		this.getLogger = function(loggerName) {
			if (!loggers[loggerName]) {
				var logger = new UXFLogger(loggerName);
				loggers[loggerName] = logger;
				loggerNames.push(loggerName);
			}
			return loggers[loggerName];
		};

		/**
		 * Create a new instance of UXFLogger.
		 * @methodOf Lightsaber.Core.Logger#
		 * @name UXFLogger
		 * @param {Object} Logger name for UXFLooger instance.
		 * @returns A new instance.
		 */
		function UXFLogger(name) {
			this.name = name;
			var appenders = [];
			var loggerLevel = Level.DEBUG;

			// Add Appender to logger
			this.addAppender = function(appender) {
				appenders.push(appender);
			};
			this.removeAppender = function(appender) {
				var tempappenders = [];
				var newAppenders = [];
				tempappenders = appenders;
				for (var i = appenders.length - 1; i >= 0; i--) {
					if (appenders[i] === appender) {
						tempappenders.pop();
					} else {
						newAppenders.push(tempappenders.pop());
					}
				}
				appenders = newAppenders;
			};

			this.removeAllAppenders = function() {

				var tempAllappenders = [];
				tempAllappenders = appenders;
				while (appenders.length > 0) {
					tempAllappenders.pop();
				}
				appenders = tempAllappenders;
			};
			var enabled = true;

			this.setEnabled = function(enable) {
				enabled = enable;
			};

			this.isEnabled = function() {
				return enabled;
			};

			// log function to do logging
			this.log = function(level, params) {
				if (this.isEnabled() && level.isGreaterOrEqual(this.getLevel())) {
					// Check whether last param is an exception
					var exception;
					var finalParamIndex = params.length - 1;
					var lastParam = params[finalParamIndex];
					if (params.length > 1 ) {
						exception = lastParam;
						finalParamIndex--;
					}

					// Construct genuine array for the params
					var messages = [];
					for (var i = 0; i <= finalParamIndex; i++) {
						messages[i] = params[i];
					}

					var loggingEvent = new LoggingEvent(this, new Date(), level, messages);

					this.callAppenders(loggingEvent);
				}
			};

			this.callAppenders = function(loggingEvent) {
				for (var i = 0, len = appenders.length; i < len; i++) {
					appenders[i].doAppend(loggingEvent);
				}
			};

			this.setLevel = function(level) {
				if ( level instanceof Level) {
					loggerLevel = level;
				}
			};

			this.getLevel = function() {
				return loggerLevel;
			};

			this.group = function(name, initiallyExpanded) {
				if (this.isEnabled()) {
					for (var i = 0, len = appenders.length; i < len; i++) {
						appenders[i].group(name, initiallyExpanded);
					}
				}
			};

			this.groupEnd = function() {
				if (this.isEnabled()) {
					for (var i = 0, len = appenders.length; i < len; i++) {
						appenders[i].groupEnd();
					}
				}
			};

			this.toString = function() {
				return 'Logger[' + this.name + ']';
			};

			this.Appender = Appender;
			this.Level = Level;
			this.LoggingEvent = LoggingEvent;
			this.JsonLayout = JsonLayout;
			this.ConsoleAppender = ConsoleAppender;
			this.ModelAppender = ModelAppender;
			this.TopicAppender = TopicAppender;

		}

		_.extend(UXFLogger.prototype, {

			trace : function() {
				this.log(Level.TRACE, arguments);
			},
			debug : function() {
				this.log(Level.DEBUG, arguments);
			},
			info : function() {
				this.log(Level.INFO, arguments);
			},
			warn : function() {
				this.log(Level.WARN, arguments);
			},
			error : function() {
				this.log(Level.ERROR, arguments);
			},
			fatal : function() {
				this.log(Level.FATAL, arguments);
			},
			isEnabledFor : function(level) {
				return level.isGreaterOrEqual(this.getLevel());
			},
			isTraceEnabled : function() {
				return this.isEnabledFor(Level.TRACE);
			},
			isDebugEnabled : function() {
				return this.isEnabledFor(Level.DEBUG);
			},
			isInfoEnabled : function() {
				return this.isEnabledFor(Level.INFO);
			},
			isWarnEnabled : function() {
				return this.isEnabledFor(Level.WARN);
			},
			isErrorEnabled : function() {
				return this.isEnabledFor(Level.ERROR);
			},
			isFatalEnabled : function() {
				return this.isEnabledFor(Level.FATAL);
			}
		});

	};

	return Logger;
});

define('src/core/application/Bootstrap',['jquery', 'src/core/util/Utils', 'src/core/application/Application', 'src/core/controller/Router'], function ($, Utils, Application, Router) {


    var Bootstrap = function (options) {
        this._init(options);
        this.init(options);
        this.createRouter(options);
        this.createApplication(options);
        this.postInit(options);
        //this.initialize.apply(this, arguments);
    };

    _.extend(Bootstrap, {
        extend: Utils.extend
    });

    _.extend(Bootstrap.prototype, {

        routes: {},
        modules: [],


        /**
        @private
        **/
        _init: function() {
            this.applicationConstructor = Application;
        },

        init: function() {
        },

        postInit: function() {
        },

        createRouter: function() {
            this.router = new Router({
                routes: this.routes
            });
        },

        createApplication: function() {
            new this.applicationConstructor({
                router: this.router,
                modules: this.modules
            });
        }

    });

    return Bootstrap;

});
/**
 Execution Context component. Intended for synchronization of VM between different Widgets.

 @class Lightsaber.Core.ExecutionContext
 @namespace Lightsaber.Core
 @module Lightsaber.Core
 @extends Object
 @singleton false

 @requires underscore
 @requires backbone

 @since 9.3.0

 @constructor
 **/
define('src/core/application/ExecutionContext',['underscore',
    'backbone',
    'src/core/util/Utils'
], function(_, Backbone, Utils) {
    

    var CHANGE_ACTION_NAME= '$change', SUBSCRIBE_ACTION_NAME= '$subscribe';

    var ExecutionContext = function(options) {

        this.options = options || {};
        this.modules = {};
        this.createModules(this.options.modules)
    };

    _.extend(ExecutionContext.prototype, Utils.Factory, {
        createModules: function(modulesConfig){
            _.each(modulesConfig, function(modelConfig, moduleID) {
                this.createModule(moduleID, modelConfig.path, modelConfig.options);
            }, this);
        },
        /**
         * Create a new module that can be shared between Widget using the same execution context.
         * @param moduleID - The module ID
         * @param modulePath - The module jquery path
         * @param modelOptions - The module options configuration.
         * @returns the created module
         */
        createModule: function(moduleID, modulePath, modelOptions){
            var ModuleConstructor = requirejs(modulePath);
            if (typeof ModuleConstructor === 'undefined'){//The module constructor was not loaded yet.
                return null;
            }
            this.modules[moduleID] = this.create(_.uniqueId('module_' + moduleID + '_'), ModuleConstructor, modelOptions);
            return this.modules[moduleID];
        },
        /**
         * Return the requested module based on the module ID.
         * @param moduleID
         * @returns the requested module
         */
        getModule: function(moduleID){
            return this.modules[moduleID];
        },
        /**
         * Publish data to a module and trigger an action.
         * @param moduleID - The module that should handle the data change and action
         * @param data - The new data
         * @param action - string, action name to trigger
         * @returns promise for the action fired
         */
        publish: function(moduleID, data, action){
            var module = this.getModule(moduleID);
            if (!module){
                throw new Error('Module \'' + moduleID + '\' is not instantiated for use yet.');
            }

            data = _.pick(data, _.keys(module.get()));
            module.set(data);
            if (action) {
                module.handleAction(action);
            }
        },
        subscribe: function(moduleID, options){
            var generateTopicData = function(module, data, action) {
                var topicData = Utils.clone(_.omit(module.get(), 'subViewModels'));
                var _data = {
                    action: action,
                    data: topicData
                };
                if (action === SUBSCRIBE_ACTION_NAME) {
                    _data.changedAttributes = topicData;
                    _data.prevAttributes = {};
                    _data.changedAttributes = {};
                } else if (action === CHANGE_ACTION_NAME) {
                    _data.changedAttributes = Utils.clone(data.changed);
                    _data.prevAttributes = Utils.clone(_.omit(data.target.data.previousAttributes(), 'subViewModels'));
                }
                return _data;
            };
            var module = this.getModule(moduleID);
            if (!module){
                throw new Error('Module \'' + moduleID + '\' is not instantiated for use yet.');
            }
            if (!options.actions || _.indexOf(options.actions, 'change') > -1){
                module.on('change', options.handler, options.context);
            }
            if (options.events){
                _.each(options.events, function(eventInfo, eventName, obj){
                    if (_.isArray(obj)){
                        eventName = eventInfo;
                        eventInfo = null;
                    }
                    if (!eventInfo) {
                        eventInfo = {};
                    }
                    eventInfo.handler = eventInfo.handler || options.handler;
                    eventInfo.context = eventInfo.context || options.context;
                    module.on(eventName, eventInfo.handler, eventInfo.context);
                });
            }
            if (!options.silent) {
                (_.bind(options.handler, options.context))(generateTopicData(module, {}, SUBSCRIBE_ACTION_NAME));
            }
        }
    });

    return ExecutionContext;
});

/**
 Context provider Create <em>ExecutionContext</em> and can be used by 3rd party components to communicate with Widgets.

 @class Lightsaber.Core.ExecutionContext
 @namespace Lightsaber.Core
 @module Lightsaber.Core
 @extends Object
 @singleton false

 @requires underscore
 @requires backbone

 @since 9.3.0

 @constructor
 **/
define('src/core/application/ContextProvider',[
    'underscore',
    'src/core/application/ExecutionContext',
    'src/core/util/Utils'
], function(_, ExecutionContext, Utils){

    

    var ContextProvider = function ( options ){
        this.options = options || {};
        this.modelConfigs = this.options.modules || {};
        this.createdContext = {};
        this.envViewModel = null;
    };

    _.extend(ContextProvider.prototype, Utils.Factory, {
        /**
         *  Creates execution context on demand.
         *  @modules -  array of modules to share.
         **/
        createExecutionContext: function(modules) {
            var executionContext, moduleID;

            if (!this.envViewModel){
                this.envViewModel = this.createEnvViewModel(this.options.env)
            }
            if ( _.isString(modules)){
                return this.createExecutionContext([modules]);
            }
            if (_.isArray(modules)) {
                executionContext = this.create(_.uniqueId('module_'), ExecutionContext, {});

                _.each(modules, function(moduleID) {
                    var modelConfig = this.modelConfigs[moduleID];
                    if (modelConfig){
                        var module = executionContext.createModule(moduleID, modelConfig.path, modelConfig.option);
                        if (module.addSubViewModel){
                            module.addSubViewModel('env',this.envViewModel);
                        }
                    }
                }, this);
            }
            return executionContext;
        },
        createEnvViewModel : function(data){

        }

    });

    return ContextProvider;
});


define(
'lightsaber.core',[
 	'underscore',
	'backbone',
	'src/core/util/Utils',
	'src/core/resourceBundle/ResourceBundle',
	'src/core/dataSource/DataSource',
	'src/core/dataSource/LocalStorageDataSource',
	'src/core/dataSource/RESTDataSource',
	'src/core/dataSource/LSRESTDataSource',
	'src/core/dataSource/RESTSession',
	'src/core/model/ErrorHandler',
	'src/core/model/Model',
	'src/core/model/RESTModel',
	'src/core/model/Validator',
	'src/core/model/Collection',
	'src/core/viewModel/BaseViewModel',	
	'src/core/viewModel/ViewModel',
    'src/core/viewModel/ObservableViewModel',
	'src/components/collection/viewmodel/CollectionViewModel',
	'src/core/view/View',
	'src/core/binding/Binding',
	'src/core/application/Application',
	'src/core/application/BusinessWidget',
	'src/core/hub/BusinessWidgetHub',
	'src/core/controller/Router',
	'src/core/controller/FlowManager',
	'src/core/util/Configuration',
	'src/core/util/StorageUtil',
	'src/core/formatter/FormattersContainer',
    'src/core/application/WidgetInternalFlow',
	'src/core/logger/Logger',
    'src/core/application/Bootstrap',
    'src/core/application/ContextProvider'
],
function(_,
         Backbone,
         Utils,
         ResourceBundle,
         DataSource,
         LocalStorageDataSource,
         RESTDataSource,
         LSRESTDataSource,
         RESTSession,
         ErrorHandler,
         Model,
         RESTModel,
         Validator,
         Collection,
         BaseViewModel,
         ViewModel,
         ObservableViewModel,
         CollectionViewModel,
         View,
         DataBinding,
         Application,
         BusinessWidget,
         BusinessWidgetHub,
         Router,
         FlowManager,
         Configuration,
		 StorageUtil,
		 FormattersContainer,
         WidgetInternalFlow,
		 Logger,
         Bootstrap,
         ContextProvider
		 ) {

	var Lightsaber = {

		DataSource: DataSource,

		LocalStorageDataSource: LocalStorageDataSource,

		RESTDataSource: RESTDataSource,
		
		LSRESTDataSource: LSRESTDataSource,
		
		RESTSession: RESTSession,
		
		ErrorHandler: ErrorHandler,

		Model: Model,
		
		RESTModel: RESTModel,

		Collection: Collection,

		Validator: Validator,

		View: View,

		BaseViewModel: BaseViewModel,

		ViewModel: ViewModel,
        ObservableViewModel: ObservableViewModel,       

		CollectionViewModel: CollectionViewModel,
		
		DataBinding: DataBinding,

		Application: Application,

		BusinessWidget: BusinessWidget,

		BusinessWidgetHub: BusinessWidgetHub,

		Router: Router,

        FlowManager: FlowManager,
		Utils: Utils,

		ResourceBundle: ResourceBundle,
		
		Configuration: Configuration,

		StorageUtil: StorageUtil,

		FormattersContainer: FormattersContainer,

        WidgetInternalFlow: WidgetInternalFlow,
		
		Logger: Logger,

        Bootstrap: Bootstrap,

        ContextProvider: ContextProvider
		
	};

	return Lightsaber;

});




define('text!src/components/button/view/template/anchorButtonTemplate.html',[],function () { return '<a class="uxf-button" data-uxf-point="buttonElement" data-role="button"><%=text%></a>';});


define('text!src/components/button/view/template/defaultButtonTemplate.html',[],function () { return '<button class="uxf-button" data-uxf-point="buttonElement"><%=text%></button>';});


define('text!src/components/button/view/template/inputButtonTemplate.html',[],function () { return '<input class="uxf-button" data-uxf-point="buttonElement" type="button" value="<%=text%>"></input>';});

/**
Base <em>Button</em> component that all other <em>Buttons</em> extend.

## Default HTML `button` element-based template

```html
<button class="uxf-button" data-uxf-point="buttonElement"><%=text%></button>
```

## HTML `a` element-based template

```html
<a class="uxf-button" data-uxf-point="buttonElement" data-role="button"><%=text%></a>
```

## HTML `input` element-based template

```html
<input class="uxf-button" data-uxf-point="buttonElement" type="button" value="<%=text%>"></input>
```


@class Lightsaber.Mobile.BaseButtonView
@namespace Lightsaber
@module Lightsaber.Mobile
@extends Lightsaber.Core.View

@private

@requires jQuery
@requires Underscore
@requires Lightsaber.Core

@since 9.0.0

@constructor
@param {Object} options constructor's only parameter
@param {Lightsaber.Core.ViewModel} options.viewModel <em>ViewModel</em> that the <em>View</em> is going to use
@param {Object} options.config main configuration parameter
@param {String} options.config.vmKeys mapping of expected name of *ViewModel* 
property to its actual name in the specific *ViewModel* that this *View* receives at runtime.
@param {Boolean} [options.config.preventDefault=true] prevents or allows default `click` behaviour
@param {Boolean} [options.config.stopPropagation=true] prevents or allows bubbling of the `click` event
@param {String} [options.config.tagName] HTML element to use as base (can be either `a`, `input` or `button` (default))

**/
define('src/components/button/view/BaseButtonView',[
	'jquery',
	'underscore',
	'text!./template/anchorButtonTemplate.html',
	'text!./template/defaultButtonTemplate.html',
	'text!./template/inputButtonTemplate.html',
    'lightsaber.core'
], function($,_, anchorButtonTemplate, defaultButtonTemplate, inputButtonTemplate, LightsaberCore) {

	
    

	var BaseButtonView = LightsaberCore.View.extend({

		
		/**
		List of public methods exposed by this view as a jQuery plugin.
		 
		Default value is `['reapplyAttrs','refresh']`.
		
		@property {Array<String>} publicMethods
		@protected
		@default ['reapplyAttrs','refresh']
		**/
		publicMethods : ['reapplyAttrs','refresh'],

		/**
		Default template (matching default `tagName` - for `button`-based buttons).

		@property defaultTemplate
		@protected
		@type {String}
		@default <button class="uxf-button" data-uxf-point="buttonElement"><%=text%></button>
		**/
		template : defaultButtonTemplate,

		/**
		Default `tagName` to be used for template deduction.
	
		For more information see {{#crossLink "Lightsaber.BaseButtonView"}}{{/crossLink}}.

		@property tagName
		@protected
		@type {Object}
		**/
		tagName: 'button',

		/**
		Describes default values of the properties (on the ViewModel of the button) for `text` and `label`.
		
		For more information see {{#crossLink "Lightsaber.Core.View"}}{{/crossLink}}.

		@property vmKeysChangeEvents
		@protected
		@type {Object}
		**/
		vmKeys: {
			'data.text' : 'text',
			'data.label'	: 'label',
			'action.click' : 'click'
		},

		/**
		Describes default values of the change events handlers for `text` and `label`.
		
		For more information see {{#crossLink "Lightsaber.Core.View"}}{{/crossLink}}.

		@property vmKeysChangeEvents
		@protected
		@type {Object}
		**/
		vmKeysChangeEvents: {
			'data.text'		: 'onChange',
			'data.label'	: 'onChange'
		},

		/**
		Binds click handler to the instance of the `ButtonView`.
		
		@method initialize
		@protected
		**/
		initialize: function() {
			_.bindAll(this, '_clicked');
		},
		
		/**
		Sets the default template to be used based on `tagName` configuration attribute passed as parameter 
		to the button's constructor.

		Default value is `button`.
		
		@method _preRender
		@protected
		**/
		_preRender : function() {
			var template = this.getConfig('template');

			if (!template) {
				this._decideDefaultTemplate();
			}		
		},

		/**
		Calculates `this.$root` wrapper by calling to {{#crossLink "Lightsaber.BaseButtonView/_calcWrapper"}}{{/crossLink}} 
		method.

		@method _postRender
		@protected
		**/
		_postRender : function() {
			this._calcWrapper();
		},

		/**
		Calculates wrapper HTML element for the button's root HTML element.
		
		@method _calcWrapper
		@private
		**/
		_calcWrapper : function() {
			var $parentsBeforeEL = this.$root.parentsUntil(this.$el);
			this.$wrapper = $parentsBeforeEL.eq($parentsBeforeEL.length - 1);
			if(!this.$wrapper.length || this.options.insertMethod == 'replace') {
				this.$wrapper = this.$el;
			}
		},
			
		/**
		Creates data to be used by `_.template` (for all `<%=%>` tokens) by deciding on corresponding
		`label` property to be used from the ViewModel (as defined by `vmKeys`) and adding `disabled` property.

		@method _createTemplateData
		@protected
		@callable
		@return data object to be used with the template
		**/	
		_createTemplateData : function() {
			var label = this.viewModel.get(this.vmKeys['data.text']) || 
						this.viewModel.get(this.vmKeys['data.label']) || 
						this.viewModel.getConfig(this.vmKeys['data.label']) || 
						this.getConfig(this.vmKeys['data.label']);

			var data = {text: label, disabled: this.attr('disabled')};

			return data;
		},
		
		/**
		Decides what is the default template to be used according to `tagName` configuration parameter.

		@method _decideDefaultTemplate
		@private
		**/	
		_decideDefaultTemplate : function() {
			this.tagName = this.getConfig('tagName') || this.tagName;
			
			switch(this.tagName) {
				case 'input' :
					this.template = _.template(inputButtonTemplate);
					break;
				case 'a' :
					this.template = _.template(anchorButtonTemplate);
					break;
				case 'button' :
				default :
					this.template = _.template(defaultButtonTemplate);
					break;
			}
		},

		/**
		Enhances the created button HTML markup using jQuery UI or jQuery Mobile button widget.

		The idea is to create the button's HTML markup (perhaps based on data returned from some AJAX request)
		and allow jQuery UI or Mobile to enhance it both visually and functionally.

		@method _enhanceMarkup
		@protected
		**/
		_enhanceMarkup : function() {},		

		/**
		Provides the default handler for `change` event - which, in case of button may 
		mean the change of the value of the `label` property on the ViewModel, which requires
		refresh of the button's HTML markup.

		@method onChange
		@noncallable
		@param {Object} event change event
		@param {Object|String|...} event.value changed attribute's value
		**/
		onChange : function(event) {
			this.refresh(event);
		},

		/**
		Refreshes the button's HTML markup.

		If `refresh` was called as a result of `change` event, it will refresh the appropriate
		parts of HTM markup, otherwise (when called directly by client code) it will reapply attributes
		(that become part of the HTML markup, just like those passed as part of configuration object to the
		`ButtonView` constructor).

		> **Note** that this implementation is Mobile-based and is overridden on Web touch point.

		@method refresh
		@callable
		@param {Object} event change event
		@param {Object|String|...} event.value changed attribute's value
		**/
		refresh : function(event) {
			if(event) {
				switch(this.tagName) { 
					case 'input':
						this.$root.val(event.value);

						this.$root.button('refresh');
						break;
					case 'a' :
						this.$root.find('span').html(event.value);
						break;
					case 'button ': 
					default : 
						this.$root.html(event.value);
						this.$root.button('refresh');
						break;
				}
			}
			else {
				this.reapplyAttrs();
			}			
		},	
		
		/**
		Higher level `click` event handler that calls the default event handler and then
		propagates the call to the corresponding action on the ViewModel, as defined by:

			new Lightsaber.Core.ViewModel({
				config: {
					actions: {
						click: function() { ... }
					}
				}
			});

		In addition calls `stopPropagation` and `preventDefault` to stop bubbling and prevent (in case of 
		button implementation using `a` HTML element) navigation attempt.

		@method _clicked
		@protected
		@param {Object} event change event
		@param {Object|String|...} event.value changed attribute's value
		**/
		_clicked: function(event) {
			this._handleEventOnClick(event);
			// checking if we have a mapped name for the action on the view
			var eventType = this.vmKeys['action.' + event.type];
			if (!eventType) {
				eventType = event.type;
			}

			this.viewModel.handleAction(eventType, event);
			
			if (this.getConfig('stopPropagation') !== false) {
				event.stopPropagation();
			}
			if (this.getConfig('preventDefault') !== false) {
				event.preventDefault();
			}
		},
		
		/**
		<dfn title="Method that is expected to be overridden and implemented by extending classes">Template method</dfn> - empty implementation of default click handler.

		@method _handleEventOnClick
		@protected
		@param {Object} event change event
		@param {Object|String|...} event.value changed attribute's value
		**/
		_handleEventOnClick: function(event){},

		/**
		<dfn title="Method that is expected to be overridden and implemented by extending classes">Template method</dfn> - 
		empty implementation of method that should reapply received attributes (through corresponding configuration
		parameter).

		@method reapplyAttrs
		@protected
		**/
		reapplyAttrs : function() {}
	});
	return BaseButtonView;

});

/**
ButtonView is the WEB implementation for button.

@class ButtonView
@namespace Lightsaber
@module Lightsaber.Web
@extends Lightsaber.BaseButtonView

@requires jQuery
@requires jQueryUI
@requires Lightsaber.BaseButtonView
@requires Lightsaber.Core

@since 9.0.0

@constructor
@param {Object} options the *Button's* configuration object. Please find additional params at: 
	{{#crossLink "Lightsaber.BaseButtonView"}}{{/crossLink}}, 
	{{#crossLink "Lightsaber.Core.View"}}{{/crossLink}}
@example 
For basic creation of the *ButtonView* the only mandatory configuration parameter is `viewModel`:

	var buttonView = new Lightsaber.ButtonView({
		viewModel: myViewModel
	});
		
in which case the *ButtonView* is created <dfn title="not connected to a DOM node">detached</dfn>.

More standard and wide-spread way is to create a *Button* while providing an `el` configuration property
to attach `ButtonView` to:

	var buttonView = new Lightsaber.ButtonView({
		el: '[data-uxf-point="button"]',
		viewModel: myViewModel
	});

Buttons may be created using different HTML elements as base for the template: `button` (default), `input` and `a`:

	new Lightsaber.ButtonView({
		el : $placeholder,
	  	viewModel : viewModel,
	  	config: {
			tagName : 'a' // or `button`, or `input`
	  	}
	});

which would result in the created HTML markup being, for `a` (notice the absense of `href` attribute):

	<a class="uxf-button ui-button ui-widget ui-state-default ui-corner-all ui-button-text-only" 
			data-uxf-point="buttonElement" data-role="button" role="button" aria-disabled="false">
		<span class="ui-button-text">a-based button</span>
	</a>

for `button`:

	<button class="uxf-button ui-button ui-widget ui-state-default ui-corner-all ui-button-text-only" 
			data-uxf-point="buttonElement" role="button" aria-disabled="false">
		<span class="ui-button-text">button-based button</span>
	</button>

and for `input`:

	<input class="uxf-button ui-button ui-widget ui-state-default ui-corner-all" data-uxf-point="buttonElement" 
			type="button" value="input-based button" role="button" aria-disabled="false">

In addition, buttons may have icons, both before and after the button's text:

	var buttonView1 = new Lightsaber.ButtonView({
	    el: $placeholder,
	    viewModel : viewModel,
	    config : {
	        icons: {
	            primary: 'ui-icon-gear', 			
	            secondary: 'ui-icon-triangle-1-s'	
	        }
	    }                
	});

when `ui-icon-gear` and `ui-icon-triangle-1-s` are standard jQuery UI icon names (turn classes, eventaually). See
more [jQuery UI icons here](http://api.jqueryui.com/theming/icons/).

> **Note** that such a setting is better done through and in sync with CSS work on the custom jQuery UI theme.

Aside from being able to customize separate features, the entire template of the button may be replaced (while
still using icons, for example):
	
	var buttonView1 = new Lightsaber.ButtonView({
	    el: $placeholder,
	    viewModel : viewModel,
	    config : {
	        tagName : 'a',
	        icons: {
	            primary: 'ui-icon-gear',
	            secondary: 'ui-icon-triangle-1-s'
	        },
	        template: '<span data-uxf-point="buttonElement"><%=name%> <%=aText%></span>'
	    }               
	});

Buttons may be disabled and enabled either by relying on corresponding ViewModel attribute:
	
	var viewModel = new Lightsaber.Core.ViewModel({
	    data : {
	        text : 'Button'
	    },
	    config : {
	        enabled : false
	    }
	});

	new Lightsaber.ButtonView({
	    config : {
	        el : $placeholder
	    },
	    viewModel : viewModel
	});

or by setting the configuration option on `ButtonView` itself (discouraged - better done through template):

	var viewModel = new Lightsaber.Core.ViewModel({
	  data : {
	    text : 'Button'
	  }
	});

	new Lightsaber.ButtonView({
	  config : {
	    el : $placeholder    
	  },
	  attributes: {
	    disabled: true
	  }, 
	  viewModel : viewModel
	});

The HTML markup that is created for the button is largely influenced by the jQueryUI that is responsible
for the actual creation of the UXF button, as a result the following are classes (and other styling information that
exist for the *Button*):

* `uxf-button`
	- top-level CSS class added by UXF framework
	- <dfn title="Provides a convinient connection to the underlying HTML structure to alter, if necessary.">
	CSS hook</dfn> only - doesn't carry any styling information
* `ui-button`
	- jQuery UI top-level CSS class 
* `ui-widget`
	- jQuery UI top-level generic CSS class for all its widgets
* `ui-state-default`
	- jQuery UI CSS class that denotes the state of the widget being default (not active or disabled)
* `ui-corner-all`, `ui-button-text-only` etc.
	- jQuery UI CSS classes responsible for various visiual features

> **Note**, that, as usual, usage of any of these classes in your JavaScript to serve as "hooks" into the DOM is 
**strongly discouraged** and may lead to eventual BWC breaks. Use `data-uxf-point` (which has the value of 
`buttonElement`) instead.

For more live and editable examples see 
[Button examples in Web Kitchen Sink App](../../examples/apps/AllWebViewsTestApp/page.html?button).

For more information on API and possible customization of buttons, *as it is created by jQuery UI*, refer to: 
[jQuery UI Button documentation](http://api.jqueryui.com/button/) for your version.

**/
define('src/components/button/view/ButtonView',[
	'jquery',
	'jquery.ui',
	'src/components/button/view/BaseButtonView',
    'lightsaber.core'
], function($, $$, BaseButtonView, Lightsaber ) {

	
	

	var ButtonView = BaseButtonView.extend({

				
		/**
		Enhances the created button HTML markup using jQuery UI button widget, by calling:

			this.$root.button(this.getConfig());

		basically passing the entire configuration object received by `ButtonView` constructor.

		@method _enhanceMarkup
		@protected
		**/
		_enhanceMarkup : function() {
			this.$root.button(this.getConfig());
			this.buttonEnhanced = true;
			this._checkEnable();
		},

		/**
		Calculates `this.$root` wrapper by calling to {{#crossLink "Lightsaber.BaseButtonView/_postRender"}}{{/crossLink}} method and reattaches `click` event.

		@method _postRender
		@protected
		**/
		_postRender: function() {
			this._super();
            this.$root.off('click', this._clicked);
            this.$root.on('click', this._clicked);
		},

		/**
		Refreshes the button's HTML markup.

		If `refresh` was called as a result of `change` event, it will refresh the appropriate
		parts of HTML markup, otherwise (when called directly by client code) it will reapply attributes
		(that become part of the HTML markup, just like those passed as part of configuration object to the
		`ButtonView` constructor).

		@method refresh
		@callable
		@param {Object} event change event
		@param {Object|String|...} event.value changed attribute's value
		**/
		refresh : function(event) {
			if(event) {
				switch(this.tagName) {
					case 'input':
						this.$root.val(event.value);
						this.$root.button('refresh');
						break;
					case 'a' :
					case 'button ': 
					default : 
						this.$root.find('span').html(event.value);
						this.$root.button('refresh');
						break;
				}
			}
			else {
				this.reapplyAttrs();
			}
		},
		
		/**
		Handler for change of `disabled` attribute on the ViewModel.

		Reapplies `disabled` to the button.

		@method onEnableChange
		@param {Object} event change event
		@param {Object|String|...} event.value changed attribute's value
		**/		
		onEnableChange: function(event) {
			if(this.buttonEnhanced) {
				this.$root.button( "option", "disabled", !event.value )
			}
		},

		/**
		Reapplies attributes to `this.$root` (`disabled` currently) that were received through constructor's configuration parameter.

		@method reapplyAttrs
		@protected
		**/
		reapplyAttrs : function() {
			if(this.$wrapper) {
				if(this.attr('disabled')) {
					this.$root.button('disable');
				}
				else {
					this.$root.button('enable');
				}
			}
		}		

	});

	return ButtonView;

});


define('text!src/components/header/view/template/header.html',[],function () { return '<div data-role="header" class="custom_header ui-header ui-bar-a" data-position="fixed" data-inline="true" data-tap-toogle="false">\n\t<h1 class="ui-title"><%=title%></h1>\t\n</div>';});

/**
 * @class HeaderView
 * @type View
 * @memberOf Lightsaber.Mobile
 * @name HeaderView
 * @description This view is a part of the header multi touch-points widget. Just like the container widget 
 * it extends, it is responsible to render all the sub-views that it receives in the same order or 
 * according to a given template.
 * @example
 * -->Example for usage with a template.
 *      // define the header view with sub-views configuration
 *      var headerView = new Lightsaber.HeaderView({
 *          viewModel: headerViewModel,
 *          config: {
 *              template: 	'<div data-role="header">
 *              				<h1><%=title%></h1>
 *              				<div id="rightButton"></div>
 *              				...
 *              			</div>',
 *              subViews:[
 *              {
                     viewInstance : new Lightsaber.ButtonView({
                        viewModel: new Lightsaber.ActionViewModel({
                            data:{
                                label : "Hide Content"
                            }
                        }),
                        config: {
                            className: 'ui-btn-right',
                            tagName: 'a'
                        },
                        id:'mytestbutton'
                     })
                  }
                 ]
 *          }
 *      });
 *      $('#headerDiv').append(headerView.el); // add the header view element to DOM
 *
 *
 * @example
 * -->Example for usage without a template.
 *      // define the header view with sub-views configuration
 *      var headerView = new Lightsaber.HeaderView({
 *          viewModel: headerViewModel,
 *          config: {
 *              subViews:[
 *              {
                     viewInstance : new Lightsaber.ButtonView({
                        viewModel: new Lightsaber.ActionViewModel({
                            data:{
                                label : "Hide Content"
                            }
                        }),
                         config: {
                            className: 'ui-btn-right',
                            tagName: 'a'
                         },
                         id:'mytestbutton'
                     })
                  }
               ]
 *          }
 *      });
 *      $('#headerDiv').append(headerView.el); // add the header view element to DOM
 */
define('src/components/header/view/HeaderView',['jquery','underscore', 'lightsaber.core', 'text!./template/header.html'],
	function($,_, LightsaberCore, headerTemplate) {

		var HeaderView = LightsaberCore.View.extend({

			vmKeys : {
				"data.title" : "title"
			},
			config: {
				autoRefresh: true,
				template: _.template(headerTemplate),
				"data.title" : ""
			},

			_enhanceMarkup : function() {
				this.$el.trigger('create');
			}

		});

		return HeaderView;

	});

define('text!src/components/forminput/view/template/input_template.html',[],function () { return '<div class="uxf-input">\n\t<legend data-uxf-point="myLegend"><%=legend%></legend>\n\t<fieldset data-uxf-point="myInput"></fieldset>\n\t<div data-uxf-point="LS-error" class="LS-error is-hidden"></div>\n</div>\n';});


define('text!src/components/forminput/view/template/minimal_input_template.html',[],function () { return '<span class="uxf-minimalinput">\n\t<span data-uxf-point="myInput"></span>\n</span>\n';});


define('text!src/components/forminput/view/template/textInput_template.html',[],function () { return '<span class="uxf-textinput">\n<label for="<%=id%>"><%=display%></label><input data-uxf-point="myElement" type="<%=type%>" id="<%=id%>" name="<%=name%>" value="<%=value%>"></input>\n</span>';});

/**
Base UXF <em>Base Form Input</em> component. All specific components (like <em>RadioButton</em>) extend from it.
 
This is the base component for **all** form elements - radio buttons, checkboxes etc. for both *Mobile* and *Web* touch-points.
It provides the basic functionality and handling of events.


@class Lightsaber.Mobile.BaseFormElementView
@namespace Lightsaber.Mobile
@module Lightsaber.Mobile
@extends Lightsaber.Core.View

@since 9.0.0
@private

@requires jquery
@requires underscore
@requires backbone
@requires Lightsaber.Core

@constructor
@param {Object} options constructor's only parameter
@param {String|HTML Element|jQuery Object} [options.el] the element to attach to
@param {Lightsaber.Core.ViewModel} options.viewModel <em>ViewModel</em> that the <em>View</em> is going to use
@param {Object} options.vmKeys mapping of expected name of *ViewModel* 
property to its actual name in the specific *ViewModel* that this *View* 
receives at runtime, with default value of:  
___
```javascript
{
	'data.label': 'label',
	'data.legend': 'legend',
	'data.fieldValue': 'fieldValue',
	'data.defaultValue': 'defaultValue'
}
```
@param {Object} options.vmKeysChangeEvents mapping of expected name of *ViewModel* 
event to its actual name in the specific *ViewModel* that this *View* 
receives at runtime, with default value of:  
___
```javascript
{
	'data.label': '_valueChanged',
	'data.legend': '_valueChanged',
	'data.fieldValue: '_valueChanged',
	'data.defaultValue: '_valueChanged'
}
```
@param {Object} [options.config={}] main configuration parameter
@param {Object} [options.config.template] element's template
@param {Object} [options.config.inputAttributes={}] attributes that will be set on the input elements (maxLength, type, size, etc.) 
for now, attributes can be updated by the setConfig but cannot be deleted
@param {String} [options.config.template=""] template for the element; should have the "myInput" in case the input should be set from 
inner template
@param {String} [options.config.elementTemplate=""] template for the input element; this will override the default template for the element
@param {String} [options.config.legend=""] value for the legend                                                     
@param {Function} [options.config.errorHandler=null] error handler that receives the *model* and *error* as parameters; if handler returns `true` - 
also populates error message
@param {Function} [options.config.errorRemoveHandler=null] error removal handler; if supplied it will be used instead of the default `_removeError`
@param {Boolean} [options.config.useErrorClass=false] set to true if error message display/hide is done via associated CSS classes

@examples none

**/
define('src/components/forminput/view/BaseFormElementView',[
    'jquery',
    'underscore',
    'backbone',
	'lightsaber.core',
	'text!./template/input_template.html',
	'text!./template/minimal_input_template.html',
	'text!./template/textInput_template.html'
], function($, _, Backbone, Lightsaber, inputTemplate, minimumInputTemplate, elementTemplate) {

	
	
    
	var BaseFormElementView = Lightsaber.View.extend({

				
		publicMethods : ['getData','refresh'],
		/**
		Events defined over the *Form Elements*.
		###### Default:
		```json
		{
			'vclick [data-uxf-point="myElement"]': '_clicked',
			'dblclick [data-uxf-point="myElement"]': '_clicked',
			'focusin [data-uxf-point="myElement"]': '_clicked',
			'focus [data-uxf-point="myElement"]': '_clicked',		
			'blur [data-uxf-point="myElement"]': '_unfocus',
			'focusout [data-uxf-point="myElement"]': '_unfocus',
			'keyup [data-uxf-point="myElement"]': '_keyboard',
			'keydown [data-uxf-point="myElement"]': '_keyboard',
			'change [data-uxf-point="myElement"]': '_changed'
		}
		```
		@property {Object} events
		**/
		events : {
			'vclick [data-uxf-point="myElement"]' 	: '_clicked',
			'dblclick [data-uxf-point="myElement"]' 	: '_clicked',
			'focusin [data-uxf-point="myElement"]' 	: '_clicked',
			'focus [data-uxf-point="myElement"]' 		: '_clicked',		
			'blur [data-uxf-point="myElement"]'		: '_unfocus',
			'focusout [data-uxf-point="myElement"]'	: '_unfocus',
			'keyup [data-uxf-point="myElement"]'		: '_keyboard',
			'keydown [data-uxf-point="myElement"]'	: '_keyboard',
			'change [data-uxf-point="myElement"]' 	: '_changed'
		},

		/**
		`vmKeys` property.
		
		###### Default:

		```json
		{
			'data.label': 'label',
			'data.legend': 'legend',
			'data.fieldValue': 'fieldValue',
			'data.defaultValue': 'defaultValue'
		}
		```
		@property {Object} vmKeys
		**/
		vmKeys: {
			"data.label"					: "label",
			"data.legend"					: "legend",
			"data.fieldValue" 				: "fieldValue",
			"data.defaultValue" 			: "defaultValue",
			// below is for backwards compatibility, should be configuration of the view at some point
			"config.collectionViewModel" 	: "collectionViewModel",
			"config.optionsModelName" 		: "optionsModelName",
			"config.optionsValueFieldName"	: "optionsValueFieldName",
			"config.optionsDisplayFieldName": "optionsDisplayFieldName"
		},

		/**
		`vmKeysChangeEvents` property.
		
		###### Default:

		```json
		{
			'data.label': '_valueChanged',
			'data.legend': '_valueChanged',
			'data.fieldValue': '_valueChanged',
			'data.defaultValue': '_valueChanged'
		}
		```
		@property {Object} vmKeysChangeEvents
		**/
		vmKeysChangeEvents: {
			"data.label"		: "_valueChanged",
			"data.legend"		: "_valueChanged",
			"data.fieldValue"	: "_valueChanged",
			"data.defaultValue"	: "_valueChanged"
		},
		
		/**
		@private
		**/
		isClicked : false,

		/**
		Main-entry method.

		The main functional purpose is to bind handlers to events that *ViewModel* triggers: 

		* `error` - {{#crossLink "Lightsaber.Mobile.BaseFormElementView/_error"}}{{/crossLink}}
		* `items:loaded` - {{#crossLink "Lightsaber.Mobile.BaseFormElementView/refresh"}}{{/crossLink}}

		@method initialize
		@protected
		**/
		preRender: function() {
			this.isClicked = false;
			this.inputAttr = null;
			this.viewData = null;
			this.type = null;
			
			if (this.getConfig("template")) {
				this.template = this.getConfig("template");
			} else if (this.getConfig("isMinimalTemplate")) {
				this.template = _.template(minimumInputTemplate);
			} else {
				this.template = _.template(inputTemplate);
			}

			//  checking for model for multiple options
			this._handleCollectionForMultipleChoices();			
		},

		/**
		`config` property.
		
		@property {Object} config
		@default {}
		**/
		config: {
			optionsValueFieldName : "value",
			optionsDisplayFieldName : "name"
		},
		
		/**
		@private
		**/
		getData : function() {
			// getting the plain data first
			var returnObj = {
				"label": this._getVMData("data.label"),
				"legend": this._getVMData("data.legend"),
				"fieldValue" : this._getVMData("data.fieldValue"),
				"defaultValue" : this._getVMData("data.defaultValue")
			};
			// adding the select options if we have them
			if (this.selectModel != null || this.collectionView != null) {
				var items = null;
				if(this.selectModel != null) {
					items = this.selectModel.toJSON();
				} else if (this.collectionView != null) {
					items = this.collectionView.getData().items;
				}
				var optionsData = {items : items};
				optionsData.valueField 	= this._getVMConfig("config.optionsValueFieldName") || this.getConfig("optionsValueFieldName");
				optionsData.nameField 	= this._getVMConfig("config.optionsDisplayFieldName") || this.getConfig("optionsDisplayFieldName");
				returnObj.optionsData = optionsData;
				
			}
			return returnObj;
		},

		/**
		@deprecated
		**/
		configChanged : function(data) {
			// only handling configuration changes on the input element
			if (this.inputElement != null) {
				var inputAttr = this._getClonedInputAttributes();
				this._handleInputAttributes(inputAttr, this.getData());
				this._setPropertiesAndValue(inputAttr,this.inputElement);
				this.inputElement.attr(inputAttr);
				this._postRenderFormElement(this.inputElement);
			}
		},

		/**
		Refreshed the *Form Element* after changes to data/configuration are done via *ViewModel*.

		@method refresh
		@protected 
		**/
		refresh : function() {
			var inputAttr = this.inputAttr;
			// getting the type. saving it since we will delete it from the input attributes in a bit.
			var type = this._getType(inputAttr);
			var viewData = this.getData();
			viewData = _.extend({refresh: true}, viewData, this.getConfig());
			// update data if specific requirements per element
			this._updateDataForElement(inputAttr, viewData, type);
		},

		/**        
        Handles the change of the `enable` property of the *ViewModel*.

        @method onEnableChange
        @protected
        @param {ViewModel Event} event the `change`/`enable` event
        **/
		onEnableChange : function(event) {
			if (this.inputElement != null) {
				var attrValue = this.viewModel.getConfig("enabled") ? false : true;
				this.inputElement.prop("disabled", attrValue);
			}
		},

		/**        
        Handles the change of the `visible` property of the *ViewModel*.

        @method onEnableChange
        @protected
        @param {ViewModel Event} event the `change`/`visible` event
        **/
		onVisibleChange : function(event) {
			var isVisible = (this.viewModel.getConfig("visible") == true);
			if (isVisible) {
				this.$root.show();
			} else {
				this.$root.hide();					
			}
		},
		
		/**
		@private
		**/
		_getClonedInputAttributes : function() {
			var inputAttr = {};
			if (this.getConfig("inputAttributes")) {
				inputAttr = _.clone(this.getConfig("inputAttributes"));				
			} 
			return inputAttr;
		},

		/**
		@private
		**/
		_handleCollectionForMultipleChoices : function() {
	        // checking for select model for multiple options, either as a named model
	        // or as a collection view.
	        this.selectModel = null;
			this.collectionView = this.getConfig("collectionViewModel");;
			// handling updates on the collection to build the selectables
			if (this.collectionView != null) {
				// this.collectionView.on("all", this.refresh, this);	
			} else {
		        var modelName = this.getConfig("optionsModelName") || 
		        	this._getVMConfig("config.optionsModelName") || 
		        	this._getVMData("data.optionsModelName");
				if (modelName != null) {
					this.selectModel = this.viewModel.models[modelName];
					// handling the events on this model in case it changes
					// this.selectModel.on("all", this.refresh, this);	
				}
			}
			
		},

		_handleTemplate: function(refresh) {
			var data = this._createTemplateData();
			var filledTemplate = this.getPopulatedTemplate(this.template, data);
			this.placeRoot(filledTemplate, refresh? true : false);
			this._updateDataForElement(this.inputAttr, this.viewData, this.type);
			this._normalizeRootDomEl();
		},

		/**
        Creates static data into the context that is used to render *Form element* template.

        Injects `type` (as in `<input type="text">`).

        @method _createTemplateData
        @protected
        @return {Object} object (`{}` by default) to be injected into the context
        **/
		_createTemplateData : function() {
			this.inputAttr = this._getClonedInputAttributes()
			// getting the type. saving it since we will delete it from the input attributes in a bit.
			this.type = this._getType(this.inputAttr);
			// update data if specific requirements per element
			this.viewData = this.getData();
			this.viewData = _.extend({}, this.viewData, this.getConfig());
			return this._getTemplateObject(this.inputAttr, this.viewData);
		},

		/**
		Initializes *Form Element's* template (precomiles it and decides on which one to use).

        @method preRender
        @protected
        **/
		// _preRender : function() {
		// 	if (this.getConfig("template")) {
		// 		this.template = this.getConfig("template");
		// 	} else if (this.getConfig("isMinimalTemplate")) {
		// 		this.template = _.template(minimumInputTemplate);
		// 	} else {
		// 		this.template = _.template(inputTemplate);
		// 	}
		// },
		
		/**
		Renders the actual form element DOM, along with error placeholder enhancement and styling
		changes, where necessary. 

		Calls to {{#crossLink "Lightsaber.Mobile.BaseFormElementView/onEnableChange"}}{{/crossLink}} and
		{{#crossLink "Lightsaber.Mobile.BaseFormElementView/onVisibleChange"}}{{/crossLink}} to verify that
		the state is consistent.

        @method postRender
        @protected
        **/
		_postRender: function (){
			// adding the actual form element(s)
			this._renderFormElement(this.inputAttr, this.viewData, this.type);
			
			// saving reference to input and error element for later
			this.inputElement = this.$root.find('[data-uxf-point="myElement"]');
			this.errorElement = this.$root.find('[data-uxf-point="LS-error"]');
			this._postRenderFormElement(this.inputElement);
			
			// checking the value of the element and the value on the model are consistent
			var inputVal = this._getValue();
			if (this.viewData.fieldValue && inputVal != this.viewData.fieldValue) {
				this._setVMData("data.fieldValue", inputVal);
			}
			// handling styling
			this._applyStyling();
			// setting visibility and stuff from viewmodel
			this.onEnableChange();
			this.onVisibleChange();
			// adding events
			this.viewModel.on("error", this._error, this); // For backward compatibility!!!
			this.viewModel.on("error:"+this.vmKeys["data.fieldValue"], this._error, this);
			this.viewModel.on("warning:"+this.vmKeys["data.fieldValue"], this._error, this);
			this.viewModel.on("bindingError:"+this.vmKeys["data.fieldValue"], this._error, this);
			this.viewModel.on("bindingWarning:"+this.vmKeys["data.fieldValue"], this._error, this);
			
			this.viewModel.on('items:loaded', this.refresh, this);

			if(this.collectionViewModel) {
				this.collectionView.on("all", this.refresh, this);	
			} else if(this.selectModel) {
				this.selectModel.on("all", this.refresh, this);					
			}
		},
		
		/**
		Renders the actual form element DOM, along with error placeholder enhancement and styling
		changes, where necessary. 

		Calls to {{#crossLink "Lightsaber.Mobile.BaseFormElementView/onEnableChange"}}{{/crossLink}} and
		{{#crossLink "Lightsaber.Mobile.BaseFormElementView/onVisibleChange"}}{{/crossLink}} to verify that
		the state is consistent.

        @method _handleInputAttributes
        @protected
        @param {Object} inputAttributes attributes to apply to the form element's DOM element
        @param {Object} viewdata data to use for templates, where applicable
        **/
		_handleInputAttributes : function(inputAttributes, viewdata) {
			// removing the type element since it cannot be templated 
			if (inputAttributes["type"]) delete inputAttributes["type"];				
			//and setting the id to the cid of the view if we did not get ir
			if (inputAttributes["id"] == null) inputAttributes["id"] = this.cid;
			// setting name to id if we did not get it
			if (inputAttributes["name"] == null) inputAttributes["name"] = inputAttributes["id"];
			// setting the value
			inputAttributes["value"] = this._getElementInitialValue(inputAttributes, viewdata);
			// doing specific work per form element
			this._handleElementSpecificInputAttributes(inputAttributes, viewdata);
		},

		/**
		@private
		**/
		_getElementInitialValue : function(inputAttr, viewData) {
			var inputvalue = inputAttr["value"];
			if (inputvalue == null) {
				if (viewData.fieldValue != null) {
					inputvalue = viewData.fieldValue;				
				} else if (viewData.defaultValue != null) {
					inputvalue = viewData.defaultValue;								
				}
			}
			return inputvalue;
		},

		/**
		@private
		**/
		_getTemplateObject : function(inputAttr, viewData, type) {
			var inputObj = _.extend({}, inputAttr, {
					type : type,
					id : inputAttr["id"],
					name : inputAttr["name"],
					value : inputAttr["value"],
					display : viewData.label,
					legend : viewData.legend
			});
			return inputObj;
		},

		/**
		@private
		**/
		_renderFormElement : function (inputAttr, viewData, type) {
			var placeholder = this.$root.find('[data-uxf-point="myInput"]');
			this._handleInputAttributes(inputAttr, viewData);
			if (placeholder != null) {
				var elementTemplate = this.getConfig("elementTemplate") || this._getElementTemplate();
				elementTemplate = _.template(elementTemplate);

				this.createElement( placeholder, elementTemplate, inputAttr, viewData, type );
			}
			this.binding.bindDOM(this); // bind declarative DOM			
		},

		/**
		Creates the actual DOM element.

		@method createElement
		@protected
		@param {String} placeholder placeholder attribute string
		@param {String} elementTemplate DOM element template
		@param {Array} inputAttr input attributes to be applied to the DOM element
		@param {Objec} viewData view data to be used during templating
		@param {String} type HTML element type
		**/
		createElement : function ( placeholder, elementTemplate, inputAttr, viewData, type ) {
			var inputObj = this._getTemplateObject(inputAttr, viewData, type);
			var htmlElem = this.getPopulatedTemplate(elementTemplate, inputObj);
			placeholder.append(htmlElem);
			// finding it again since setting attributes on the htmlElem does not work
			var inputElem = this.$root.find("input");

			// value should be handled using "val()" and the rest must be handled via "prop" and not "attr"
			this._setPropertiesAndValue(inputAttr,inputElem);

			inputElem.attr(inputAttr); 
		},

		/**
		No-op.

		Post-form element's DOM rendering hook.

		May be overridden by extending classes.

        @method _postRenderFormElement
        @protected
        **/
		_postRenderFormElement : function (inputElement) {},

		/**
		Handler for `click` event.

        @method _clicked
        @protected
        @param {jQuery Event} event the original *jQuery* event
        **/
		_clicked: function(evt) {
			if (!this.isClicked) {
				this.isClicked  = true;
				this.trigger("clicked", {event : evt});
			}
		},

		/**
		Handler for `blur` event.

        @method _unfocus
        @protected
        @param {jQuery Event} event the original *jQuery* event
        **/
		_unfocus : function(evt) {
			this.isClicked = false;
		},

		/**
		Handler for `key-*` event.

        @method _keyboard
        @protected
        @param {jQuery Event} event the original *jQuery* event
        **/
		_keyboard: function(evt) {
			this.trigger("keyboard", {event : evt, value: this._getValue()});
		},

		/**
		Handler for `change` event.

        @method _changed
        @protected
        @param {jQuery Event} event the original *jQuery* event
        **/
		_changed: function(evt, val) {
			this._removeError();
			if (val == null) {
				val =  this._getValue(evt);				
			}
			this._setVMData("data.fieldValue", val);
			this.trigger("changed:value", {event : evt, value: val});
		},	

		/**
		Handler for *ViewModel's* `change` event.

        @method _valueChanged
        @protected
        @param {ViewModel Event} event the original *ViewModel* event
        **/
		_valueChanged: function(event) {
			// we will only allow an update of the text in case it has changed, label and default value cannot be changed
			var text = this._getVMData("data.fieldValue");
			if (text != this._getValue()) {
				!event._warningWasFound && this._removeError();
				this._setValue(text);				
			}
		},	

		/**
		@private
		**/
		_removeError : function() {
			var errorRemoveHandler = this.getConfig("errorRemoveHandler");
			if (errorRemoveHandler && !errorRemoveHandler(this)) {
				return;
			}
			if (this.errorElement != null) {
				if (this.getConfig('useErrorClass')) {
					this.errorElement.removeClass('is-visible').addClass('is-hidden');
				} else {
					this.errorElement.hide();
				}
			}
		},

		/**
		@private
		**/
		_getErrorText : function( key, conf ) {
			var text = undefined;
			
			try { text = this._getLocaleString( key, conf);	} catch(e) {}
			
			return text;
		},

		/**
		@private
		**/
		validationErrorTextHandler : function( errorTextKey, error) {
			
			if (error.errors && error.errors.length)
				error = error.errors[0];
			else if (error.warnings && error.warnings.length)
				error = error.warnings[0];
			
			var text = (errorTextKey && 
							(this._getErrorText( errorTextKey + '.' + error.status, error.conf ) ||	this._getErrorText( errorTextKey, error.conf ))) ||
						this._getErrorText( error.status, error.conf ) ||
						error.statusText;

			return text;
		},

		/**
		Handler for *ViewModel's* `error` event (from *Model's* validations, normally).

        @method _error
        @protected
        @param {ViewModel Event} event the original *ViewModel* event
        **/
		_error: function (vm, error, options) {
			var errorHandler = this.getConfig("errorHandler");
			if (errorHandler) {
				if (! errorHandler(vm, error, this) )
					return;
			}
			if (this.errorElement != null) {
				var errorText = "";
				var errorTextKey = this.getConfig("errorTextKey");
				var errorTextHandler = this.getConfig("errorTextHandler");
				
				if (errorTextHandler)
					errorText = errorTextHandler(vm, error, options);													
				else if (error.source === 'validation')
					errorText = this.validationErrorTextHandler( errorTextKey, error, options);
				else if (errorTextKey)
					errorText = this._getErrorText( errorTextKey );
				else if ( typeof error === 'string')
					errorText = error;

				this.errorElement.text(errorText);					
				if (this.getConfig('useErrorClass')) {
					this.errorElement.removeClass('is-hidden').addClass('is-visible');
				} else {
					this.errorElement.show();
				}
			}
		},

		/**
		@private
		**/
		_setPropertiesAndValue : function(inputAttr, inputElem) {
			if (inputAttr["value"]) {
				inputElem.val(inputAttr["value"]);
				delete inputAttr["value"];
			}
			if (inputAttr["checked"]) {
				inputElem.prop("checked", inputAttr["checked"]);
				delete inputAttr["checked"];
			} 
			if (inputAttr["disabled"]) {
				inputElem.prop("disabled",inputAttr["disabled"]);
				delete inputAttr["disabled"];
			}

		},

		/**
		No-op.
	
		May be overridden by extending classes.

		@deprecated
		**/
		_handleMultipleOptionsElement : function() {},

		/**
		Retrieves the type of the *Form Element*.
	
		@method _getType
		@protected
		**/
		_getType : function(inputAttr) {
			return (inputAttr["type"]) ? inputAttr["type"] :"text";
		},

		/**
		Retirieves element template - defined by `config.elementTemplate` configuration property.

		@method _getElementTemplate
		@protected
		@return {String} element template
		**/
		_getElementTemplate : function() {
			return elementTemplate;
		},

		/**
		Retirieves element value.

		@method _getValue
		@protected
		@return {String} element value
		**/
		_getValue : function(evt) {
			return this.inputElement && this.inputElement.val();
		},

		/**
		Sets element value.

		@method _setValue
		@protected
		@praram {String} element value
		**/
		_setValue : function(val) {
			this.inputElement.val(val);
		},

		/**
		No-op.

		Called during creation of DOM element in {{#crossLink "Lightsaber.Mobile.BaseFormElementView/_handleInputAttributes:method"}}{{/crossLink}}.

		Intended to be overriden by extending classes.

		@method _handleElementSpecificInputAttributes
		@protected
		@param {Array} inputAttr input attributes to be applied to the DOM element
		@param {Objec} viewData view data to be used during templating
		**/
		_handleElementSpecificInputAttributes : function(inputAttributes, viewdata) {},

		/**
		Updates the actual DOM element.

		@method createElement
		@protected
		@param {Array} inputAttr input attributes to be applied to the DOM element
		@param {Objec} viewData view data to be used during templating
		**/
		_updateDataForElement : function(inputAttr, viewData, type) {},

		/**
		No-op.

		Applies style.

		@protected
		**/
		_applyStyling : function() {}
	});

	return BaseFormElementView;

});

/**
Base UXF <em>Base Form Input</em> component. All specific components (like <em>RadioButton</em>) extend from it.
 
This is the base component for **all** form elements - radio buttons, checkboxes etc. for both *Mobile* and *Web* touch-points.
It provides the basic functionality and handling of events.

@class Lightsaber.Web.FormElementTouchpointBaseView
@namespace Lightsaber.Web
@module Lightsaber.Web
@extends Lightsaber.Mobile.BaseFormElementView

@since 9.0.0
@private

@requires jquery
@requires underscore
@requires backbone
@requires Lightsaber.Core

@constructor
@param {Object} options constructor's only parameter
@param {Lightsaber.Core.ViewModel} options.viewModel <em>ViewModel</em> that the <em>View</em> is going to use
@param {String|HTML Element|jQuery Object} [options.el] the element to attach to
@param {Object} options.vmKeys mapping of expected name of *ViewModel* 
property to its actual name in the specific *ViewModel* that this *View* 
receives at runtime, with default value of:  
___
```javascript
{
	'data.label': 'label',
	'data.legend': 'legend',
	'data.fieldValue': 'fieldValue',
	'data.defaultValue': 'defaultValue'
}
```
@param {Object} options.vmKeysChangeEvents mapping of expected name of *ViewModel* 
event to its actual name in the specific *ViewModel* that this *View* 
receives at runtime, with default value of:  
___
```javascript
{
	'data.label': '_valueChanged',
	'data.legend': '_valueChanged',
	'data.fieldValue: '_valueChanged',
	'data.defaultValue: '_valueChanged'
}
```
@param {Object} [options.config={}] main configuration parameter
@param {Object} [options.config.template] element's template
@param {Object} [options.config.inputAttributes={}] attributes that will be set on the input elements (maxLength, type, size, etc.) 
for now, attributes can be updated by the setConfig but cannot be deleted
@param {String} [options.config.template=""] template for the element; should have the "myInput" in case the input should be set from 
inner template
@param {String} [options.config.elementTemplate=""] template for the input element; this will override the default template for the element
@param {String} [options.config.legend=""] value for the legend
@param {Boolean} [options.config.isMinimalTemplate=true] set to true if the view should only return the element with the input without label and error; 
can be used a number of elements should be grouped together                                                            
@param {Function} [options.config.errorHandler=null] error handler that receives the error as input; if handl returns `true` - 
also populates error message
@param {Function} [options.config.errorTextHandler=null] function that can be used in order to translate error text for the view
@param {String} [options.config.errorTextKey=null] the *Resource Bundle's* key of the error text
@param {Function} [options.config.errorRemoveHandler=null] error removal handler; if supplied it will be used instead of the default `_removeError`
@param {Boolean} [options.config.useErrorClass=false] set to true if error message display/hide is done via associated CSS classes

@examples none

**/
define('src/components/forminput/view/FormElementTouchpointBaseView',[
	    'jquery',
	    'underscore',
	    'backbone',
		'lightsaber.core',
		'src/components/forminput/view/BaseFormElementView',
		'text!./template/textInput_template.html'], 
function($, _, Backbone, Lightsaber, BaseFormElementView, InputTemplate) {

	
	var baseElementMobile = BaseFormElementView.extend({
	    	});

	return baseElementMobile;

});

/**
<em>Input Form Element</em> component.

## Template

```html
<span class="uxf-textinput">
	<label for="<%=id%>"><%=display%></label>
	<input data-uxf-point="myElement" type="<%=type%>" id="<%=id%>" name="<%=name%>" value="<%=value%>"></input>
</span>
```

@class Lightsaber.Mobile.InputTextView
@namespace Lightsaber.Mobile
@module Lightsaber.Mobile
@extends Lightsaber.Mobile.FormElementTouchpointBaseView

@since 9.0.0

@requires jquery
@requires underscore
@requires backbone
@requires Lightsaber.Core

@constructor
@param {Object} options constructor's only parameter
@param {Lightsaber.Core.ViewModel} options.viewModel <em>ViewModel</em> that the <em>View</em> is going to use
@param {String|HTML Element|jQuery Object} [options.el] the element to attach to
@param {Object} options.vmKeys mapping of expected name of *ViewModel* 
property to its actual name in the specific *ViewModel* that this *View* 
receives at runtime, with default value of:  
___
```javascript
{
	'data.label': 'label',
	'data.legend': 'legend',
	'data.fieldValue': 'fieldValue',
	'data.defaultValue': 'defaultValue'
}
```
@param {Object} options.vmKeysChangeEvents mapping of expected name of *ViewModel* 
event to its actual name in the specific *ViewModel* that this *View* 
receives at runtime, with default value of:  
___
```javascript
{
	'data.label': '_valueChanged',
	'data.legend': '_valueChanged',
	'data.fieldValue: '_valueChanged',
	'data.defaultValue: '_valueChanged'
}
```
@param {Object} [options.config={}] main configuration parameter
@param {Object} [options.config.template] element's template
@param {Object} [options.config.inputAttributes={}] attributes that will be set on the input elements (maxLength, type, size, etc.) 
for now, attributes can be updated by the setConfig but cannot be deleted
@param {String} [options.config.template=""] template for the element; should have the "myInput" in case the input should be set from 
inner template
@param {String} [options.config.elementTemplate=""] template for the input element; this will override the default template for the element
@param {String} [options.config.legend=""] value for the legend                                                
@param {Function} [options.config.errorHandler=null] error handler that receives the model and error as parameters; if handler returns `true` - 
also populates error message
@param {Function} [options.config.errorRemoveHandler=null] error removal handler; if supplied it will be used instead of the default `_removeError`
@param {Boolean} [options.config.useErrorClass=false] set to true if error message display/hide is done via associated CSS classes

**/
define('src/components/forminput/view/InputTextView',[
    'jquery',
    'underscore',
    'backbone',
	'lightsaber.core',
	'src/components/forminput/view/FormElementTouchpointBaseView',
	'text!./template/textInput_template.html'], 
function($, _, Backbone, Lightsaber, FormElementTouchpointBaseView, ElementTemplate) {

    
    
    
	var InputTextView = FormElementTouchpointBaseView.extend({

	    
		_jqueryMobilePluginType: 'textinput',

		/**
		@private
		**/
		_getType : function(inputAttr) {
			// text can also support other types such as password
			return (inputAttr["type"]) ? inputAttr["type"] :"text";
		},

		/**
		@private
		**/
		_getElementTemplate : function() {
			return ElementTemplate;
		}

	});

	InputTextView.widgetName = 'uxf.uxfinputtext';

	return InputTextView;

});


define('text!src/components/forminput/view/template/textArea_template.html',[],function () { return '<span class="uxf-textarea">\n\t<label for="<%=id%>"><%=display%></label>\n\t<textarea id="<%=id%>" name="<%=name%>" data-uxf-point="myElement"><%=value%></textarea> \n</span>';});

/**
<em>Input Form Textaread</em> component.

## Template

```html
<span class="uxf-textarea">
	<label for="<%=id%>"><%=display%></label>
	<textarea id="<%=id%>" name="<%=name%>" data-uxf-point="myElement"><%=value%></textarea> 
</span>
```

@class Lightsaber.Mobile.InputTextAreaView
@namespace Lightsaber.Mobile
@module Lightsaber.Mobile
@extends Lightsaber.Mobile.FormElementTouchpointBaseView

@since 9.0.0

@requires jquery
@requires underscore
@requires backbone
@requires Lightsaber.Core

@constructor
@param {Object} options constructor's only parameter
@param {Lightsaber.Core.ViewModel} options.viewModel <em>ViewModel</em> that the <em>View</em> is going to use
@param {String|HTML Element|jQuery Object} [options.el] the element to attach to
@param {Object} options.vmKeys mapping of expected name of *ViewModel* 
property to its actual name in the specific *ViewModel* that this *View* 
receives at runtime, with default value of:  
___
```javascript
{
	'data.label': 'label',
	'data.legend': 'legend',
	'data.fieldValue': 'fieldValue',
	'data.defaultValue': 'defaultValue'
}
```
@param {Object} options.vmKeysChangeEvents mapping of expected name of *ViewModel* 
event to its actual name in the specific *ViewModel* that this *View* 
receives at runtime, with default value of:  
___
```javascript
{
	'data.label': '_valueChanged',
	'data.legend': '_valueChanged',
	'data.fieldValue: '_valueChanged',
	'data.defaultValue: '_valueChanged'
}
```
@param {Object} [options.config={}] main configuration parameter
@param {Object} [options.config.template] element's template
@param {Object} [options.config.inputAttributes={}] attributes that will be set on the input elements (maxLength, type, size, etc.) 
for now, attributes can be updated by the setConfig but cannot be deleted
@param {String} [options.config.template=""] template for the element; should have the "myInput" in case the input should be set from 
inner template
@param {String} [options.config.elementTemplate=""] template for the input element; this will override the default template for the element
@param {String} [options.config.legend=""] value for the legend                                                
@param {Function} [options.config.errorHandler=null] error handler that receives the model and error as parameters; if handler returns `true` - 
also populates error message
@param {Function} [options.config.errorRemoveHandler=null] error removal handler; if supplied it will be used instead of the default `_removeError`
@param {Boolean} [options.config.useErrorClass=false] set to true if error message display/hide is done via associated CSS classes

**/
define('src/components/forminput/view/InputTextAreaView',[
    'jquery',
    'underscore',
    'backbone',
	'lightsaber.core',
	'src/components/forminput/view/FormElementTouchpointBaseView',
	'text!./template/textArea_template.html'], 
function($, _, Backbone, Lightsaber, FormElementTouchpointBaseView, ElementTemplate) {

    
    
    
	var InputTextAreaView = FormElementTouchpointBaseView.extend({

	    		
		_jqueryMobilePluginType: 'textinput',

		/**
		@private
		**/
		_getType : function(inputAttr) {
			// text can also support other types such as password
			return null;
		},

		/**
		@private
		**/
		_getElementTemplate : function() {
			return ElementTemplate;
		},

		/**
		@protected
		**/
		createElement : function ( placeholder, elementTemplate, inputAttr, viewData, type ) {
			var inputObj = this._getTemplateObject(inputAttr, viewData, type);
			var htmlElem = this.getPopulatedTemplate(elementTemplate, inputObj);
			placeholder.append(htmlElem);
			// finding it again since setting attributes on the htmlElem does not work
			var inputElem = this.$root.find("textarea");

			// value should be handled using "val()" and the rest must be handled via "prop" and not "attr"
			this._setPropertiesAndValue(inputAttr,inputElem);

			inputElem.attr(inputAttr);
		}

	});
	return InputTextAreaView;

});


define('text!src/components/forminput/view/template/clickInput_template.html',[],function () { return '<span class="uxf-clickinput">\n<input data-uxf-point="myElement" type="<%=type%>" value="<%=value%>" name="<%=name%>" id="<%=id%>"></input>\n<label for="<%=id%>"><%=display%></label>\n</span>\n';});

/**
<em>Checkbox Form Element</em> component.

## Template (`type` is `radio`)

```html
<span class="uxf-clickinput">
	<input data-uxf-point="myElement" 
		type="<%=type%>" value="<%=value%>" name="<%=name%>" id="<%=id%>"></input>
	<label for="<%=id%>"><%=display%></label>
</span>
```

@class Lightsaber.Mobile.CheckboxView
@namespace Lightsaber.Mobile
@module Lightsaber.Mobile
@extends Lightsaber.Mobile.FormElementTouchpointBaseView

@since 9.0.0

@requires jquery
@requires underscore
@requires backbone
@requires Lightsaber.Core

@constructor
@param {Object} options constructor's only parameter
@param {String|HTML Element|jQuery Object} [options.el] the element to attach to
@param {Lightsaber.Core.ViewModel} options.viewModel <em>ViewModel</em> that the <em>View</em> is going to use
@param {Object} options.vmKeys mapping of expected name of *ViewModel* 
property to its actual name in the specific *ViewModel* that this *View* 
receives at runtime, with default value of:  
___
```javascript
{
	'data.label': 'label',
	'data.legend': 'legend',
	'data.fieldValue': 'fieldValue',
	'data.defaultValue': 'defaultValue'
}
```
@param {Object} options.vmKeysChangeEvents mapping of expected name of *ViewModel* 
event to its actual name in the specific *ViewModel* that this *View* 
receives at runtime, with default value of:  
___
```javascript
{
	'data.label': '_valueChanged',
	'data.legend': '_valueChanged',
	'data.fieldValue: '_valueChanged',
	'data.defaultValue: '_valueChanged'
}
```
@param {Object} [options.config={}] main configuration parameter
@param {Object} [options.config.template] element's template
@param {Object} [options.config.inputAttributes={}] attributes that will be set on the input elements (maxLength, type, size, etc.) 
for now, attributes can be updated by the setConfig but cannot be deleted
@param {String} [options.config.template=""] template for the element; should have the "myInput" in case the input should be set from 
inner template
@param {String} [options.config.elementTemplate=""] template for the input element; this will override the default template for the element
@param {String} [options.config.legend=""] value for the legend                                                
@param {Function} [options.config.errorHandler=null] error handler that receives the model and error as parameters; if handler returns `true` - 
also populates error message
@param {Function} [options.config.errorRemoveHandler=null] error removal handler; if supplied it will be used instead of the default `_removeError`
@param {Boolean} [options.config.useErrorClass=false] set to true if error message display/hide is done via associated CSS classes

@param {ViewModel} [options.config.collectionViewModel=null]  *CollectionViewmodel* to be used for the multiple values
@param {String} [options.config.optionsModelName='']  name of the model to be used for the multiple values
@param {String} [options.config.optionsValueFieldName='value'] name of the field in the collection that will have the value for multiple options
@param {String} [options.config.optionsDisplayFieldName='value'] name of the field in the collection that will have the display name for multiple options

**/
define('src/components/forminput/view/CheckboxView',[
	'jquery',
	'underscore',
	'backbone',
	'lightsaber.core',
	'src/components/forminput/view/FormElementTouchpointBaseView',
	'text!./template/clickInput_template.html'
], function($, _, Backbone, Lightsaber, FormElementTouchpointBaseView, ElementTemplate) {

	
	
    
	var CheckboxView = FormElementTouchpointBaseView.extend({

	    
		_jqueryMobilePluginType: 'checkboxradio',
		
		_getType : function() {
			return "checkbox";
		},
		_getElementTemplate : function() {
			return ElementTemplate;
		},

		/***
		 * Gets the value from the checkbox. 
		 * will get concatenated values by "," if there are multiple options
		 */
		_getValue : function(evt) {
			// in case we have a multiple checkbox situation, we will send back an array
			var val = new Array();
			var myInput = this._getInputElementsArray();
			// getting the selected values
			for (var i=0;i<myInput.length;i++) {
				var myInputElem = $(myInput[i]);
				var checked = myInputElem.prop("checked");
				if (checked) {
					// setting escaped value
					val[val.length] = myInputElem.val().replace(",", "\\,");
				}
			}
			// deciding what to send back depending on how many values we found
			if(val.length > 0) {
				return val.join(",");
			} else {
				if (this.getConfig("falseValue")) {
					return this.getConfig("falseValue");
				} else {
					return null;					
				}
			}
		},
		
		
		/***
		 * override - sets the value of the element,
		 * expects multiple values in an array
		 */
		_setValue : function(val) {
			if(_.isUndefined(val)){
				val = '';
			}
			val = val.replace("\\,", "MYQUOTE");
			var myArray = val.split(",");
			var myInput = this._getInputElementsArray();
			for (var i=0;i<myInput.length;i++) {
				// getting the values of the checkbox and comparing if it is in the value on the model
				var myInputElem = $(myInput[i]);
				var inputVal = myInputElem.val();
				if (_.indexOf(myArray, inputVal.replace(",", "MYQUOTE")) > -1) {
					myInputElem.prop("checked", true);
				} else {
					myInputElem.prop("checked", false);
				}
			}
		},
		
		/***
		 * override. in case the multiple elements are not the same one duplicated
		 */
		createElement : function(placeholder,elementTemplate, inputAttr, viewData) {
			if ( !viewData.optionsData ) {
				FormElementTouchpointBaseView.prototype.createElement.apply( this, arguments);
				return;
			}
			var options = viewData.optionsData.items;
			// keeping some elements that are not for all fields
			var fieldId = inputAttr["id"];
			var fieldValue = inputAttr["value"];
			delete inputAttr["value"];
			for (var i=0;i<options.length;i++) {
				inputAttr["id"] = fieldId + "-" + i;
				var inp = {
						type : "checkbox",
						id : inputAttr["id"],
						name : inputAttr["name"],
						value : options[i][viewData.optionsData.valueField],
						display : options[i][viewData.optionsData.nameField]
					};
				var htmlElem = this.getPopulatedTemplate(elementTemplate, inp);
				placeholder.append(htmlElem);
				this.$root.find("#"+inputAttr["id"]).attr(inputAttr);				
			}
			inputAttr["id"] = fieldId;
			inputAttr["value"] = fieldValue;
			// setting the "checked" attribute according to the input value
			this._setValue(inputAttr["value"]);
			this.$root.find("fieldset").attr("data-role", "controlgroup");
		},
		/***
		 * override, sets the checked attribute for a single element
		 */
		_handleElementSpecificInputAttributes : function(inputAttributes, viewData) {
			if (!viewData.optionsData) {
				if (viewData.fieldValue!= null && inputAttributes["value"] == viewData.fieldValue) {
					// in the case of the checkbox, the value does not matter. what matters
					// is the value that will be sent by the checkbox
					inputAttributes["value"] = viewData.defaultValue;
					if (viewData.defaultValue == viewData.fieldValue) {
						inputAttributes["checked"] = "checked";										
					}
				}				
			}
		},
		/***
		 * sets the default label for single element and the legend for multiple checkboxes
		 */
		_updateDataForElement : function(inputAttributes, viewData) {
			var optionsData = viewData.optionsData;
			if (optionsData && viewData.legend == null) {
				viewData.legend = viewData.label;
			} else {
				if (viewData.label == null) {
					viewData.label = "Available"
				}
				if (viewData.defaultValue == null) {
					viewData.defaultValue = "true"
				}
				
			}
			var populatedTemplate = this.getPopulatedTemplate(this.template, viewData);
			this.placeRoot(populatedTemplate, true);
			if (viewData.refresh && optionsData && optionsData.items && optionsData.items.length > 0) {
				var options = optionsData.items;
				var elementTemplate = this.getConfig("elementTemplate") || this._getElementTemplate();
				var placeholder = this.$root.find('[data-uxf-point="myInput"]');
				elementTemplate = _.template(elementTemplate);
				// keeping some elements that are not for all fields
				var fieldId = inputAttributes["id"];
				var fieldValue = inputAttributes["value"];
				delete inputAttributes["value"];
				for (var i=0;i<options.length;i++) {
					inputAttributes["id"] = fieldId + "-" + i;
					var inp = {
							type : "checkbox",
							id : inputAttributes["id"],
							name : inputAttributes["name"],
							value : options[i][viewData.optionsData.valueField],
							display : options[i][viewData.optionsData.nameField]
						};
					var htmlElem = this.getPopulatedTemplate(elementTemplate, inp);
					placeholder.append(htmlElem);
					this.$root.find("#"+inputAttributes["id"]).attr(inputAttributes);				
				}
				inputAttributes["id"] = fieldId;
				inputAttributes["value"] = fieldValue;
				// setting the "checked" attribute according to the input value
				this._setValue(inputAttributes["value"]);
				this.$root.find("fieldset").attr("data-role", "controlgroup");
				}
				// this.createElement();
		},
		
		/***
		 * private. returns the input elements as an array, whether single
		 * or multiple checkboxes
		 */
		_getInputElementsArray : function() {
			var myInput = this.$root.find("input");
			// if (!myInput.length) {
			// 	myInput = new Array();
			// 	myInput[0] = myInput;
			// } 
			return myInput;
		}

	});
	return CheckboxView;

});

/**
<em>Radio Form Element</em> component.

## Template (`type` is `radio`)

```html
<span class="uxf-clickinput">
	<input data-uxf-point="myElement" 
		type="<%=type%>" value="<%=value%>" name="<%=name%>" id="<%=id%>"></input>
	<label for="<%=id%>"><%=display%></label>
</span>
```

@class Lightsaber.Mobile.RadioView
@namespace Lightsaber.Mobile
@module Lightsaber.Mobile
@extends Lightsaber.Mobile.FormElementTouchpointBaseView

@since 9.0.0

@requires jquery
@requires underscore
@requires backbone
@requires Lightsaber.Core

@constructor
@param {Object} options constructor's only parameter
@param {String|HTML Element|jQuery Object} [options.el] the element to attach to
@param {Lightsaber.Core.ViewModel} options.viewModel <em>ViewModel</em> that the <em>View</em> is going to use
@param {Object} options.vmKeys mapping of expected name of *ViewModel* 
property to its actual name in the specific *ViewModel* that this *View* 
receives at runtime, with default value of:  
___
```javascript
{
	'data.label': 'label',
	'data.legend': 'legend',
	'data.fieldValue': 'fieldValue',
	'data.defaultValue': 'defaultValue'
}
```
@param {Object} options.vmKeysChangeEvents mapping of expected name of *ViewModel* 
event to its actual name in the specific *ViewModel* that this *View* 
receives at runtime, with default value of:  
___
```javascript
{
	'data.label': '_valueChanged',
	'data.legend': '_valueChanged',
	'data.fieldValue: '_valueChanged',
	'data.defaultValue: '_valueChanged'
}
```
@param {Object} [options.config={}] main configuration parameter
@param {Object} [options.config.template] element's template
@param {Object} [options.config.inputAttributes={}] attributes that will be set on the input elements (maxLength, type, size, etc.) 
for now, attributes can be updated by the setConfig but cannot be deleted
@param {String} [options.config.template=""] template for the element; should have the "myInput" in case the input should be set from 
inner template
@param {String} [options.config.elementTemplate=""] template for the input element; this will override the default template for the element
@param {String} [options.config.legend=""] value for the legend                                                
@param {ViewModel} [options.config.collectionViewModel=null]  *CollectionViewmodel* to be used for the multiple values
@param {String} [options.config.optionsModelName='']  name of the model to be used for the multiple values
@param {String} [options.config.optionsValueFieldName='value'] name of the field in the collection that will have the value for multiple options
@param {String} [options.config.optionsDisplayFieldName='value'] name of the field in the collection that will have the display name for multiple options

**/
define('src/components/forminput/view/RadioView',[
    'jquery',
    'underscore',
    'backbone',
	'lightsaber.core',
	'src/components/forminput/view/FormElementTouchpointBaseView',
	'text!./template/clickInput_template.html'
], function($, _, Backbone, Lightsaber, FormElementTouchpointBaseView, ElementTemplate) {

	
	
    
	var inputFormelementView = FormElementTouchpointBaseView.extend({

	    
		_jqueryMobilePluginType: 'checkboxradio',

		/**
		@private
		**/
		_getType : function(inputAttr) {
			return "radio";
		},

		/**
		@private
		**/
		_getElementTemplate : function() {
			return ElementTemplate;
		},
		
		/**
		@private
		**/
		createElement : function(placeholder,elementTemplate, inputAttr, viewData) {
			placeholder.empty();
			var options = viewData.optionsData.items;
			var fieldID = inputAttr["id"];
			var fieldValue = inputAttr["value"];
			delete inputAttr["value"];
			delete inputAttr["checked"]; //making sure checked data is not passed within the inputAttr
			var radioValue = (viewData.fieldValue == null) ? viewData.defaultValue : viewData.fieldValue;
			for (var i=0;i<options.length;i++) {
				var hasChecked = false;
				inputAttr["id"] = fieldID + "-" + i
				var inp = {
						type : "radio",
						id : inputAttr["id"],
						name : inputAttr["name"],
						value : options[i][viewData.optionsData.valueField],
						display : options[i][viewData.optionsData.nameField]
					};
				var htmlElem = this.getPopulatedTemplate(elementTemplate, inp);
				placeholder.append(htmlElem);

				// checking whether we should check this element
				if (inp.value == fieldValue) {
					hasChecked = true;
				}
				var myelem = this.$root.find("#"+inputAttr["id"]);
				myelem.attr(inputAttr);
				myelem.prop("checked",hasChecked);
			}
			if (!hasChecked) {
				// in case we have a default value, we will set it to this if there nothing
				// has been checked yet
				var defaultOption = this.$root.find("[value='"+viewData.defaultValue+"']");
				if (defaultOption.length) {
					defaultOption.prop("checked",true)
				}
			}
			// resetting input attributes
			inputAttr["value"] = fieldValue;
			inputAttr["id"] = fieldID;

		},
		
		/**
		@private
		**/
		_getValue : function(evt) {
			if (evt != null) {
				return $(evt.currentTarget).val();				
			} else {
				// returning the checked value
				return this.$root.find("[type='radio']:checked").val();
			}
		},

		/**
		@private
		**/
		_setValue : function(val) {
			var inputToCheck = this.$root.find("[value='"+val+"']");
			if (inputToCheck.length) {
				this.$root.find("[type='radio']:checked").prop("checked", false);
				inputToCheck.prop("checked", true);
			}
		},
		
		/**
		@private
		**/
		_updateDataForElement : function(inputAttributes, viewData) {
			if (viewData.optionsData == null) {
				viewData.optionsData = {items: [
				     { name : "Yes", value : "true"},
				     { name : "No", value : "false"}				                        
						],
						nameField : "name",
						valueField : "value"};
			}
			if (viewData.label == null) viewData.label = "Choose";
			// setting legend to label if we do not have it
			if (viewData.legend == null) viewData.legend = viewData.label;	
			this.$root.find('[data-uxf-point="myLegend"]').text(viewData.legend);	
			
			var placeholder = this.$root.find('[data-uxf-point="myInput"]');
			var elementTemplate = this.getConfig("elementTemplate") || this._getElementTemplate();
			elementTemplate = _.template(elementTemplate);
			this.createElement( placeholder, elementTemplate, inputAttributes, viewData);
		}
	});

	return inputFormelementView;
});


define('text!src/components/forminput/view/template/selectInput_template.html',[],function () { return '<span class="uxf-input">\n\t<label for="<%=id%>"><%=display%></label><select id="<%=id%>"  name="<%=name%>" data-uxf-point="myElement"></select> \n</span>\n';});


define('text!src/components/forminput/view/template/selectOption_template.html',[],function () { return '<option value="<%=value%>"><%=display%></option>';});

/**
Base <em>Select Form Element</em> component. Extended by touch-point specific *Select* components.

## Template

```html
<span class="uxf-input">
	<label for="<%=id%>"><%=display%></label>
	<select id="<%=id%>" name="<%=name%>" data-uxf-point="myElement"></select> 
</span>
```

## Option template

```javascript
<option value="<%=value%>"><%=display%></option>
```

@class Lightsaber.Mobile.BaseSelectView
@namespace Lightsaber.Mobile
@module Lightsaber.Mobile
@extends Lightsaber.Mobile.FormElementTouchpointBaseView

@since 9.0.0
@private

@requires jquery
@requires underscore
@requires backbone
@requires Lightsaber.Core

@constructor
@param {Object} options constructor's only parameter
@param {String|HTML Element|jQuery Object} [options.el] the element to attach to
@param {Lightsaber.Core.ViewModel} options.viewModel <em>ViewModel</em> that the <em>View</em> is going to use
@param {Object} options.vmKeys mapping of expected name of *ViewModel* 
property to its actual name in the specific *ViewModel* that this *View* 
receives at runtime, with default value of:  
___
```javascript
{
	'data.label': 'label',
	'data.legend': 'legend',
	'data.fieldValue': 'fieldValue',
	'data.defaultValue': 'defaultValue'
}
```
@param {Object} options.vmKeysChangeEvents mapping of expected name of *ViewModel* 
event to its actual name in the specific *ViewModel* that this *View* 
receives at runtime, with default value of:  
___
```javascript
{
	'data.label': '_valueChanged',
	'data.legend': '_valueChanged',
	'data.fieldValue: '_valueChanged',
	'data.defaultValue: '_valueChanged'
}
```
@param {Object} [options.config={}] main configuration parameter
@param {Object} [options.config.template] element's template
@param {Object} [options.config.inputAttributes={}] attributes that will be set on the input elements (maxLength, type, size, etc.) 
for now, attributes can be updated by the setConfig but cannot be deleted
@param {String} [options.config.template=""] template for the element; should have the "myInput" in case the input should be set from 
inner template
@param {String} [options.config.elementTemplate=""] template for the input element; this will override the default template for the element
@param {String} [options.config.legend=""] value for the legend                                                
@param {ViewModel} [options.config.collectionViewModel=null]  *CollectionViewmodel* to be used for the multiple values
@param {String} [options.config.optionTemplate=''] 	template to be used for the option elements used in the select
@param {String} [options.config.optionsModelName='']  name of the model to be used for the multiple values
@param {String} [options.config.optionsValueFieldName='value'] name of the field in the collection that will have the value for multiple options
@param {String} [options.config.optionsDisplayFieldName='value'] name of the field in the collection that will have the display name for multiple options
**/
define('src/components/forminput/view/BaseSelectView',[
    'jquery',
    'underscore',
    'backbone',
	'lightsaber.core',
	'src/components/forminput/view/FormElementTouchpointBaseView',
	'text!./template/selectInput_template.html',
	'text!./template/selectOption_template.html'
], function($, _, Backbone, Lightsaber, FormElementTouchpointBaseView, ElementTemplate, OptionTemplate) {

	
	
    
	var baseSelectView = FormElementTouchpointBaseView.extend({

	    		
		/**
		Retrieves the type of the *Select Form Element*.

		@protected
		**/
		_getType : function(inputAttr) {
			return "select";
		},
		
		/**
		Retirieves element template - defined by `config.elementTemplate` configuration property.

		@protected
		@return {String} element template
		**/
		_getElementTemplate : function() {
			return ElementTemplate;
		},

		/**
		Creates the actual DOM element.

		@method createElement
		@protected
		@param {String} placeholder placeholder attribute string
		@param {String} elementTemplate DOM element template
		@param {Array} inputAttr input attributes to be applied to the DOM element
		@param {Objec} viewData view data to be used during templating
		@param {String} type HTML element type
		**/
		createElement : function(placeholder,elementTemplate, inputAttr, viewData) {
			var options = viewData.optionsData.items;
			var fieldID = inputAttr["id"];
			var selectValue = inputAttr["value"];
			delete inputAttr["value"];
			// adding the select
			var inp = this._getTemplateObject(inputAttr, viewData, this._getType());
			var htmlElem = elementTemplate(inp);
			placeholder.append(htmlElem);
			var selectElem = this.$root.find('[data-uxf-point="myElement"]');
			selectElem.attr(inputAttr);
			// adding the options
			var optionTemplate = this.getConfig("optionTemplate") || OptionTemplate;
			optionTemplate = _.template(optionTemplate);
			for (var i=0;i<options.length;i++) {
				inp = {
						value : options[i][viewData.optionsData.valueField],
						display : options[i][viewData.optionsData.nameField],
						disabled : options[i].disabled,
						placeholder : options[i].placeholder
					};
				htmlElem = this.getPopulatedTemplate(optionTemplate, inp);
				selectElem.append(htmlElem);
				// setting the selected option
			}
			if (selectValue != null) {	
				selectElem.val(selectValue + '');			
			}
			if (selectElem.children().length>0 && selectElem.find("option:selected").length == 0 
					&& options && options.length){
				// means we have a value that is not in the list anymore.
				// do not know how to properly handle, will set value to selected index	
				selectElem.val(options[0][viewData.optionsData.valueField] + '');
			}
			inputAttr["id"] = fieldID;
		},
		
		/**
		Updates the actual DOM element.

		@method createElement
		@protected
		@param {Array} inputAttr input attributes to be applied to the DOM element
		@param {Objec} viewData view data to be used during templating
		**/
		_updateDataForElement : function(inputAttributes, viewData) {			
			if (viewData.optionsData == null) {
				viewData.optionsData = {items: [
				     { name : "Yes", value : "true"},
				     { name : "No", value : "false"}				                        
				],
				nameField : "name",
				valueField : "value"};
			}
			if (viewData.label == null) viewData.label = "Choose";
			
			var selectValue = inputAttributes["value"];
			var $select = this.$el.find(this._getType());
			var selected = $select.val();
			$select.empty();
			var options = viewData.optionsData.items;

			var htmlElem, inp;
			var optionTemplate = this.getConfig("optionTemplate") || OptionTemplate;
			optionTemplate = _.template(optionTemplate);
			for ( var i=0; i<options.length; i++) {
				inp = {
						value : options[i][viewData.optionsData.valueField],
						display : options[i][viewData.optionsData.nameField],
						disabled : options[i].disabled,
						placeholder : options[i].placeholder
					};
				htmlElem = this.getPopulatedTemplate(optionTemplate, inp);
				$select.append(htmlElem);
			}
			$select.val(selected + '');	
			if(!this._getVMData("data.fieldValue") && options && options.length > 0) {	
				this.viewModel.set(this.vmKeys["data.fieldValue"], options[0]?options[0][this._getVMConfig('optionsValueFieldName')]:null, {silent: true});
			}
		}

		
	});
	return baseSelectView;

});


define('text!src_web/components/forminput/view/template/selectInput_template.html',[],function () { return '<span class="uxf-selectinput">\n\t<div class="mlabel"><label data-ls-bind="text:label" for="<%=id%>"><%=display%></label></div><select id="<%=id%>"  name="<%=name%>" data-uxf-point="myElement"></select> \n</span>\n';});

/**
<em>Select Form Element</em> component.

## Template

```html
<span class="uxf-selectinput">
	<div class="mlabel">
		<label for="<%=id%>"><%=display%></label>
	</div>
	<select id="<%=id%>"  name="<%=name%>" data-uxf-point="myElement"></select> 
</span>
```

## Option template

```javascript
<option value="<%=value%>"><%=display%></option>
```

@class Lightsaber.Web.SelectView
@namespace Lightsaber.Web
@module Lightsaber.Web
@extends Lightsaber.Mobile.BaseSelectView

@constructor
@param {Object} options constructor's only parameter
@param {String|HTML Element|jQuery Object} [options.el] the element to attach to
@param {Lightsaber.Core.ViewModel} options.viewModel <em>ViewModel</em> that the <em>View</em> is going to use
@param {Object} options.vmKeys mapping of expected name of *ViewModel* 
property to its actual name in the specific *ViewModel* that this *View* 
receives at runtime, with default value of:  
___
```javascript
{
	'data.label': 'label',
	'data.legend': 'legend',
	'data.fieldValue': 'fieldValue',
	'data.defaultValue': 'defaultValue'
}
```
@param {Object} options.vmKeysChangeEvents mapping of expected name of *ViewModel* 
event to its actual name in the specific *ViewModel* that this *View* 
receives at runtime, with default value of:  
___
```javascript
{
	'data.label': '_valueChanged',
	'data.legend': '_valueChanged',
	'data.fieldValue: '_valueChanged',
	'data.defaultValue: '_valueChanged'
}
```
@param {Object} [options.config={}] main configuration parameter
@param {Object} [options.config.template] element's template
@param {Object} [options.config.inputAttributes={}] attributes that will be set on the input elements (maxLength, type, size, etc.) 
for now, attributes can be updated by the setConfig but cannot be deleted
@param {String} [options.config.template=""] template for the element; should have the "myInput" in case the input should be set from 
inner template
@param {String} [options.config.elementTemplate=""] template for the input element; this will override the default template for the element
@param {String} [options.config.legend=""] value for the legend                                                
@param {ViewModel} [options.config.collectionViewModel=null]  *CollectionViewmodel* to be used for the multiple values
@param {String} [options.config.optionTemplate=''] 	template to be used for the option elements used in the select
@param {String} [options.config.optionsModelName='']  name of the model to be used for the multiple values
@param {String} [options.config.optionsValueFieldName='value'] name of the field in the collection that will have the value for multiple options
@param {String} [options.config.optionsDisplayFieldName='value'] name of the field in the collection that will have the display name for multiple options
**/
define('src_web/components/forminput/view/SelectView',[
	'src/components/forminput/view/BaseSelectView',
	'text!./template/selectInput_template.html'
], function(BaseSelectView, ElementTemplate) {

	
	
    
	var SelectView = BaseSelectView.extend({

	    
		/***
		 * override.
		 */
		_getElementTemplate : function() {
			return ElementTemplate;
		}
	});
	return SelectView;

});


define('text!src_web/components/forminput/view/template/slider_template.html',[],function () { return '<span class="uxf-slider">\n<table "width=100%">\n<tr>\n\t<td><div class="mlabel"></span><label for="<%=id%>"><%=display%></label></div></td>\n\t<td><input style="width:40px" class="amount" type="number" value="<%=value%>"/></td>\n\t<td><span class="minElement"></span></td>\n\t<td width="100%"><span class="amountText"></span><div data-uxf-point="myElement"></div></td>\n\t<td><span class="maxElement"></span></td>\n</tr>\n</table>\n</span>\n';});

/**
Base UXF <em>Slider Form Input</em> component.
 
## Main Template

```html
<span class="uxf-slider">
	<label for="<%=id%>"><%=display%></label>
	<input data-uxf-point="myElement" type="range" min="<%=min%>"  max="<%=max%>" id="<%=id%>" name="<%=name%>" value="<%=value%>"></input>
</span>
```

@class Lightsaber.Web.SliderView
@namespace Lightsaber.Web
@module Lightsaber.Web
@extends Lightsaber.Web.FormElementTouchpointBaseView

@since 9.0.0

@requires jquery
@requires underscore
@requires backbone
@requires Lightsaber.Core
@requires Lightsaber.Web.FormElementTouchpointBaseView

@constructor
@param {Object} options constructor's only parameter
@param {String|HTML Element|jQuery Object} [options.el] the element to attach to
@param {Lightsaber.Core.ViewModel} options.viewModel <em>ViewModel</em> that the <em>View</em> is going to use
@param {Object} options.vmKeys mapping of expected name of *ViewModel* 
property to its actual name in the specific *ViewModel* that this *View* 
receives at runtime, with default value of:  
___
```javascript
{
	'data.label': 'label',
	'data.legend': 'legend',
	'data.fieldValue': 'fieldValue',
	'data.defaultValue': 'defaultValue'
}
```
@param {Object} options.vmKeysChangeEvents mapping of expected name of *ViewModel* 
event to its actual name in the specific *ViewModel* that this *View* 
receives at runtime, with default value of:  
___
```javascript
{
	'data.label': '_valueChanged',
	'data.legend': '_valueChanged',
	'data.fieldValue: '_valueChanged',
	'data.defaultValue: '_valueChanged'
}
```
@param {Object} [options.config={}] main configuration parameter
@param {Object} [options.config.template] element's template
@param {Object} [options.config.inputAttributes={}] attributes that will be set on the input elements (maxLength, type, size, etc.) 
for now, attributes can be updated by the setConfig but cannot be deleted
@param {String} [options.config.template=""] template for the element; should have the "myInput" in case the input should be set from 
inner template
@param {String} [options.config.elementTemplate=""] template for the input element; this will override the default template for the element
@param {String} [options.config.legend=""] value for the legend                                                     
@param {Boolean} [options.config.showTextInput=""] whether to show the text field with the input next to the slider
@param {HTML} [options.config.minElement=""] HTML to be shown on the minimum side of the slider
@param {HTML} [options.config.maxElement=""] HTML to be shown on the maximum side of the slider
@param {Number} [options.config.minValue=""] minimum value for the slider
@param {Number} [options.config.maxValue=""] maximum value for the slider
@param {Number} [options.config.increment=""] increment between the values that the slider can give
@param {Boolean} [options.config.highlight=""] whether the slider will have a highlighted bar for the chosen range

**/
define('src_web/components/forminput/view/WebSliderView',[
	'jquery',
	'underscore',
	'backbone',
	'lightsaber.core',
	'src/components/forminput/view/FormElementTouchpointBaseView',
	'text!./template/slider_template.html'
], function($, _, Backbone, Lightsaber, FormElementTouchpointBaseView, ElementTemplate) {

	
	
    
	var sliderFormelementView = FormElementTouchpointBaseView.extend({

	    
		/*** override **/
		_getType : function(inputAttr) {
			return "range";
		},
		/*** override **/
		_getElementTemplate : function() {
			return ElementTemplate;
		},
		
		/***
		 * sets the value of the amount from the slider
		 * on the text input and the other placeholders
		 */
		_setAmountValue: function(value) {
			var amount = this.$root.find( ".amount" );
			for (var i=0; i <amount.length; i++) {
				var elem = $(amount[i]);
				if (!elem.is("input")) {
					elem.text(value);					
				} else {
					elem.attr("value",  value);
				}
			}				
		},

		/***
		 * handles changes in the slider value. it will set the amounts
		 * if initialized by the slider, or updates the slider and fix the amounts
		 * when initialized from outside (fix is for steps or values that are of
		 * the slider)
		 */
		_handleChange : function(event, newVal, fromSlider) {
			if (fromSlider) {
				this._setAmountValue(newVal);				
			} else {
				this.inputElement.slider("value", newVal);
				// get the value as calculate by the slider
				newVal = this._getValue();
				if (this.inputElement.slider("step")) {
					// update the value with the value as calculated for the step
					this._setAmountValue(newVal);						
				}
			}
			this._changed(event, newVal);
		},
		
		/***
		 * wrapper for handling the changes to the input element
		 */
		_changeFromInput : function(evt) {
			this._handleChange(evt, evt.currentTarget.value, false);
		},
		
		/***
		 * override
		 */
		_postRenderFormElement : function (inputElement) {
			var that = this;
			var sliderInputs = {
					range : "min",	// use to start sliding from left
					slide : function( event, ui ) {
							var myEvent = {currentTarget : that.inputElement};
							that._handleChange(myEvent, ui.value, true);
						}
			}
			sliderInputs.value = this.$root.find(".amount").attr("value");
			sliderInputs.max =  this.getConfig("maxValue") ? this.getConfig("maxValue") : 100;
			sliderInputs.min =  this.getConfig("minValue") ? this.getConfig("minValue") : 0;
			if (this.getConfig("increment")) {
				sliderInputs.step = this.getConfig("increment");				
			}
			
			this.inputElement.slider(sliderInputs);
			this.amountInput = this.$root.find("input.amount");
			this.amountInput.on("change", this._changeFromInput);
			// additional items in the left and right template that have a placeholder for the value
			// hasAmountPlaceHolder = false;
			
			if (this.getConfig("highlight")) {
				$( ".ui-slider-range" ).css( "background", this.getConfig("highlight") );
				$( ".ui-slider-handle" ).css( "background", this.getConfig("highlight") );
			}
			if (this.getConfig("showTextInput") === false) {
				this.amountInput.addClass("ui-helper-hidden");
			}
			var addValue = (this.getConfig("maxValue")  && this.getConfig("minValue") );
			if (addValue|| this.getConfig("minElement")) {
				this.$root.find(".minElement").append(this.getConfig("minElement"));		
			}

			if (addValue || this.getConfig("maxElement")) {
				this.$root.find(".maxElement").append(this.getConfig("maxElement"));		
			}
			
			if (this.getConfig("amountElement")) {
				this.amountElementText = this.$root.find(".amountText");
				this.amountElementText.append(this.getConfig("amountElement"));	
				this._setAmountValue(this.amountInput.attr("value"));

			}
		},

		/***
		 * override
		 */
		_setValue : function(val) {
			this.inputElement.slider("value", val);
			this._setAmountValue(val);
		},
		/***
		 * override
		 */
		_getValue : function(val) {
			return this.inputElement.slider("value");				
		}
	});
	return sliderFormelementView;

});

/**
<em>FlipSwitch Form Element</em> component.

## Template

```html
<span class="uxf-input">
	<label for="<%=id%>"><%=display%></label>
	<select id="<%=id%>" name="<%=name%>" data-uxf-point="myElement"></select> 
</span>
```

## Option template

```javascript
<option value="<%=value%>"><%=display%></option>
```

@class Lightsaber.Mobile.FlipSwitchView
@namespace Lightsaber.Mobile
@module Lightsaber.Mobile
@extends Lightsaber.Mobile.BaseSelectView

@since 9.0.0

@requires jquery
@requires underscore
@requires backbone
@requires Lightsaber.Core

@constructor
@param {Object} options constructor's only parameter
@param {String|HTML Element|jQuery Object} [options.el] the element to attach to
@param {Lightsaber.Core.ViewModel} options.viewModel <em>ViewModel</em> that the <em>View</em> is going to use
@param {Object} options.vmKeys mapping of expected name of *ViewModel* 
property to its actual name in the specific *ViewModel* that this *View* 
receives at runtime, with default value of:  
___
```javascript
{
	'data.label': 'label',
	'data.legend': 'legend',
	'data.fieldValue': 'fieldValue',
	'data.defaultValue': 'defaultValue'
}
```
@param {Object} options.vmKeysChangeEvents mapping of expected name of *ViewModel* 
event to its actual name in the specific *ViewModel* that this *View* 
receives at runtime, with default value of:  
___
```javascript
{
	'data.label': '_valueChanged',
	'data.legend': '_valueChanged',
	'data.fieldValue: '_valueChanged',
	'data.defaultValue: '_valueChanged'
}
```
@param {Object} [options.config={}] main configuration parameter
@param {Object} [options.config.template] element's template
@param {Object} [options.config.inputAttributes={}] attributes that will be set on the input elements (maxLength, type, size, etc.) 
for now, attributes can be updated by the setConfig but cannot be deleted
@param {String} [options.config.template=""] template for the element; should have the "myInput" in case the input should be set from 
inner template
@param {String} [options.config.elementTemplate=""] template for the input element; this will override the default template for the element
@param {String} [options.config.legend=""] value for the legend                                                
@param {ViewModel} [options.config.collectionViewModel=null]  *CollectionViewmodel* to be used for the multiple values
@param {String} [options.config.optionTemplate=''] 	template to be used for the option elements used in the select
@param {String} [options.config.optionsModelName='']  name of the model to be used for the multiple values
@param {String} [options.config.optionsValueFieldName='value'] name of the field in the collection that will have the value for multiple options
@param {String} [options.config.optionsDisplayFieldName='value'] name of the field in the collection that will have the display name for multiple options
**/
define('src/components/forminput/view/FlipSwitchView',[
    'jquery',
    'underscore',
    'backbone',
    'lightsaber.core',
    'src/components/forminput/view/BaseSelectView'], 
function($, _, Backbone, Lightsaber, BaseSelectView) {

	
	
    
	var FlipSwitch = BaseSelectView.extend({

	    
		_jqueryMobilePluginType: 'slider',

		/**
		Sets `data-role` attribute to be `none`.

		@method _handleElementSpecificInputAttributes
		@protected
		@param {Array} inputAttr input attributes to be applied to the DOM element
		@param {Objec} viewData view data to be used during templating
		**/
		_handleElementSpecificInputAttributes : function(inputAttributes, viewdata) {
			inputAttributes["data-role"] = "none";
		},

		/**
		Enhances created DOM element using `slider` API.

        @method _postRenderFormElement
        @protected
        @param {HTML Element} inputElement DOM element
        **/
		_postRenderFormElement : function (inputElement) {
			inputElement.slider( this.viewModel.getConfig("enabled")? undefined: {disabled:"true"});
		},

		_updateDataForElement : function(inputAttributes, viewData) {
			if (viewData.optionsData == null) {
				viewData.optionsData = {
						items: [	{ name : "I", value : "true"},				                        
						        	{ name : "O", value : "false"}	],
						nameField : "name",
						valueField : "value"
				};
			} else
				if (viewData.optionsData.items.length != 2)
					throw "We can only display 2 values";

		},

		/**        
        Handles the change of the `enable` property of the *ViewModel*.

        @method onEnableChange
        @protected
        @param {ViewModel Event} event the `change`/`enable` event
        **/
		onEnableChange : function(event) {
			if (this.inputElement && event)
					this.inputElement.slider( this.viewModel.getConfig("enabled")?'enable':'disable' );
		},
		
		/**
		Handler for *ViewModel's* `change` event.

        @method _valueChanged
        @protected
        @param {ViewModel Event} event the original *ViewModel* event
        **/
		_valueChanged: function(evt, text) {
			// we will only allow an update of the text in case it has changed, label and default value cannot be changed
			var text = this._getVMData("data.fieldValue");
			if (text != this._getValue()) {
				this._removeError();
				this._setValue(text);				
			}
		}
	});

	return FlipSwitch;
});

/**
<em>Select Form Element</em> component.

## Template

```html
<span class="uxf-input">
	<label for="<%=id%>"><%=display%></label>
	<select id="<%=id%>" name="<%=name%>" data-uxf-point="myElement"></select> 
</span>
```

## Option template

```javascript
<option value="<%=value%>"><%=display%></option>
```

@class Lightsaber.Mobile.SelectView
@namespace Lightsaber.Mobile
@module Lightsaber.Mobile
@extends Lightsaber.Mobile.BaseSelectView

@since 9.0.0

@requires jquery
@requires Lightsaber.Mobile.BaseSelectView

@constructor
@param {Object} options constructor's only parameter
@param {String|HTML Element|jQuery Object} [options.el] the element to attach to
@param {Lightsaber.Core.ViewModel} options.viewModel <em>ViewModel</em> that the <em>View</em> is going to use
@param {Object} options.vmKeys mapping of expected name of *ViewModel* 
property to its actual name in the specific *ViewModel* that this *View* 
receives at runtime, with default value of:  
___
```javascript
{
	'data.label': 'label',
	'data.legend': 'legend',
	'data.fieldValue': 'fieldValue',
	'data.defaultValue': 'defaultValue'
}
```
@param {Object} options.vmKeysChangeEvents mapping of expected name of *ViewModel* 
event to its actual name in the specific *ViewModel* that this *View* 
receives at runtime, with default value of:  
___
```javascript
{
	'data.label': '_valueChanged',
	'data.legend': '_valueChanged',
	'data.fieldValue: '_valueChanged',
	'data.defaultValue: '_valueChanged'
}
```
@param {Object} [options.config={}] main configuration parameter
@param {Object} [options.config.template] element's template
@param {Object} [options.config.inputAttributes={}] attributes that will be set on the input elements (maxLength, type, size, etc.) 
for now, attributes can be updated by the setConfig but cannot be deleted
@param {String} [options.config.template=""] template for the element; should have the "myInput" in case the input should be set from 
inner template
@param {String} [options.config.elementTemplate=""] template for the input element; this will override the default template for the element
@param {String} [options.config.legend=""] value for the legend                                                
@param {ViewModel} [options.config.collectionViewModel=null]  *CollectionViewmodel* to be used for the multiple values
@param {String} [options.config.optionTemplate=''] 	template to be used for the option elements used in the select
@param {String} [options.config.optionsModelName='']  name of the model to be used for the multiple values
@param {String} [options.config.optionsValueFieldName='value'] name of the field in the collection that will have the value for multiple options
@param {String} [options.config.optionsDisplayFieldName='value'] name of the field in the collection that will have the display name for multiple options
**/
define('src/components/forminput/view/SelectView',[
    'jquery',
    'src/components/forminput/view/BaseSelectView'
], function($, BaseSelectView) {

    
    
    
	var inputFormelementView = BaseSelectView.extend({

	    		
		_jqueryMobilePluginType: 'selectmenu',

		/**        
        Handles the change of the `enable` property of the *ViewModel*.

        @method onEnableChange
        @protected
        @param {ViewModel Event} event the `change`/`enable` event
        **/
		onEnableChange : function() {
			if(this.viewModel.getConfig("enabled")) {
				this.$root.find('select').selectmenu();
				this.$root.find('select').selectmenu('enable');	
			}
			else {
				this.$root.find('select').selectmenu();
				this.$root.find('select').selectmenu('disable');	
			}	
		},

		/**
		Handler for *ViewModel's* `change` event.

        @method _valueChanged
        @protected
        @param {ViewModel Event} event the original *ViewModel* event
        **/
		_valueChanged: function(evt, text) {
			// we will only allow an update of the text in case it has changed, 
			// label and default value cannot be changed
			var text = this._getVMData("data.fieldValue");
			if (text != this._getValue()) {
				this._removeError();
				this._setValue(text);	
				this.$root.find('select').selectmenu();		
				this.$root.find('select').selectmenu('refresh');				
			}
		}

	});
	return inputFormelementView;

});

/**
<em>Boolean Form Element</em> component.

@class Lightsaber.Mobile.BooleanView
@namespace Lightsaber.Mobile
@module Lightsaber.Mobile
@extends Lightsaber.Core.View

@since 9.0.0
@deprecated 9.0.1

@requires jquery
@requires underscore
@requires backbone
@requires Lightsaber.Core

@constructor
@param {Object} options constructor's only parameter
@param {String|HTML Element|jQuery Object} [options.el] the element to attach to
@param {Lightsaber.Core.ViewModel} options.viewModel <em>ViewModel</em> that the <em>View</em> is going to use
@param {Object} options.vmKeys mapping of expected name of *ViewModel* 
property to its actual name in the specific *ViewModel* that this *View* 
receives at runtime, with default value of:  
___
```javascript
{
	'data.label': 'label',
	'data.legend': 'legend',
	'data.fieldValue': 'fieldValue',
	'data.defaultValue': 'defaultValue'
}
```
@param {Object} options.vmKeysChangeEvents mapping of expected name of *ViewModel* 
event to its actual name in the specific *ViewModel* that this *View* 
receives at runtime, with default value of:  
___
```javascript
{
	'data.label': '_valueChanged',
	'data.legend': '_valueChanged',
	'data.fieldValue: '_valueChanged',
	'data.defaultValue: '_valueChanged'
}
```
@param {Object} [options.config={}] main configuration parameter
@param {Object} [options.config.template] element's template
@param {Object} [options.config.inputAttributes={}] attributes that will be set on the input elements (maxLength, type, size, etc.) 
for now, attributes can be updated by the setConfig but cannot be deleted
@param {String} [options.config.template=""] template for the element; should have the "myInput" in case the input should be set from 
inner template
@param {String} [options.config.elementTemplate=""] template for the input element; this will override the default template for the element
@param {String} [options.config.legend=""] value for the legend                                                
@param {ViewModel} [options.config.collectionViewModel=null]  *CollectionViewmodel* to be used for the multiple values
@param {String} [options.config.optionsModelName='']  name of the model to be used for the multiple values
@param {String} [options.config.optionsValueFieldName='value'] name of the field in the collection that will have the value for multiple options
@param {String} [options.config.optionsDisplayFieldName='value'] name of the field in the collection that will have the display name for multiple options

@examples none
**/
define('src/components/forminput/view/BooleanView',[
    'jquery',
    'underscore',
    'backbone',
	'lightsaber.core',
	'src/components/forminput/view/RadioView',
	'src/components/forminput/view/FlipSwitchView',
	'src/components/forminput/view/CheckboxView',
	'src/components/forminput/view/SelectView'], 
function($, _, Backbone, LightsaberCore, RadioView, FlipSwitchView, CheckboxView, SelectView) {

    
	var BooleanView = LightsaberCore.View.extend({

	    
		publicMethods : ['toggle'],
		_jqueryMobilePluginType: undefined,
		
		vmKeys: {
			"data.label"					: "label",
			"data.legend"					: "legend",
			"data.fieldValue" 				: "fieldValue",
			"data.defaultValue" 			: "defaultValue",
			// below is for backwards compatability, should be configuration of the view instead
			"config.collectionViewModel" 	: "collectionViewModel",
			"config.optionsModelName" 		: "optionsModelName",
			"config.optionsValueFieldName"	: "optionsValueFieldName",
			"config.optionsDisplayFieldName": "optionsDisplayFieldName"
		},
		
		initialize : function() {
			this._testModelItemsLength();
			
			this.myControl= null;

		},
		
		/***
		 * Checks that we either do not have an input model with values and will use the default values, 
		 * or that the input model only has 2 values
		 */
		_testModelItemsLength : function() {
			// getting the model to see we have only 2 options or a null model.
		    var modelName = this.getConfig("optionsModelName") || this._getVMConfig("config.optionsModelName");
			var booleanOptionsModel = null;
			var collectionView = this.getConfig("CollectionViewModel");
			if (collectionView != null) {
				booleanOptionsModel = collectionView._getModel();				
			}
			else if (modelName != null) {
				booleanOptionsModel = this.viewModel.models[modelName];	
			}
			// else if(this.getConfig('viewType') !== 'Checkbox'){
			// 	booleanOptionsModel = new LightsaberCore.Collection(
			// 		[{
			// 			name: this.getConfig('positiveLabel') || 'Yes',
			// 			value: this.getConfig('positiveValue') || true
			// 		},
			// 		{
			// 			name: this.getConfig('negativeLabel') || 'No',
			// 			value: this.getConfig('negativeValue') || false

			// 		}]
			// 	);
			// 	var booleanOptionsModelName = _.uniqueId('options');
			// 	this.viewModel.models[booleanOptionsModelName] = booleanOptionsModel;
			// 	this.setConfig('optionsModelName', booleanOptionsModelName);
			// 	this.setConfig('optionsDisplayFieldName', 'name');
			// 	this.setConfig('optionsValueFieldName', 'value');
			// }

			if (booleanOptionsModel && booleanOptionsModel.length != 2) {
				throw "boolean view can only get 2 values";
			}
		},

		/***
		 * wrappers for the input element
		 */
		_getType : function(inputAttr) {
			return this.myControl._getType();
		},
		_getValue : function(evt) {
			return this.myControl._getValue();
		},
		_setValue : function(val) {
			return this.myControl._setValue(val);
		},
		_changed: function(evt) {
			this.myControl._changed(evt);
		},	
		/**
		 * will toggle the value
		 */
		toggle : function() {
			var currentValue = this._getValue();
			var data = this.myControl.getData();
			if (data!= null && data.optionsData != null){
				// working with the view model
				var toggleVal = data.optionsData.items[0][data.optionsData.valueField];
				if (toggleVal == currentValue) {
					toggleVal = data.optionsData.items[1][data.optionsData.valueField];
				}
				
			} else {
				toggleVal =  ("false" == currentValue) + "";				
			}
			this._setValue(toggleVal);
		},
		
		_enhanceMarkup : function() {
			this.$root.attr("id", this.cid);
		},
		
		_postRender: function (){
	        var booleanControl = this.getConfig("viewType");
	        // creating a new EL for the new control since otherwise sometimes it gets confused

			// copying the configuration and setting the new el, creating input for the control	       			
	        var config = _.extend({}, this.getConfig(), {root:null, el:null});
		
			var inputObj = {
	        		el : this.$el,
        			viewModel: this.viewModel,
        			config : config,
        			attributes : this.attr(),
        			vmKeys : this.vmKeys
        	};


			// getting the correct control
	        switch (booleanControl) {
	        	case "FlipSwitch" :
	        		this.myControl = new FlipSwitchView(inputObj);
	        		break;
	        	case "Select" :
	        		this.myControl = new SelectView(inputObj);
	        		break;
	        	case "Checkbox" :
	        		if (!this.getConfig("falseValue")) {
	        			inputObj.config.falseValue = "false";
	        		}
	        		this.myControl = new CheckboxView(inputObj);
	        		break;
	        	default :
	        		if (this._getVMData("data.defaultValue") == null) {
	        			inputObj.config.defaultValue = "true";
	        		}
	        		this.myControl = new RadioView(inputObj);
	        		break;
	        }
	        this._jquery_mobile_plugin_type = this.myControl._jquery_mobile_plugin_type;
	       
	        // proxying the event calls from the control
	        var that = this;
	        this.myControl.bind("all", function(name,data) {
	        	that.trigger(name, data);
	        });

	        this.$root = this.myControl.$root;
		}

	});
	return BooleanView;

});



define('text!src/components/forminput/view/template/fileLoader_template.html',[],function () { return '<span class="uxf-fileloader">\n    <input data-uxf-point="fileLoader" type="<%=type%>" id="<%=id%>" name="<%=name%>" value="<%=value%>"/>\n</span>';});

/**
 <em>File Form Element</em> component.

 ## Template (`type` is `file`)

 ```html
 <span class="uxf-fileloader">
    <input data-uxf-point="fileLoader" type="<%=type%>" id="<%=id%>" name="<%=name%>" value="<%=value%>"/>
 </span>
 ```

 @class Lightsaber.Mobile.FileLoader
 @namespace Lightsaber.Mobile
 @module Lightsaber.Mobile
 @extends Lightsaber.Mobile.BaseFormElementView

 @since 9.0.0

 @requires jquery
 @requires underscore
 @requires backbone
 @requires Lightsaber.Core

 @constructor
 @param {Object} options constructor's only parameter
 @param {String|HTML Element|jQuery Object} [options.el] the element to attach to
 @param {Lightsaber.Core.ViewModel} options.viewModel <em>ViewModel</em> that the <em>View</em> is going to use
 @param {Object} options.vmKeys mapping of expected name of *ViewModel*
 property to its actual name in the specific *ViewModel* that this *View*
 receives at runtime, with default value of:
 ___
 ```javascript
 {
     'data.label': 'label'
 }
 ```
Also allow mapping of expected actions fired by the *View*,
 that can and should be captured by the  *ViewModel*
 receives at runtime, with default value of:
 ___
 ```javascript
 {
    'action.submitFile': 'submitFile',
    'action.response': 'response',
    'action.fileSelected': 'fileSelected'
 }
 ```
 @param {Object} options.vmKeysChangeEvents mapping of expected name of *ViewModel*
 event to its actual name in the specific *ViewModel* that this *View*
 receives at runtime, with default value of:
 ___
 ```javascript
 {
     'data.label': '_valueChanged'
 }
 ```
 @param {Object} [options.config={}] main configuration parameter
 @param {Object} [options.config.template] element's template
 @param {Object} [options.config.inputAttributes={}] attributes that will be set on the input elements (maxLength, type, size, etc.)
 for now, attributes can be updated by the setConfig but cannot be deleted
 @param {String} [options.config.template=""] template for the element; should have the "myInput" in case the input should be set from
 inner template
 @param {String} [options.config.elementTemplate=""] template for the input element; this will override the default template for the element
 @param {Function} [options.config.errorHandler=null] error handler that receives the error as input; if handl returns `true` -
 also populates error message
 @param {Function} [options.config.errorTextHandler=null] function that can be used in order to translate error text for the view
 @param {String} [options.config.errorTextKey=null] the *Resource Bundle's* key of the error text
 @param {Function} [options.config.errorRemoveHandler=null] error removal handler; if supplied it will be used instead of the default `_removeError`
 @param {Boolean} [options.config.useErrorClass=false] set to true if error message display/hide is done via associated CSS classes

 **/
define('src/components/forminput/view/FileLoaderView',[
    'jquery',
    'underscore',
    'backbone',
	'lightsaber.core',
    'src/core/util/Utils',
        'src/components/forminput/view/FormElementTouchpointBaseView',
    'text!./template/fileLoader_template.html'],
function($, _, Backbone, Lightsaber, Utils, FormElementTouchpointBaseView, ElementTemplate) {


    

    
    var FileLoaderView = FormElementTouchpointBaseView.extend({
    	
		_jqueryMobilePluginType: undefined,

        events: {
            'change input[type="file"]' : '_onFilesSelected'
        },

		/**
		@private
        Override the _getType function to inform the BaseFormElementView on the input type this view is implementing.
		**/
		_getType: function() {
			return "file";
		},

		/**
		@private
        Override the _getElementTemplate to return a new template.
		**/
		_getElementTemplate: function() {
			return ElementTemplate;
		},

        /**
         Handler for `change` event in file selection button.

         @method _onFilesSelected
         @protected
         @param {jQuery Event} event the original *jQuery* event
         **/
        _onFilesSelected: function(event) {
            var inputElm = event.target;
//            if (Utils.FileUpload.isFormDataSupported()){
//                this.formData = new FormData();
//                for (var i = 0; i < inputElm.files.length; i++) {
//                    var file = inputElm.files[i];
//                    this.formData.append(inputElm.name,file,file.name);
//                }
//            }
//            else{
                this.formData = inputElm;
                this._setVMData("data.file", "");
//            }
            this.formData.uniqueId = _.uniqueId('formData') ;//used so that the backbone/underscore compare will find the difference between 2 formData objects or prevent from deep compare in inputElm.
            this._setVMData("data.file", this.formData);
        }
    });

    FileLoaderView.widgetName = 'uxf.uxffileloader';

    return FileLoaderView;
});

define('text!src/components/searchinput/view/template/searchinput.html',[],function () { return '<div class="uxf-searchinput" data-role="<%=container%>" data-uxf-point="searchinput">\n\t<label data-uxf-point="label" for="<%=inputId%>" class="<% if(labelIsHidden) { %>ui-hidden-accessible <% } %>"><%=label%>:</label>\n\t<input type="search" data-uxf-point="input" name="<%=inputId%>" id="<%=inputId%>" <%=themeStr%> value="<%=value%>" data-inline="true" placeholder="<%=placeholder%>"/>\n</div>\n';});

/**
Base <em>Search</em> component that provides shared behaviour to both <em>Mobile</em> and <em>Web</em> <em>Search</em> components that extend it.

@class Lightsaber.Mobile.SearchInputViewBase
@namespace Lightsaber
@module Lightsaber.Mobile
@extends Lightsaber.Core.View

@private

@constructor
@param {Object} options constructor's only parameter
@param {Lightsaber.Core.ViewModel} options.viewModel <em>ViewModel</em> that the <em>View</em> is going to use
@param {Object} options.config main configuration parameter
@param {String} options.config.vmKeys mapping of expected name of <em>ViewModel</em> property to its 
actual name in the specific <em>ViewModel</em> that this <em>View</em> receives at runtime.
@param {String} [options.config.labelIsHidden=true] determines whether to hide the `input` HTML element `label`.
@param {String} [options.config.placeholder=""] placeholder for `<input type="search" placeholder="...">` HTML element
**/
define('src/components/searchinput/view/SearchInputViewBase',[
	'jquery', 
	'underscore', 
	'lightsaber.core', 
	'text!./template/searchinput.html'], 
function($, _, Lightsaber, templateText) {

	
	
			
	var SearchInputViewBase = Lightsaber.View.extend({

       	    		/**
		Configuration property that maps expected *ViewModel* properties to the actual ones.
		
		@property {Object} vmKeys
		@param {Object} [vmKeys.data.label='label'] default name of the `label` propery of the *ViewModel*
		@param {Object} [vmKeys.data.value='value'] default name of the `value` propery of the *ViewModel*
		@param {Object} [vmKeys.action.search='search'] default name of the `search` action of the *ViewModel*
		**/
		vmKeys: {
			"data.label"	: "label",
			"data.value"	: "value",
			"action.search"	: "search"
		},

		/**
		Configuration property that maps expected *ViewModel* `chnage` events (for example `change:label`) to its
		handler.
		
		@property {Object} vmKeysChangeEvents
		@param {Object} [vmKeysChangeEvents.data.label='refresh'] default handler of the `label` propery change of the *ViewModel*
		@param {Object} [vmKeysChangeEvents.data.value='refresh'] default handler name of the `value` propery change of the *ViewModel*
		**/
		vmKeysChangeEvents: {
			"data.label"	: "refresh",
			"data.value"	: "refresh"

		},
		
		/**
		`keyDown` event handler. It ivokes the corresponding (marked by `config.vmKeys.action.search` configuration property)
		*ViewModel* action.

		@method _onKeyDown
		@param {jQuery Event} event the  original *jQuery* event
		**/
		_onKeyDown: function(event) {
			if (event.keyCode !== 13) return;
			var searchValue = $(event.currentTarget).val();
			this.viewModel.handleAction(this.vmKeys['action.search'], searchValue);

		},
		
		/**
		`Esc`/clear event handler. Cleans *ViewModel* value that marked by `vmKeys.data.value` configuration property and
		triggers `search:input` event with `""` as value.

		@method _onClear
		@param {jQuery Event} event the  original *jQuery* event
		**/

		/**
		@event search:input
		@param {Object} value value that is passed with the event
		**/
		_onClear : function(event) {
			this._setVMData('data.value', null);
			this.trigger('search:input', "");
		},
		
		/**
		`input` event handler. Triggers `search:input` event with `event.target.value` as value.

		@method onInput
		@param {jQuery Event} event the  original *jQuery* event
		**/
		onInput : function(event) {
			this.trigger('search:input', event.target.value)
		},
		
		/**
		`blur` event handler. Triggers `search:input` event with `event` as value.

		@method onBlur
		@param {jQuery Event} event the  original *jQuery* event
		**/
		onBlur : function(event) {
			this.trigger('search:blur', event)
		},
		
		/**
		Main configuration property.

		@property {Object} config
		@param {Boolean} [autoRender=true] whether the *View* should be rendered immediately upon instantiation
		@param {String} [options.config.labelIsHidden=true] determines whether to hide the `input` HTML element `label`.
		@param {String} [options.config.placeholder=""] placeholder for `<input type="search" placeholder="...">` HTML element
		**/
		config: {
			autoRender: true,
			labelIsHidden: true,
			placeholder: 'Search',
			container : '',
			template: _.template(templateText),
			"data.label" : "Search",
			"data.value" : ""
		},
		
		/**
		Main-entry method. Resets action handler.

		@method initialize
		@protected
		**/
		initialize: function(options) {
			this.actionHandler = null;
		},
		
		/**
        Injects theme data into the context that is used to render the main *Search* template.

        @method _createTemplateData
        @protected
        @return {Object} object with `themeStr` property injected (along with `inputId` and other `config` properties)
        **/		
		_createTemplateData : function() {
			var data = _.extend({inputId : _.uniqueId('search_')}, this.getConfig()); 
			
			var theme = (this.attr('theme') != null) ? this.attr('theme') : this.getConfig('theme');
			if (theme != null) {
				data.themeStr = 'data-theme="' + theme + '"';
				} else {
				data.themeStr = '';
			}
			
			return data;
		},
		
		/**
        Binds events to the `input` HTML elements.

        @method _postRender
        @protected
        @return {Object} object with `themeStr` property injected (along with `inputId` and other `config` properties)
        **/
		_postRender : function() {
			var inputEventSupported = Lightsaber.Utils.isEventSupported('search:input'); //IE8
			if(inputEventSupported) {
				 this.$el.on('input', '[data-uxf-point="input"]', _.bind(this.onInput, this));
			}
			else {
					 this.$el.on('keyup', '[data-uxf-point="input"]', _.bind(this.onInput, this));
				}
				
				this.$el.on('keydown', '[data-uxf-point="input"]', _.bind(this._onKeyDown, this));
		    this.$el.on('input', '[data-uxf-point="input"]', _.bind(this.onInput, this));
		    this.$el.on('blur', '[data-uxf-point="input"]', _.bind(this.onBlur, this));
			this.$el.on('vclick', '.ui-input-clear', _.bind(this._onClear, this));			    
		},
		
		/**
		`change` event handler. Triggers `search:input` event with `event` as value.

		@method onChange
		@param {jQuery Event} event the original *jQuery* event
		**/
		onChange : function(event) {
			this.refresh(event);
		},
		
		
		/**
		Resets the *ViewModel* action handler (to allow further invokations) and calls {{#crossLink "Lightsaber.Core.View/_refresh"}}{{/crossLink}}.

		@method refresh
		**/
		refresh : function() {
			this.actionHandler = null;
			this._refresh();
		},

		/**
		 * @description
			 * Enables or disables search input field.
			 * It is called when {@link Lightsaber.SearchInputViewModel#change:config:enabled} event occurs.
			 * @memberOf Lightsaber.Mobile.SearchInputViewBase	
		 * @name onEnableChange
		 * @param {Object} event
		 * The event that should be handled 
		 * @param {Boolean} [event.value]
		 * true (for enable) or false (for disable)
		 */
		/**
        No-op.

        Handles the change of the `enable` property of the *ViewModel*, by removing or adding `ui-disabled` class and `disabled` attribute.

        Intended to be overridden by extending classes.

        @method onEnableChange
        @param {jQuery Event} event the original *jQuery* event
        **/
		onEnableChange: function(event) {
			//disable or enable root as well as input to fix issues in general
			this.inputElement = this.$root.find('[data-uxf-point="input"]');
			if(this.inputElement != null){
				if(event.value){
					this.$root.removeClass('ui-disabled');
						this.inputElement.removeAttr("disabled");
					}
					else{
						this.$root.addClass('ui-disabled');					
						this.inputElement.attr("disabled", !event.value);
					}
			}
							                
		}
	});
	
	return SearchInputViewBase;
});

/**
<em>Search</em> component.

@class Lightsaber.Web.SearchInputView
@namespace Lightsaber
@module Lightsaber.Web
@extends Lightsaber.Mobile.SearchInputViewBase

@constructor
@param {Object} options constructor's only parameter
@param {Lightsaber.Core.ViewModel} options.viewModel <em>ViewModel</em> that the <em>View</em> is going to use
@param {Object} options.config main configuration parameter
@param {String} options.config.vmKeys mapping of expected name of <em>ViewModel</em> property to its 
@param {String} [options.config.labelIsHidden=true] determines whether to hide the `input` HTML element `label`.
@param {String} [options.config.placeholder=""] placeholder for `<input type="search" placeholder="...">` HTML element
**/
define('src/components/searchinput/view/SearchInputView',[
	'jquery', 
	'underscore', 
	'jquery.ui',
	'src/components/searchinput/view/SearchInputViewBase',
	'lightsaber.core', 
	'text!./template/searchinput.html'], 
function($, _, jqui, SearchInputViewBase, Lightsaber, templateText) {

			

	var SearchInputView = SearchInputViewBase.extend({

					/**
		Enhances the created DOM using jQuery UI.
		
        @method enhanceMarkup
        @protected
        **/
		_enhanceMarkup: function(arg) {
			if(arg) {
				this.$root.autocomplete(arg);
			}
		}
	});
	
	return SearchInputView;
});


define('text!src/components/itemlist/view/template/ItemListTemplate.html',[],function () { return '<div>\n\t<ul data-uxf-point="uxf-itemlist"></ul>\n\t<div class="listview-pagination"></div>\n</div>';});


define('text!src/components/itemlist/view/template/ItemTemplate.html',[],function () { return '<li data-uxf-point="ui-listitem" id="<%=item[idAttribute]%>"><a>(<%=item[idAttribute]%>) <%=item.name%></a></li>';});


define('text!src/components/itemlist/view/template/PaginationTemplate.html',[],function () { return ' ';});


define('text!src/components/pagination/view/template/PaginationTemplate.html',[],function () { return '<div id=\'pc\' class="uxf-pagination">\n<a data-uxf-point="paginationPrev" class="uxf-pagination-prev"></a>\n<div  style="display: inline" data-uxf-point="paginationGoto" class="uxf-pagination-goto"></div>\n<a data-uxf-point="paginationNext" class="uxf-pagination-next"></a>\n</div>';});

/**
 * @class BasePaginationView
 * @type View
 * @memberOf Lightsaber.Mobile
 * @name BasePaginationView
 * @description This view is the base for the Pagination control widget. It is responsible to create pagination toolbar
 * according to configuration. User provided elements will be handled by this control as well to allow them pagination manipulations.
 * 
 * 
 * @param {Template} 	[options.config.toolbarTemplate=_template]	
 * 		 The provided template will override default toolbar.
 * @param {Array}   [options.config.controls]
 *      Array of configuration {control:'next',selector:'Selector',text:'NextButton',defaultRows:25, event:'click',disableCallBack:'function(){}',enableCallBack:'function(){}',successCallBack:function(){},errorCallBack:function(){}},{another control}]
 * @param {ViewModel}       [options.viewModel]
 *      ViewModel have to be the same as in the view that handles data 
 */

define('src/components/pagination/view/BasePaginationView',[
    'jquery',
    'underscore',
    'lightsaber.core'    
    ], function($, _, LightsaberCore) {

    
	var paginationView = LightsaberCore.View.extend({

				
		publicMethods : ['hasPreviousPageSupport','createControl','generateNextControl','generatePrevControl','updateToolbar','enableControls','disableControls'],

		_showSinglePageNumbering : false,
		/**
		 * initialize
		 */
		initialize: function() {
			_.bindAll(this,'disableControls','updateGotoInner');
			this.viewModel.on('items:loaded', this._updateControls, this);
			this.viewModel.on('items:paginated', this._updateControls, this);
			this.viewModel.on('items:refreshed', this._updateControls, this);
			var showSingle = this.getConfig("showSinglePageNumbering");
			if (typeof showSingle !== 'undefined') {
				this._showSinglePageNumbering = showSingle;
			}
		},

		/**
		 * @name _postRender
		 */
		_postRender: function() {
			this.viewModel.off( null, this._updateControls, this);
			this.viewModel.on('items:loaded', this._updateControls, this);
			this.viewModel.on('items:paginated', this._updateControls, this);
			this.viewModel.on('items:refreshed', this._updateControls, this);

			this.controls = [];
			this.placeRoot(this._prepareControls());
			var data = this.viewModel.getData();
			this._updateControls(data);				
		},
		
		/**
		 return boolean indication whether the pagination view supports previous pages.
		 can be used by views to decide whether to append or replace the data
		 @memberOf Lightsaber.Mobile.BasePaginationView
		 @name hasPreviousPageSupport
		 @function		 
		 */	
		hasPreviousPageSupport: function () {
			for (var i=0;i<this.controls.length;i++) {
				if(this.controls[i].attr('data-uxf-point')=='paginationPrev')
				{
					return true;
				}
			}
			return false;
		},
		

		/**
		 * Prepare the controls according to configuration and return toolbar jqueryObject
		 */
		_prepareControls:function()
		{
			var control = null;
			var tollbarTemplateControls = ['next','prev','goto'];
			var toolbar = $(this.getTemplate());
			var config = this.getConfig('controls');
			var tollbarExistingControls=[];
			
			for(var i =0;i<config.length;i++)
			{
				if(config[i].selector)
				{
					control = $(config[i].selector);
				}
				else
				{
					control = $(this._getControlClass(config[i].control),toolbar);
					/*control.hover(
						    function() {$(this).addClass('hover');},
						    function() {$(this).removeClass('hover');}
						    );*/
					tollbarExistingControls.push(config[i].control);
				}
				this.createControl(control,config[i]);
			}
			
			this._updateToolbarControls(toolbar,_.difference(tollbarTemplateControls,tollbarExistingControls));

			return toolbar;
		},
		
		/**
		 * Create control
		 */
		createControl:function(control,controlData)
		{
			switch(controlData.control)
			{
				case 'next':this.generateNextControl(control,controlData);break;
				case 'prev':this.generatePrevControl(control,controlData);break;
				case 'goto':this.generateGotoControl(control,controlData);break;
				default:if(console){console.log('invalid control',controlData);};
			}
			control.data('controlData',controlData);
			this.controls.push(control);
		},
		
		/**
		 * creates next control specific data
		 */
		generateNextControl:function(control,controlData)
		{
			var viewModel = this.viewModel;
			control.on(controlData.event||'click',this.disableControls);
			control.disableCallback = controlData.disableCallBack||this.defaultDisableCallback;
			control.enableCallback = controlData.enableCallBack||this.defaultEnableCallback;
			control.attr('data-uxf-point','paginationNext');
			control.html(controlData.text||'Next');
			
			var options = {};
			options.error = controlData.errorCallBack;
			options.success = controlData.successCallBack;
			
			control.on(controlData.event||'click',function(){
				viewModel.nextPage(1,options);
			});
		},
		
		/**
		 * creates prev control specific data
		 */
		generatePrevControl:function(control,controlData)
		{
			var viewModel = this.viewModel;
			control.on(controlData.event||'click',this.disableControls);
			control.disableCallback = controlData.disableCallBack||this.defaultDisableCallback;
			control.enableCallback = controlData.enableCallBack||this.defaultEnableCallback;
			control.attr('data-uxf-point','paginationPrev');
			control.html(controlData.text||'Prev');
			
			var options = {};
			options.error = controlData.errorCallBack;
			options.success = controlData.successCallBack;
			
			control.on(controlData.event||'click',function(){
				viewModel.previousPage(1,options);
			});
		},
		
		/**
		 * updates toolbar controls and lookup
		 */
		_updateToolbarControls:function(toolbar,controlsToRemove)
		{
			for(var i = 0; i<controlsToRemove.length; i++)
			{
				this._removeToolbarControl(controlsToRemove[i],toolbar);
			}
			this.updateToolbar(toolbar);
		},
		
		/**
		 * remove control from toolbar
		 */
		_removeToolbarControl:function(control,toolbar)
		{
			var selector = this._getControlContainerClass(control);
			toolbar.find(selector).remove();
		},
		
		/**
		 * Update controls each time ne page received
		 */
		_updateControls: function(page)
		{
			if(!page.paginationInfo){return};
			
			this.enableControls();
			this._updateNextControls(page.paginationInfo);
			this._updatePrevControls(page.paginationInfo);
			this.updateGotoControls(page.paginationInfo);
		},
		
		/**
		 * control next appereance 
		 */
		_updateNextControls: function(paginationInfo)
		{
			var that = this;
			$.each(this.controls,function(index,control){
				if(control.attr('data-uxf-point')=='paginationNext')
				{
					if( (paginationInfo.pageNum>=paginationInfo.totalPages-1)  && paginationInfo.totalPages)
					{
						control.disableCallback();						
						if(that.$root.attr('data-uxf-point') == 'paginationNextContainer'){
							that.$root.hide();
						}
					}
					else
					{
						control.enableCallback();						
						if(that.$root.attr('data-uxf-point') == 'paginationNextContainer'){
							that.$root.show();
						}
					}
					that._updateNextControlText(control,paginationInfo);
				}
			});
		},
		
		/**
		 * control prev appereance 
		 */
		_updatePrevControls: function(paginationInfo)
		{
			var that = this;
			$.each(this.controls,function(index,control){
				if(control.attr('data-uxf-point')=='paginationPrev')
				{
					if(paginationInfo.pageNum==0)
					{
						control.disableCallback();
						if(that.$root.attr('data-uxf-point') == 'paginationPrevContainer'){
							that.$root.hide();
						}
					}
					else
					{
						control.enableCallback();						
						if(that.$root.attr('data-uxf-point') == 'paginationPrevContainer'){
							that.$root.show();
						}
					}
				}
			});
		},
	
		/**
		 * accroding to control type returns control class  
		 */
		_getControlClass:function(controlType)
		{
			switch(controlType)
			{
				case 'next':return '[data-uxf-point="paginationNext"]';
				case 'prev':return '[data-uxf-point="paginationPrev"]';
				case 'goto':return '[data-uxf-point="paginationGoto"]';	
				default:
					return '';
			}
		},
		
		/**
		 * accroding to control type returns control container class in template 
		 */
		_getControlContainerClass:function(controlType)
		{
			switch(controlType)
			{
				case 'next':return '[data-uxf-point="paginationNextContainer"]';
				case 'prev':return '[data-uxf-point="paginationPrevContainer"]';
				case 'goto':return '[data-uxf-point="paginationGotoContainer"]';					
				default:
					return '';
			}
		},
		
		/**
		 * override me 
		 */
		getTemplate:function(){},
		
		/**
		 * Override me
		 */
		defaultDisableCallback:function(){
			this.hide();
		},
		
		/**
		 * Override me
		 */
		defaultEnableCallback:function(){	
			this.show();
		},
			
		/**
		 * Override me
		 */
		updateToolbar:function(toolbar){},
	
		/**
		 * override me
		 */
		disableControls:function(){},
	
		/**
		 * override me
		 */		
		enableControls:function(){},
		
		/**
		 * override me
		 */	
		updateGotoInner:function(control){},
		/**
		 * overide me
		 */
		generateGotoControl:function(control,controlData){},
		/**
		 * overide me
		 */
		updateGotoControls: function(paginationInfo){},
		/**
		 * override me
		 */
		_updateNextControlText:function(control,paginationInfo){}
		
		
	
	});

	return paginationView;
});
/**
 * @class PaginationView
 * @type View
 * @memberOf Lightsaber.Web
 * @name PaginationView
 * @description This view is a Pagination control widget. It is responsible to create pagination toolbar
 * according to configuration. User provided elements will be handled by this control as well to allow them pagination manipulations.
 * 
 * 
 * @param {Template} 	[options.config.toolbarTemplate=_template]	
 * 		 The provided template will override default toolbar.
 * @param {Array}   [options.config.controls]
 *      Array of configuration {control:'next',selector:'Selector',text:'NextButton',event:'click',disableCallBack:'function(){}',enableCallBack:'function(){}',successCallBack:function(){},errorCallBack:function(){}},{another control}]
 * @param {ViewModel}       [options.viewModel]
 *      ViewModel have to be the same as in the view that handles data 
 */
define('src/components/pagination/view/PaginationView',[
    'jquery',
    'underscore',
    'lightsaber.core',
    'text!./template/PaginationTemplate.html',
    'src/components/pagination/view/BasePaginationView'   
    ], function($, _, LightsaberCore,template,BasePaginationView) {

    	
	var paginationView = BasePaginationView.extend({
					
		/**
		 * create template for pagination control
		 */
		getTemplate:function()
		{
			var templ = this.getConfig("toolbarTemplate") || _.template(template,{});
			return templ;
		},
	
		/**
		 * method is invoked by default to disable control
		 */
		defaultDisableCallback :function()
		{
			this.hide();
		},
		
		/**
		 * method is invoked by default to enable control
		 */
		defaultEnableCallback:function()
		{
			this.show();
		},
		
		
		/**
		 * method to disable controls upon click
		 */
		disableControls:function()
		{
			$.each(this.controls,function(data,control){control.prop("disabled", true)});
		},
		
		/**
		 * method to enable controls once data retrieved
		 */
		enableControls:function()
		{
			$.each(this.controls,function(data,control){control.prop("disabled", false)});
		},
		
		/**
		 * remove control from toolbar
		 */
		_removeToolbarControl:function(control,toolbar)
		{
			var selector = this._getControlContainerClass(control);
			toolbar.find(selector).remove();
		},
		
		/**
		 * Generate goto controls
		 */
		generateGotoControl:function(control,controlData)
		{
			control.pagesNum = controlData.pagesNum||5;
			var viewModel = this.viewModel;
			control.attr('data-uxf-point','paginationGoto');
			for(var i = 0;i<control.pagesNum;i++)
			{
				this.createGotoInner(control,controlData);
			}
		},
		
		/**
		 * Create each element in goto Control
		 */
		createGotoInner:function(control,controlData)
		{
			var inner = $(controlData.template||'<a class="uxf-pagination-page"></a>');
			inner.attr('data-uxf-point','gotoInner');
			var viewModel = this.viewModel;
		
			/*inner.hover(
				    function() {$(this).addClass('hover');},
				    function() {$(this).removeClass('hover');}
				    );*/
			
			var options = {};
			options.success = controlData.successCallBack;
			options.error = controlData.errorCallBack;
				
			inner.on(controlData.event||'click',function(){
				viewModel.gotoPage($(this).attr('pageNum'),options);
			});
			
			this.updateGotoInner = controlData.updateGotoCallback||this.updateGotoInner;
			
			control.append(inner);
		},
		
		/**
		 * Calculate how the inner goto elements should look like and updates them
		 */
		updateGotoControls: function(page)
		{
			var that = this;
			$.each(this.controls,function(index,control){
				if(control.attr('data-uxf-point')=='paginationGoto')
				{
					
					var pages = page.totalPages < control.pagesNum ? page.totalPages : control.pagesNum;
					var firstPage = page.pageNum - Math.floor(pages/2);
					firstPage = firstPage < 0 ? 0 : firstPage;
					var lastPage = firstPage + pages-1;
					
					if(lastPage>page.totalPages-1)
					{
						var dif = lastPage - page.totalPages + 1;
						lastPage = page.totalPages-1;
						firstPage = firstPage - dif;
					};
					
					var currentP = firstPage;
					var inners = $('[data-uxf-point="gotoInner"]',control);
					inners.removeClass('uxf-pagination-page-active');
					if (page.totalPages === 1 && !that._showSinglePageNumbering) {
						inners.hide();
					} else {
						inners.each(function(){
							
							if(currentP>lastPage)
							{
								$(this).hide();
							}
							else
							{
								if(page.pageNum==currentP)
								{
									$(this).addClass('uxf-pagination-page-active');
								};
								$(this).attr('pageNum',currentP++);
								that.updateGotoInner(this);
								$(this).show();
							}
						});
					}
				}
			})
		},
		
		
		/**
		 * Update method for goto inner controls 
		 */
		updateGotoInner:function(control)
		{
			$(control).html(parseInt($(control).attr('pageNum'))+1);
		},
		
		/**
		 * accroding to control type returns control container class in template 
		 */
		_getControlContainerClass:function(controlType)
		{
			switch(controlType)
			{
				case 'next':return '[data-uxf-point="paginationNext"]';
				case 'prev':return '[data-uxf-point="paginationPrev"]';
				case 'goto':return '[data-uxf-point="paginationGoto"]';					
				default:
					return '';
			}
		},
		
		/**
		 * control next appereance 
		 */
		_updateNextControls: function(paginationInfo)
		{
			var that = this;
			$.each(this.controls,function(index,control){
				if(control.attr('data-uxf-point')=='paginationNext')
				{
					if(paginationInfo.pageNum>=paginationInfo.totalPages-1)
					{
						control.disableCallback();
					}
					else
					{
						control.enableCallback();
					}
					that._updateNextControlText(control,paginationInfo);
				}
			});
		},
		
		/**
		 * control prev appereance 
		 */
		_updatePrevControls: function(paginationInfo)
		{
			var that = this;
			$.each(this.controls,function(index,control){
				if(control.attr('data-uxf-point')=='paginationPrev')
				{
					if(paginationInfo.pageNum==0)
					{
						control.disableCallback();
					}
					else
					{
						control.enableCallback();
					}
				}
			});
		}
		
	});

	return paginationView;

});
/**
Default base View for the itemlist display. is extended per touchpoint.
The item template must contain either "id" per the list item, or "data-id".

@class BaseItemListView
@namespace Lightsaber
@module Lightsaber.Mobile
@extends Lightsaber.Core.View

@requires jQuery
@requires Underscore
@requires Lightsaber.Core
@requires Lightsaber.PaginationView

@since 9.0.0

@constructor
@param {Object} options the configuration object. Please find additional params at: 
	{{#crossLink "Lightsaber.Core.View"}}{{/crossLink}}
@param {CVM} options.viewModel the list's CollectionViewModel
@param {Template} [options.config.template=_template]
@param {Template} [options.config.itemTemplate=_itemTemplate]
@param {Template} [options.config.paginationTemplate=paginationTemplate] item to be used to show the 
				   next button in the list. it will be added on the ".listview-pagination" placeholder. 
				   see paginationview for specifications
@param {Function} [options.config.itemUpdateHTMLFunction] used for a callback on the html item in the list
					after it it is templated. can be used for example to highlight
					specific words, it gets the json data and the HTML element and an
					indication whether it is a group or an item. Default implementation is empty and has the signature: function(data, htmlElem, isGroup)
@param {PaginationView} [options.config.paginationView=_paginationView] used in case the
					basic pagination view
@param {String} [options.vmKeys.action.select='select'] The name of the action event that will be sent when 
					an item has been selected.
**/
define('src/components/itemlist/view/BaseItemListView',[ 'underscore', 'jquery', 'text!./template/ItemListTemplate.html', 'text!./template/ItemTemplate.html',
        'text!./template/PaginationTemplate.html', 'lightsaber.core', 'src/components/pagination/view/PaginationView' ], function(_, $, template,
        itemTemplate, paginationTemplate, LightsaberCore, PaginationView) {

    
    
    
	var view = LightsaberCore.View.extend({

		
		vmKeys: {
			"action.select"	: "select"
		},
	    initialize : function() {
		    this._initialize();
	    },

	    config : {
	    	/**
	    	Html update method that could be configured and used when an item in the list requires updating.  
	    	 
	    	@property config.itemUpdateHTMLFunction
	    	@public
	    	@type function
	    	@param {Object} data the data to update into the list item 
	    	@param {HTMLElement/jQueryObject} elem The html element that requires updating 
	    	@param {boolean} isGroup is a group or an item 
	    	@default empty implementation
	    	**/
		    itemUpdateHTMLFunction : function(elem, isGroup) {
		    }
	    },

	    /**
	    During postRender, it creates the root element, applies styling, sets the visibility of the list, handles pagination, and refreshes the view
	    
	    @method _postRender
	    @private
	    **/
	    _postRender : function() {
		    // will create the root element
		    this.itemListElement = this._getItemListElement();
		    // will save the root element for future reference
		    // will set the theme related stuff
		    this._applyStyling();
		    // will decide whether this is visible
		    this._setVisible();
		    // if we have autorender, we will add all the data as well
		    if (this.getConfig("autoRender")) {
			    // adding the data
			    var data = this._getViewData(null);
			    if (data != null) {
				    this._load(data);
				    this._handlePaginationControl(data.paginationInfo);
			    }
		    }
		    // this.$el = this.$root;
		    this._refreshListView();
	    },

		 /**
		 Find the DOM element that contains the list
		 Looks for :
		 1. data-uxf-point='uxf-itemlist'
		 2. BWC - datarole = listview
		 3. BWC - the 'ul'
		 
		 @method _getItemListElement
		 @private
		 @return {jQueryObject/[jQueryObject]} It returns the found element as jQueryObj. It returns the root if none is found. In case 
		 there is more than one element matching the condition - all of them will be returned (only for that condition)
		 **/
	    _getItemListElement : function() {
		    var listelem = this.$root.find('[data-uxf-point="uxf-itemlist"]');
		    if (listelem.length) {
			    return listelem;
		    }
		    // BWC from here on
		    listelem = this.$root.find('[data-role="listview"]');
		    if (listelem.length) {
			    return listelem;
		    } else {
		    	listelem = this.$root.find("ul");
		    	if (listelem.length) {
				    return listelem;
			    }
		    }
		    return this.$root;
	    },

		 /**
		 Internal initialize. can also be called by extending views. It grabs the templates from the config and binds the events.
		 
		 @method _initialize
		 @protected
		**/
	    _initialize : function() {
		    _.bindAll(this, 'render', '_add', '_remove', '_changed', '_refresh', '_load', '_setVisible', '_applyStyling', '_refreshListView',
		            '_handleItem', '_cleared', '_enhanceMarkup', '_select', '_handlePage', '_getItemListElement', '_handlePaginationControl');
		    this.template = this.getConfig("template") || _.template(template);
		    this.itemTemplate = this.getConfig("itemTemplate") || itemTemplate;
		    this.paginationTemplate = this.getConfig("paginationTemplate") || paginationTemplate;
		    this.itemListElement = null;
		    this.paginationView = null;

		    // binding to the viewmodel events
		    this.viewModel.on('items:loaded', this._refresh, this);
		    this.viewModel.on('items:emptied', this._cleared, this);
		    this.viewModel.on('items:refreshed', this._refresh, this);
		    this.viewModel.on('items:added', this._add, this);
		    this.viewModel.on('items:changed', this._changed, this);
		    this.viewModel.on('items:removed', this._remove, this);
		    this.viewModel.on('items:paginated', this._handlePage, this);
		    // this.viewModel.on('all', function(evt) { console.log(evt)})
	    },

		 /**
		 Template method used in order to create the element on the DOM. to be overriden per
		 touchpoint
		 
		 @method _enhanceMarkup
		 @protected
		 @param {HTMLElement} element the element to enhance
		 **/
	    _enhanceMarkup : function(element) {
		    // override me
	    },

		 /**
		 Hides or showed the element depending on the configuration of the
		 viewmodel. when either visible or enable is set to false, we will
		 hide the element
		 
		 @method _setVisible
		 @private
		 **/
	    _setVisible : function() {
		    var isVisible = this.viewModel.getConfig("visible");
		    var isEnabled = this.viewModel.getConfig("enabled");
		    if (isVisible == false || isEnabled == false) {
			    this.$root.hide();
		    } else {
			    this.$root.show();
		    }

	    },
	
		 /**
		 override - for different pagination behaviour Handles the adding of a
		 page to our view. list will always append the items and not paginate
		 them with pages
		 
		 @method _handlePage
		 @private
		 @param {Object} obj the data model object for which to load the page
		 **/
	    _handlePage : function(obj) {
	    	var data = this._getViewData(obj);
		    this._handlePreloadPage(data);
		    this._load(data);
		    this._handlePaginationControl(data.paginationInfo);
		    this._refreshListView();
	    },

		 /**
		Handles adding the pagination control on the DOM in case the input
		data is paginated
		 
		 @method _handlePaginationControl
		 @private
		 @param {Object} [paginationInfo] the pagination information model. 
		 @param {Object} [paginationInfo.pageSize] the page size - the max number of items per page. 
		 **/
	    _handlePaginationControl : function(paginationInfo) {
		    if (paginationInfo != null && paginationInfo.pageSize != null) {
			    if (this.paginationView == null) {
				    // getting the pagination view. if not sent as configuration
				    // we will create it the first time.
				    if (this.getConfig("paginationView") == null) {
					    var thatVM = this.viewModel;
					    var pagcontrols = this._getPaginationControlsConfiguration();
					    var config = {
						    controls : pagcontrols
					    };
					    var paginationTemplate = this.getPaginationTemplate();
					    if (paginationTemplate) {
						    config.toolbarTemplate = paginationTemplate;
					    }
					    ;
					    this.paginationView = new PaginationView({
					        viewModel : thatVM,
					        config : config
					    });
				    } else {
					    this.paginationView = this.getConfig("paginationView");
				    }
				    // rendering the HTML
				    this.paginationView.render();
			    }
			   
			    this._placePaginationControl();

		    }
	    },

		 /**
		 Updates the list view with the refreshed data items. Empty template method to be overriden.
		 
		 @method _refreshListView
		 @protected
		 **/
	    _refreshListView : function() {
	    	this._processTemplateViews();
		    // override me
	    },

		 /**
		 Actions to be done during pagination, in the preload of the page. Currently it clears the data from the list view if the previous button
		 is allowed in the pagination.
		 
		 @method _handlePreloadPage
		 @private
		**/
	    _handlePreloadPage : function(data) {
	    	if (this.paginationView) {
	    		if (this.paginationView.hasPreviousPageSupport()) {
	    			this._cleared(true);
	    		}
	    	}
	    },

		 /**
		 Template method to be overrriden. It returns the default configuration for the pagination
		 control. Currently always returns `[{control: 'next'}]`
		 
		 @method _getPaginationControlsConfiguration
		 @protected
		 @return {Array} the pagination control configuration array. Currently always returns `[{control: 'next'}]`
		**/
	    _getPaginationControlsConfiguration : function() {
		    var that = this;
		    return [{control : 'next'}]
	    },

		/**
		May be overriden. Called when the viewmodel configuration has changed
		
		@method onVisibleChange
		@public
		**/
	    onVisibleChange : function() {
		    this._setVisible();
	    },
	    
		/**
		May be overriden - Called when the viewmodel enable/disable state has changed
		 
		@method onEnabledChange
		@private
		**/
	    onEnableChange : function() {
		    this._setVisible();
	    },

		/**
		Called by view when the configuration for the view has changed
		
		@method configChanged
		@public
		@param {Object} changed what has changed
		**/
	    configChanged : function(changed) {
		    if (changed && changed.paginationView || this.itemListElement && this.itemListElement.find('[data-uxf-point="ui-listitem"]').length > 0) {
			    this._refresh();
		    }
	    },

		/**
		May be overriden - Called by View when something changed in the view
		
		@method onChange
		@public
		**/
	    onChange : function() {
		    this._refresh();
	    },

		/**
		Removes an item from the list. Called upon viewmodel items:removed event
		
		@method _remove
		@protected
		@param {Object} data the data object to be removed
		@param {boolean} noRefresh should the view refresh itself after the data is removed
		**/
	    _remove : function(data, noRefresh) {
	    	var data = this._getViewData(data);
		    var item = null;
		    if (data.sortedIndex) {
			    item = this.itemListElement.find('[data-uxf-point="ui-listitem"]').get(data.sortedIndex);
		    } else {
			    var id = data.item[data.idAttribute];
			    item = this.itemListElement.find("#" + id);
			    if (item.length == 0) {
			    	item = this.itemListElement.find('[data-id="' + id+'"]');
			    }
		    }
		    if (item == null)
			    return;
		    item = $(item);
		    var itemIndex = item.index();
		    item.remove();
		    if (noRefresh) {
			    this._refreshListView();
		    }
		    return itemIndex;
	    },
	    /***********************************************************************
		 * Updates in case of an item update. for one item, we will replace it.
		 * for multiple items we replace the elements in the list
		 */
		/**
		This method is executed when items:changed event is fired by the viewmodel. It updates the view. In case of a single item update, 
		it replaces the item. For multiple items, the elements in the list are replaced
		
		@method _changed
		@protected
		@param {Object} obj the data object
		**/
	    _changed : function(obj) {
	    	var data = this._getViewData(obj);
		    if (data.length) {
			    if (data.paginationInfo == null || data.paginationInfo.pageSize == null) {
				    this._load(data);
			    } else {
				    throw "Not supported";
			    }
		    } else {
			    // the index is the new index where to put the item, not where
				// to remove it from
			    var newIndex = data.sortedIndex;
			    data.sortedIndex = null;
			    var removedIndex = this._remove(obj, true);
			    if (removedIndex > -1) {
				    // only if we had the original item, resetting the index to
					// where we are supposed to put the new entry
				    if (newIndex == null) {
					    // if we do not know where the item is supposed to go
						// (not sorted),
					    // we will replace the item we just replaces
					    data.sortedIndex = removedIndex;
				    } else {
					    // where the item should be has already been calculated
						// for us
					    data.sortedIndex = newIndex;
				    }
				    this._add(obj, data.sortedIndex);
			    }
		    }
	    },
	    
		/**
		Adds an item to the list. either to the index given or to the end of
		the list
		
		@method _add
		@protected
		@param {Object} data the data to add to the list
		@param {number} objectIndex the index where to add it, if none is provided it will use the data.sortIndex
		**/
	    _add : function(data, objectIndex) {
	    	var data = this._getViewData(data);
	    	// if we got the index for the object through an internal call, we will use that one
	    	if (objectIndex != null) data.sortedIndex = objectIndex;
		    if (data.sortedIndex != null) {
			    var list = this.itemListElement.find('>[data-uxf-point="ui-listitem"]');
			    if (data.sortedIndex < list.length) {
				    // getting the element that we will use in order to prepend
					// the item before it.
				    data.beforeElement = $(list.get(data.sortedIndex));
			    }
		    }
		    this._handleItem(data);
		    // this._processTemplateViews();
		    // var elem = this._handleItem(data);
		    // elem.find('[data-uxf-view]').each(_.bind(this._processTemplateView, this, templateScope));
		    this._refreshListView();

	    },

		/**
		Clears the data from the list upon items:emptied event
		
		@method _cleared
		@private
		@param {boolean} keepPagination whether to keep pagination showing
		**/
	    _cleared : function(keepPagination) {
		    this.itemListElement.children().remove();
		    if (keepPagination == null || keepPagination == false) {
			    var pControl = this.$root.find(".listview-pagination");
			    if (pControl.length) {
				    pControl.hide();
			    }
		    }

	    },
	    /***********************************************************************
		 * loads the data to the view with sort if provided
		 */
		 /**
		 loads the data to the view with sort if provided
		 
		 @method _load
		 @protected
		 @param {Object} data the data to load to the list view
		 **/
	    _load : function(data) {
		    for ( var i = 0; i < data.items.length; i++) {
			    this._handleItem({
			        "item" : data.items[i],
			        "idAttribute" : data.idAttribute
			    });
		    }
	    },
	    
		/**
		Refreshes the view in case model has changed: destorys the pagination, clears the data and recreate them all
		
		@method _refresh
		@protected
		**/
	    _refresh : function() {
	    	this.paginationView && this.paginationView.destroy();
	    	this.paginationView = null;
	    	
		    this._cleared();
		    var data = this._getViewData(null);
		    this._load(data);
		    this._handlePaginationControl(data.paginationInfo);
		    // this._processTemplateViews();
		    this._refreshListView();

	    },
	    
	    /**
	    gets the data from the view. If the view model is a collection and the method gets as an argument data object, 
	    ignores anything else and returns the data object.
	    
	    @method _getViewData
	    @protected
	    @param {Object} obj the data object. If provided (not null) and the view model type is a collection, the obj will be returned as the view's data
	    @return {Object} the view's data
	    @example
	    
	    **/
	    _getViewData: function(obj) {
	    	
			var vmType = this.viewModel.viewModelType;
			if(vmType  != null && vmType == 'Collection') {
				if (obj != null) {
					return obj;
				} else {
					return this.viewModel.getData(obj);	    						
				}
			} else {
					var modelName = this.viewModel.defaultModel();
					var model = null;
					if (modelName) {
						 model = this.viewModel.models[modelName];
					}
					if (model != null) {
						var itemsId;
						if ( !_.isUndefined(model.model) ) {
							itemsId = model.model.idAttribute;
						}
						else {
							itemsId = model.idAttribute;
						}
						if (itemsId == null) {
							itemsId = "id";
						}
						var data = {items : model.toJSON(), idAttribute : itemsId};
						return data;
					 } else {
						 return null;
					 }
			}
		 },
		 

	    /**
	    Adds a list item to the list view's DOM
	    
	    @method _handleItem
	    @protected
	    @param {Object} data the data item to add to the list
	    @return {HTMLElement} the html element that was created for the data item
	    **/
	    _handleItem : function(data) {
		    
		    var elem = $(this.getPopulatedTemplate(this.itemTemplate, data));
		    if (elem.attr("data-uxf-point") == null) {
		    	elem.attr("data-uxf-point", "ui-listitem");
		    }
		    this.getConfig("itemUpdateHTMLFunction")(data, elem, false);
		    if (data.beforeElement != null) {
			    data.beforeElement.before(elem);
		    } else if (data.afterElement != null) {
			    data.afterElement.after(elem);
		    } else if (data.appendElement != null) {
			    data.appendElement.append(elem);
		    } else {
			    this.itemListElement.append(elem);
		    }
		    this._enhanceMarkup(elem);
		    return elem;
	    },
	    
		/**
		Defines the behavior on list item selection 
		
		@method _select
		@private
		@param {event} evt the event object
		**/
	    _select : function(evt) {
		    var elem = $(evt.target).closest('[data-uxf-point="ui-listitem"]');
		    if (elem.attr("id") != null) {
				this._handleEventOnSelect(evt);
			    // triggering event from view
		    	var id = elem.attr("id");
			    var selectObj = {"itemId" : id, "event" : evt};
			    this.trigger('items:selected', selectObj);	
			    // backwards compatible
			    this.viewModel.trigger('items:selected', selectObj);	
			    // calling VM action
			    this.viewModel.handleAction(this.vmKeys['action.select'], selectObj);
		    }
		    else if (elem.attr("data-id") != null) {
				this._handleEventOnSelect(evt);
			    // triggering event from view
		    	var id = elem.attr("data-id");
			    var selectObj = {"itemId" : id, "event" : evt};
			    this.trigger('items:selected', selectObj);	
			    // backwards compatible
			    this.viewModel.trigger('items:selected', selectObj);	
			    // calling VM action
			    this.viewModel.handleAction(this.vmKeys['action.select'], selectObj);
		    }
	    },

		/**
		Retrieves the pagination template. 
		
		@method getPaginationTemplate
		@public
		@return {_template} the template to be used for the pagination control
		**/
	    getPaginationTemplate : function() {
		    return this.paginationTemplate;
	    },
	    

		/**
		This method places the pagination control in the html. override this method to place the pagination control in the 
		correct place per touchpoint. By default, the implementation places it after the list
		
		@method _placePaginationControl
		@protected
		**/
	    _placePaginationControl : function() {
		    // getting the current pagination control
		    var pControl = this.$root.find(".listview-pagination");
		    // if we have a pagination control, we will move it to the last
			// position. if not, we will append it to the last position
		    var lastListItem = this.itemListElement.find('[data-uxf-point="ui-listitem"]:last');
		    if (pControl.length && lastListItem != null) {
			    (pControl).insertAfter(lastListItem);
		    } else {
			    this.itemListElement.append(this.paginationView.$root);
		    }
		    // this._enhanceMarkup(paginationView.$root);
	    },


		/**
		applies theme and css classes to the list and list items
		
		@method _applyStyling
		@protected
		**/
	    _applyStyling : function() {
		    if (this.attr('class') != null) {
			    this.addClass(this.attributes['class']);
			    this.itemListElement.addClass(this.attributes['class']);
		    }
	    },
		
		/**
		Template method to be overriden. Provides a hook for extra activities upon selection of a list item
		
		@method _handleEventOnSelect
		@protected
		@param {event} event the selection event
		**/
		_handleEventOnSelect: function(event){}	
	});

	return view;
});
/**
Default View for the itemlist for web display

@class ItemListView
@namespace Lightsaber.Web
@module Lightsaber.Web
@extends Lightsaber.BaseItemListView

@requires jQuery
@requires Underscore
@requires Lightsaber.Core

@since 9.0.0

@constructor 
@param {Object} options the configuration object. Please find additional params at:
	{{#crossLink "Lightsaber.BaseItemListView"}}{{/crossLink}},
	{{#crossLink "Lightsaber.Core.View"}}{{/crossLink}} 
	@param {Template} 	[options.config.template=_template]	
	@param {Template} 	[options.config.itemTemplate=_itemTemplate]	
	@param {String} 	[options.config.sortFieldName="id"]
@example 
`var view = new Lightsaber.ItemListView({
			viewModel : viewModel,
			sortFieldName : "name"
		});`
**/
define('src/components/itemlist/view/ItemListView',[ 
	'underscore',
	'jquery',
    'text!./template/ItemListTemplate.html', 
    'text!./template/ItemTemplate.html', 
    'lightsaber.core',
    'src/components/itemlist/view/BaseItemListView'
], function(_, $, template, itemTemplate, LightsaberCore, BaseItemListView) {

	 
    var view = BaseItemListView.extend({

    	
    	events: {
		    "click"	:  "_select",
		    "click .clickable"	:  "_select"
		},
		/**
		Places the pagination control next to the element with the class .listview-pagination
		@method _placePaginationControl
		@protected
		**/
    _placePaginationControl : function() {
	    var pControl = this.$root.find(".listview-pagination");
	    // adding control to the div
	    if (pControl.length && pControl.children().length == 0) {
		    pControl.append(this.paginationView.$root);
	    }
	    pControl.show();
    },

    /**
    Always returns null since not relevant to WEB implementation of ItemListView
    @method getPaginationTemplate
    @private
    @return {Object} null value
    @example
    **/
    getPaginationTemplate : function() {
	    return null;
    },
    
    /**
    retrieves the pagination control configuration object
    @method _getPaginationControlsConfiguration
    @protected
   	@return {Object} `[ {
	        control : 'next',
	        disableCallBack : function() {
		        this.hide();
	        },
	        enableCallBack : function() {
		        this.show();
	        }
	    } ,
	    {
	        control : 'prev',
	        disableCallBack : function() {
		        this.hide();
	        },
	        enableCallBack : function() {
		        this.show();
	        }
	    }]`
    **/
    _getPaginationControlsConfiguration : function() {
	    var that = this;
	    return [ {
	        control : 'next',
	        disableCallBack : function() {
		        this.hide();
	        },
	        enableCallBack : function() {
		        this.show();
	        }
	    } ,
	    {
	        control : 'prev',
	        disableCallBack : function() {
		        this.hide();
	        },
	        enableCallBack : function() {
		        this.show();
	        }
	    }]
    }
    });
 
    return view;
});

define('text!src/components/itemlist/view/template/GroupTemplate.html',[],function () { return '<li class="groupdivider"  data-uxf-point="uxf-listdivider">\nGrouped by: <%=item.groupName%>\n<ul class="groupedlist" data-uxf-point="uxf-itemlist">\n</ul>\n</li>\n';});

/**
Baseline class for grouped list implementation in Mobile and Web. Not to be used as SA.

@class BaseGroupedItemListView
@namespace Lightsaber
@module Lightsaber.Mobile
@extends ItemListView

@requires Underscore
@requires jQuery
@requires Backbone
@requires Lightsaber.Core

@since 9.0.0

@constructor 
@param {Object} options the configuration object. Please find additional params at: 
	{{#crossLink "Lightsaber.ItemListView"}}{{/crossLink}}, 
	{{#crossLink "Lightsaber.BaseItemListView"}}{{/crossLink}}, 
	{{#crossLink "Lightsaber.Core.View"}}{{/crossLink}}
@param {CVM} options.viewModel the list's CollectionViewModel
@param {Template} [options.config.template=_template]
@param {Template} [options.config.itemTemplate=_itemTemplate]
@param {Template} [options.config.groupTemplate=_groupTemplate]

@example 
	var view = new Lightsaber.GroupedItemListView({ viewModel : viewModel });
**/
define('src/components/itemlist/view/BaseGroupedItemListView',[ 'underscore', 'jquery', 'text!./template/ItemListTemplate.html', 'text!./template/ItemTemplate.html', 'lightsaber.core',
        'src/components/itemlist/view/BaseItemListView', 'text!./template/GroupTemplate.html' ], function(_, $, template, itemTemplate,
        LightsaberCore, ItemListView, groupTemplate) {

    
    
    
	var view = ItemListView.extend({

		
		/**
		Mapping of the events this view listens to, and the appropriate action  
		 
		@property events
		@private
		@type {Object}
		@param {Object} event {eventType : eventAction} 
		@default {"vclick" : "_select"}
		**/
	    events : {
		    "vclick" : "_select"
	    },

	    /**
	    initializes the view: grabs the group template from the config and calls the baseline class _initialize method.
	    
	    @method initialize
	    @protected
	    **/
	    initialize : function() {
		    this._initialize();
		    // adding the template for the grouped li
		    this.groupTemplate = this.getConfig("groupTemplate") || groupTemplate;
		    this.groupTemplate = _.template(this.groupTemplate);
	    },

		 /**
		 loads the data to the view. will loop through the groups and add all
		 items inside the group
		 
		 @method _load
		 @private
		 @param {Object} data the data that was loaded to the CVM
		 **/
	    _load : function(data) {
		    /***
		     * logic :
		     * we are getting the data in groups with inner items that we will pass on to 
		     * an internal method to handle the group.
		     * the only exception is in a case of pagination after the first page, then we will have to check whether
		     * the last header in the UI is the same as the first group we got. in that case we will add the items
		     * without creating the header
		     */
		    for ( var i = 0; i < data.items.length; i++) {
		    	var appendAfterItem = null;
		    	// checking whether paginated and not the first page and the first group
		    	if (i == 0 && data.paginationInfo != null && data.paginationInfo.pageSize != null && data.paginationInfo.pageNum > 0) {
		    		var lastItem = this._getLastItem()
		    		var currentDivider = this._getItemDivider(lastItem);    		
		    		var isSameDivider = this._areDividersDOMAndDataEqual(currentDivider, {item :data.items[i]}, data.idAttribute)
		    		if(isSameDivider) {
		    			appendAfterItem = lastItem;
		    		}
		    	}
		    	// add the group
		    	var currentGroup = data.items[i];
			    this._addGroupWithItems(currentGroup, data.itemsListName, data.groupIdAttribute, data.idAttribute, null, appendAfterItem);
		    }
	    },

	    /**
	    gets the data from the CVM, in a grouped format for the view to use
	    
	    @method _getViewData
	    @private
	    @param {Object} obj the data for the view
	    @return {} the data
	    **/
	    _getViewData: function(obj) {
			if(typeof this.viewModel.getData == 'function') {
				   return this.viewModel.getGroupedData(obj);	    	
			} else {
				return null;
			}
	    	
		 },
		 
		 /**
		 Adds an item or group to the list. If an index is specified (for sorted list), the item is added to it, otherwise to the end of the list
		 
		 @method _add
		 @private
		 @param {} obj the data to add
		 **/
	    _add : function(obj) {
	    	var data = this._getViewData(obj.modelData);
		    var group = data.group;

		    // checking where the item would be and getting the group of the item after it to see
		    // if we can just dump it there without handling the grouping
		    if (data.item) /* adding a single item */{
			    var item = {
			        item : data.item,
			        idAttribute : data.idAttribute
			    };
			    var addGroupElement = {
				        item : group,
				        idAttribute : data.idAttribute
				};
			    var newGroupElement;
			    var dividerElement;
			    // looking for the item that is at the sorted position. if there is no item, this will be the last item
			    if (data.sortedIndex != null) {
				    var currentListElementAtPosition = this._getItemFromListBySortIndex(data.sortedIndex);
			    } else {
			    	currentListElementAtPosition = null;
			    }
			    // setting the group/divider and the dom placement
			    if (currentListElementAtPosition != null) {
				    // pushing in the list at a certain position
				    item.beforeElement = currentListElementAtPosition;
				    dividerElement = this._getItemDivider(currentListElementAtPosition);
				    addGroupElement.beforeElement = dividerElement;
			    } else {
				    // adding the last element for the list
			    	var lastElement = this._getLastItem();
				    dividerElement = this._getItemDivider(lastElement);
				    item.afterElement = lastElement;
			    }
			    // adding the group/divider. will return null for existing divider
			    var newGroupElement = this._handleAddGroup(addGroupElement, dividerElement);

			    // set the element to the new group in case we need to add it to this
			    // position instead
			    if (newGroupElement != null) {
				    // resetting all the positioning and having the method set it
				    item.beforeElement = null;
				    item.afterElement = null;
				    item.appendElement = null;
				    // setting the group properly on the DOM. this can be different per touchpoint in
				    // case the item is under an element that was created in the template
				    this._setGroupParentDOMElement(newGroupElement, item);

			    }
			    // finally, add the current element
			    var currentItem = this._handleItem(item);
			    
		    } else /* adding an entire group */{
			    this._addGroupWithItems(group, data.itemsListName, data.groupIdAttribute, data.idAttribute, data.sortedIndex);
		    }
		    this._refreshListView();

	    },

		 /**
		 Removes an item or group from the list
		 
		 @method _remove
		 @private
		 @param {Object} obj the item to be removed
		 @param {boolean} isAutoRefresh should the display be automatically refreshed
		 **/
	    _remove : function(obj, isAutoRefresh) {
	    	var data = this._getViewData(obj.modelData);
		    var group = data.group;
		    var removeItemIndex = -1;
		    if (data.item) /* removing only an item */{
			    var removeItem = null;
			    // get the item that should be removed from the list either by the sort index or by id
			    if (data.sortedIndex != null) {
				    removeItem = this._getItemFromListBySortIndex(data.sortedIndex);
			    } else {
				    var id = data.item[data.idAttribute];
				    removeItem = this.itemListElement.find("#" + id);
				     if (removeItem.length == 0) {
			    		removeItem = this.itemListElement.find('[data-id="' + id+'"]');
			    	}
			    }
			    // checking the item is in the UI list
			    if (removeItem.length == 0) {
				    return;			    	
			    }
			    
			    // get the group for the item
			    var itemGroup = this._getItemDivider(removeItem);
			    // remove the item
			    removeItemIndex = $(removeItem).index();
			    removeItem.remove();
			    // see if we need to remove the group if it has no inner items left
			    if (!this._hasInnerItems(itemGroup)) {
				    itemGroup.remove();
			    }

		    } else /* remove the entire group */{
			    var id = group[data.groupIdAttribute];
			    var groupItem = this.itemListElement.find("#" + id);
			    if (groupItem.length == 0) {
			    		groupItem = this.itemListElement.find('[data-id="' + id+'"]');
			    }
			    if (groupItem.length) {
				    // removing the items in the group
				    removeItemIndex = $(groupItem).index();
				    this._removeGroup(groupItem);
			    } else {
				    // doing nothing. group not found.
				    return;
			    }
		    }
		    if (isAutoRefresh) {
			    this._refreshListView();		    	
		    }
		    return removeItemIndex;
	    },

	    
	    /***********************************************************************
		 * M E T H O D S    T H A T C A N    B E   C U S T O M I Z E D    
		 * P E R    T O U C H P O I N T
		 **********************************************************************/
	   
		 /**
		 Writes group to the list. This method checks whether the group should be
		 added as a new group at the end of the list or whether it will be before/after an existing group
		 according to sort
		 
		 @method _handleAddGroup
		 @protected
		 @param {Object} data the data to be added
		 @param {HTML Element} [currentDivider] HTML element with the current divider the 
		 item is situated under. optional, in case we need to decide whether the group is
		 the same and does not need to be added
		 @return jQueryElement the element created
		 **/
	    _handleAddGroup : function(data, currentDivider) {
		    // if we have the DOM element for the group, we will first compare it to the
		    // new group we have according to the data.
		    if (currentDivider != null) {
			    // we will compare the dividers and decide whether we need to add a new one.
			    var groupDomId = data.item.idAttribute;
			    var areDividersEqual = this._areDividersDOMAndDataEqual(currentDivider, data, groupDomId);
			    if (areDividersEqual) {
					   return null;
			    }
		    }   
		    // creating the group element
		    var elem = $(this.getPopulatedTemplate(this.groupTemplate, data));
		    this.getConfig("itemUpdateHTMLFunction")(data, elem, true);
		    // adding an "id" to the group in case we have it and wasn't added by the template
		    if (elem.attr("id") == null && data.idAttribute != null && data.item[data.idAttribute] != null) {
		    	elem.attr("data-id", data.item[data.idAttribute])
		    }
		    if (elem.attr("data-uxf-point") == null) {
		    	elem.attr("data-uxf-point", "uxf-listdivider");
		    }
		    // handling where to exactly put the divider
		    if (data.beforeElement != null) {
			    data.beforeElement.before(elem);
		    } else if (data.afterElement != null) {
			    data.afterElement.after(elem);
		    } else {
		    	this.itemListElement.append(elem);
		    }
		    this._enhanceMarkup(elem);
		    return elem;
	    },

		 /**
		 Removes an entire group. Implementation may be different per
		 touchpoint
		 
		 @method _removeGroup
		 @protected
		 @param {Object} groupItem the group item to be removed
		  **/
	    _removeGroup : function(groupItem) {
		    // loop through the next siblings and stop when we have a new list
		    // divider
		    while (groupItem.length) {
			    var nextItem = groupItem.next();
			    groupItem.remove();
			    groupItem = nextItem;
			    var uxfrole = groupItem.attr("data-uxf-point");
			    if (uxfrole != null && uxfrole == "uxf-listdivider") {
				    // got to the next divider.
				    return;
			    }
		    }
	    },

		 /**
		 Gets the closest group divider for an item, looking backwards.
		 
		 @method _getItemDivider
		 @protected
		 @param {} item the item for which to find the closest divider 
		 @return {DomElement} the closest divider
		 **/
	    _getItemDivider : function(item) {
		    // loop through previous until we find the divider, for some reason
		    // find does not work correctly
		    while (item.length) {
			    item = item.prev();
			    var datarole = item.attr("data-uxf-point");
			    if (datarole != null && datarole == "uxf-listdivider") {
				    return item;
			    }
		    }
	    },
	     /**
	     Gets a specific divider by index. can be overriden per touchpoint
	     
	     @method _getDividerByIndex
	     @protected
	     @param {number} index the index of the divider
	     @return {HTMLElement} the divider
	     **/
	    _getDividerByIndex : function(index) {
	    	var dividers = this.itemListElement.find('[data-uxf-point="uxf-listdivider"]');
	    	if (dividers.length > index) {
	    		return $(dividers[index]);
	    	} else {
	    		return null;
	    	}
	    },
	   
		 /**
		 Gets all the items per a given divider
		 
		 @method _getGroupItems
		 @protected
		 @param {Object} group the group from which to get the items 
		 @return {Array[Object]} the group items
		 **/
	    _getGroupItems : function(group) {
		    var groupItems = [];
		    var groupItem = group.next();
		    while (groupItem.length) {
			    var datarole = groupItem.attr("data-uxf-point");
			    if (datarole != null && datarole == "uxf-listdivider") {
				    // go to the next divider.
				    break;
			    }
			    groupItems[groupItems.length] = groupItem;
			    groupItem = groupItem.next();
		    }
		    return groupItems;
	    },

		 /**
		 Indicator whether the group has children. Used to determine whether
		 to remove an empty group header
		 
		 @method _hasInnerItems
		 @protected
		 @param {Object} group the group to check for inner items
		 @return {boolean} does the group contain items or not
		 **/
	    _hasInnerItems : function(group) {
		    // we see what the next node is
		    group = group.next();
		    if (group.length) {
			    if (group.attr("data-uxf-point") == "uxf-listdivider") {
				    return false;
			    } else {
				    return true;
			    }
		    } else {
			    return false;
		    }
	    },

		 /**
		 Gets the item from the list by index. will only
		 check the inner items since the list also contains the group items.
		 
		 @method _getItemFromListBySortIndex
		 @protected
		 @param {number} sortIndex the index of the item in the sorted list
		 @return {Object} the list item
		 **/
	    _getItemFromListBySortIndex : function(sortIndex) {
		    var listItems = this.itemListElement.find('[data-uxf-point="ui-listitem"]');
		    // getting the list element that is after our new element
		    if (sortIndex < listItems.length) {
			    // getting the element that we will use in order to prepend the
			    // item before it.
			    return $(listItems.get(sortIndex));
		    } else {
			    return null;// listItems.last()
		    }
	    },

		 /**
		 Gets the last item of the group
		 
		 @method _getLastItem
		 @protected
		 @return {HTMLElement} the last item
		 **/
	    _getLastItem : function() {
		    var lastItem = this.itemListElement.find('[data-uxf-point="ui-listitem"]').last();
		    return lastItem;
	    },

		 /**
		 Adds a new group. will be either added according to the sort index or at the end.
		 In special cases, where existing group is sent (pagination can cause this), it will
		 be added to the existingGroup
		 
		 @method _addGroupWithItems
		 @protected
		 @param {Object} group the new group to add
		 @param {Object} itemListName the name of the field in the group Object that contains the list of group items
		 @param {Object} groupIdAttribute the id attribute name for the group element
		 @param {Object} itemIdAttribute the id attribute name for items within the group
		 @param {Object} groupSortedIndex where to place the group within the current list.  
		 @param {Object} appendToItem an item to which to append the group. 
		 **/
	    _addGroupWithItems : function(group, itemListName, groupIdAttribute, itemIdAttribute, groupSortedIndex, appendToItem) {
		    var newgroupInput = {
			        "item" : group,
			        "idAttribute" : groupIdAttribute
			}
		    if (groupSortedIndex != null) {
		    	newgroupInput.beforeElement = this._getDividerByIndex(groupSortedIndex);
		    }	
		    var myItem = { "idAttribute" : itemIdAttribute }
		    if (appendToItem == null) {
		    	var currentGroup = this._handleAddGroup(newgroupInput);		    	
			    this._setGroupParentDOMElement(currentGroup, myItem);
		    } else {
		    	myItem.afterElement = appendToItem;
		    }

		    var groupedInnerList = group[itemListName];
		    if (groupedInnerList && groupedInnerList.length > 0) {
			    for ( var j = 0; j < groupedInnerList.length; j++) {
				    myItem.item = groupedInnerList[j];
				    myItem.afterElement = this._handleItem(myItem);
			    }
		    }
	    },

		 /**
		 Used to return the list parent element so that we know where to plant
		 the list element. returns null in order to plant under the root
		 element
		 
		 @method _setGroupParentDOMElement
		 @protected
		 @param {Object} currentgroup 
		 @param {Object} item 
		 **/
	    _setGroupParentDOMElement : function(currentgroup, item) {
		    item.afterElement = currentgroup;
	    },

		/**
		Override per touchpoint. checks whether 2 groups are the same in case
		they do not have an ID that can be compared
		
		@method _areGroupDOMElementsEqual
		@protected
		@param {jQueryElement} group1 group to compare
		@param {jQueryElement} group2 group to compare
		@return {boolean} true if the groups are the same
		**/
	    _areGroupDOMElementsEqual : function(group1, group2) {
		    if (group1.contents().eq(0).text() == group2.contents().eq(0).text()) {
			    return true;
		    } else {
			    return false;
		    }

	    },
	    
	     /**
	     Checkes whether a divider on the DOM (HTML) would be the same
	     as the divider we would create from the data for the divider
	     
	     @method _areDividersDOMAndDataEqual
	     @protected
	     @param {jQueryElement} existingDivider the divider that is currently layed in the DOM
	     @param {Object} dataDivider the data by which to create the new divider
	     @param {String} groupDomId the id attribute name in the dataDivider Object
	     @return [boolean] true if the dividers are the same
	     **/
	    _areDividersDOMAndDataEqual : function(existingDivider, dataDivider, groupDomId) {
	    	if (existingDivider == null) return false;
		    if (existingDivider.attr("id") != null && groupDomId) {
			    return (dataDivider.item[groupDomId] == existingDivider.attr("id")) 
		    } else if (existingDivider.attr("data-id") != null && groupDomId) {
			    return (dataDivider.item[groupDomId] == existingDivider.attr("data-id")) 
		    } else {
			    var elem = $(this.groupTemplate(dataDivider));
			    // in case we have the same template, we will not create it again.
			   return this._areGroupDOMElementsEqual(existingDivider, elem);
		    }
	    }

	});

	return view;
});
/**


Default View for the grouped itemlist for mobile display.

Important Note for the templates: 
The items should have a "ui-listitem" data-uxf-point, 
each divider should have a "uxf-listdivider" data-uxf-point at the enclosing element,
if there is an element in the enclosing element that holds the items it should have the "uxf-itemlist" data-uxf-point 
in the template that contains the items.

@class GroupedItemListView
@namespace Lightsaber.Web
@module Lightsaber.Web
@extends Lightsaber.BaseGroupedItemListView
@requires jQuery
@requires Underscore
@requires Lightsaber.Core 
@since 9.0.0
@constructor
@param {Object} options the configuration object. Please find additional params at: 
{{#crossLink "Lightsaber.BaseGroupedItemListView"}}{{/crossLink}},
{{#crossLink "Lightsaber.ItemListView"}}{{/crossLink}},
{{#crossLink "Lightsaber.BaseItemListView"}}{{/crossLink}}, 
{{#crossLink "Lightsaber.Core.View"}}{{/crossLink}}
@param {Template}   [options.config.template=_template]  the template for the entire list
@param {Template}   [options.config.itemTemplate=_itemTemplate] the template for a list item
@param {Template}   [options.config.groupTemplate=_groupTemplate]   the template for a group in the list
@example 
`var view = new Lightsaber.GroupedItemListView({
            viewModel : viewModel
        });`
**/
define('src/components/itemlist/view/GroupedItemListView',[ 
	'underscore',
	'jquery',
    'text!./template/ItemListTemplate.html', 
    'text!./template/ItemTemplate.html', 
    'lightsaber.core',
    'src/components/itemlist/view/BaseGroupedItemListView',
    'text!./template/GroupTemplate.html'
], function(_, $, template, itemTemplate, LightsaberCore, BaseGroupedItemListView, groupTemplate) {

     
    var view = BaseGroupedItemListView.extend({

                
    	events: {
		    "click"	:  "_select",
		    "change" : "_select"
		},
		

        /***
         * Gets the closest divider for an item. Will always look backwards.
         */
        _getItemDivider : function(item) {
        	// in case all our elements are in one list like in mobile
        	var itemPrev = item.prevAll('[data-uxf-point="uxf-listdivider"]');
        	if (itemPrev.length > 1) {
        		return $(itemPrev.get(0));
        	}
	       	if (itemPrev.length) {
	       		return itemPrev;
	       	} 
	       	// in case we have a list per group
        	while(item.length) {
	    		 item = item.parent();
	    		 if (item.attr("data-uxf-point") == "uxf-listdivider") {
	    			 return item;
	    		 }
	    	 }
        },

       /***
        * Indicator whether the group has children. Used to determine whether to remove an
        * empty group header
        */ 
        _hasInnerItems : function(group) {
       	 	// we see what the next node is
        	var currentUl = group.find('[data-uxf-point="uxf-itemlist"]'); 
        	// in case this is a list like mobile where everything is in one list, we will look until the next divider
        	if (!currentUl.length) {
        		var nextelem = group.next();
        		if (nextelem.length) {
        			return (nextelem.attr("data-uxf-point") != "uxf-listdivider");
        		} else {
        			return false;
        		}
        	}
        	return (currentUl.children().length > 0);
        },

        
        /***
         * Used to return the list parent element so that we know where to plant the list element.
         * returns null in order to plant under the root element
         */
        _setGroupParentDOMElement : function(currentgroup, item) {
        	var currentUl = currentgroup.find('[data-uxf-point="uxf-itemlist"]');
        	if (currentUl.length) {
            	item.appendElement = currentUl;        		
        	} else {
        		// BWC looking for ul
        		currentUl = currentgroup.find('ul');
        		if (currentUl.length) {
                	item.appendElement = currentUl;        		
            	} else {
            		item.afterElement = currentgroup;            		
            	}	
        	}
        },
	    /***
	     * Gets a specific divider by index. can be overriden per touchpoint
	     */
	    _getDividerByIndex : function(index) {
	    	var dividers = this.$root.find('[data-uxf-point="uxf-listdivider"]');
	    	if (dividers.length > index) {
	    		return $(dividers[index]);
	    	} else {
	    		return null;
	    	}
	    },       
        /***
         * Gets the item from the ilst according to the sort index. will only
         * check the inner items since the list also contains the group items
         */
        _getItemFromListBySortIndex : function(sortIndex) {
				var listItems = this.$root.find('[data-uxf-point="ui-listitem"]');
				// getting the list element that is after our new element
				if (sortIndex < listItems.length) {
					// getting the element that we will use in order to prepend the item before it.
					return $(listItems.get(sortIndex));            		        		
				} else {
					return null;//listItems.last()
				}
        },
        
        _placePaginationControl : function() {
    	    var pControl = this.$root.find(".listview-pagination");
    	    // adding control to the div
    	    if (pControl.length && pControl.children().length == 0) {
    		    pControl.append(this.paginationView.$root);
    	    }
    	    pControl.show();
        },


        getPaginationTemplate : function() {
    	    return null;
        },
        
        _getPaginationControlsConfiguration : function() {
    	    var that = this;
    	    return [ {
    	        control : 'next',
    	        disableCallBack : function() {
    		        this.hide();
    	        },
    	        enableCallBack : function() {
    		        this.show();
    	        }
    	    }]
        }
        

    })
    return view;
});

define('src/components/navbar/viewmodel/NavBarViewModel',['underscore',
    'lightsaber.core'],
function(_, Lightsaber) {

    var NavBarViewModel = Lightsaber.ViewModel.extend({
        initialize: function(options){
            _.each(this.subViewModels, function(buttonViewModel) {
                buttonViewModel.on("user:action", function (action) {
                    this.handleUserAction(action);
                }, this);
            }, this);
        }
    });

    return NavBarViewModel;
});

define('text!src_web/components/tabpanel/view/template/TabPanelTemplate.html',[],function () { return '<div class="uxf-tabpanel">\n\t<ul data-uxf-point="uxf-tabs"></ul>\n</div>\n';});


define('text!src_web/components/tabpanel/view/template/TabTemplate.html',[],function () { return '<li>\n    <a href="#tabs-<%= id %>"><%= name %></a>\n</li>';});

/**
<em>TabPanel</em> component.

Allows to dynamically define the tabs (via *ViewModel* containing a corresponding array). 
Population of the panes of the *TabPanel* is responsibility of the *TabPanel's* creator and
is not performed automatically. *TabPanel*, much like its sibling, *Accordion* are merely a layout
component with some presentation logic added in - hiding and showing corresponding pane when
a tab is clicked.

A simple example would be:

```javascript
var collection = new Lightsaber.Core.Collection([
    {id: 'id1', name: 'Tab 1'},
    {id: 'id2', name: 'Tab 2'},
    {id: 'id3', name: 'Tab 3'}
]);

var collectionViewModel = new Lightsaber.CollectionViewModel({
    models: {
        items: collection
    } 
});

new Lightsaber.TabPanelView({
    el: $root,
    viewModel: collectionViewModel
});
```

## Main template

```html
<div class="uxf-tabpanel">
    <ul data-uxf-point="uxf-tabs"></ul>
</div>
```

## Tab template

```html
<li>
    <a href="<%= id %>"><%= name %></a>
</li>
```

@class Lightsaber.Web.TabPanelView
@namespace Lightsaber
@module Lightsaber.Web
@extends Lightsaber.Core.View

@since 9.0.0

@requires jquery
@requires Underscore
@requires Lightsaber.Core

@constructor
@param {Object} [options] constructor's only parameter
@param {Object} [options.config] main configuration parameter
@param {String} [options.config.template] main <em>TabPanel's</em> template  
@param {String} [options.config.autoRender=true] whether *TabPanel* should render immediately or wait for data from *ViewModel* 
@param {String} [options.config.idAttribute] name of the property (on the <em>ViewModel</em>), that uniquely identifies a collapsible pane
@param {String} [options.config.vmKeys] mapping of expected name of <em>ViewModel</em> properties
property to its actual name in the specific <em>ViewModel</em> that this <em>View</em> 
receives at runtime.

**/
define('src_web/components/tabpanel/view/TabPanelView',[
  'jquery',
  'underscore',
  'lightsaber.core',
  'text!./template/TabPanelTemplate.html',
  'text!./template/TabTemplate.html'
], function($, _, LightsaberCore, template, tabTemplate) {

        //>>excludeEnd('metaDataExclude');

	var tabPanelView = LightsaberCore.View.extend({

	            publicMethods : ['position','addToPane','addTab','addTabs','getPane','select'],

        /**
        Main configuration property.

        @property {Object} config
        @param {String|Function} template *TabPanel's* main template
        @param {String|Function} tabTemplate *TabPanel's* tab template
        @param {String} idAttribute name of the ID attribute that uniquely identifies tab data
        @param {Boolean} visible defines whether *TabPanel* should be visible; doing so will add `display: none` into *TabPanels* root's element `style` attribute
        @param {Boolean} enabled defines whether *TabPanel* should be enabled (so that user can interact with tabs by clicking on them); setting this will add `ui-state-disabled` CSS class to the root element of the *TabPanel*
        @param {String} selected ID of the tab to be **initially** selected
        **/
        config : {
            idAttribute : 'id',
            visible : true,
            enabled : true,
            position : 'top' // Not implemented
        },
    
        idAttribute : 'id',
        template : template,
        tabTemplate: tabTemplate,

        selected : undefined,

        /**
        Main-entry method.

        The main functional purpose is to bind handlers to two events that *ViewModel* triggers: `items:loaded` and `items:added` - {{#crossLink "Lightsaber.Web.TabPanelView/_load"}}{{/crossLink}} for `items:loaded` and {{#crossLink "Lightsaber.Web.TabPanelView/_add"}}{{/crossLink}} for `items:added`.

        This is done to allow *TabPanel* to response to data events in the *ViewModel*, for example, to refresh the tabs when they are changed via *ViewModel's* data.

        @method initialize
        @protected
        **/
        initialize: function() {
            this.template = this.getConfig('template') || this.template;
            this.tabTemplate = _.template(this.getConfig('tabTemplate') || this.tabTemplate);
            this.idAttribute = this.getConfig('idAttribute') || this.idAttribute;
            
            this.setConfig('enabled', this.getConfig('enabled') && this.viewModel.getConfig('enabled') );
            this.setConfig('visible', this.getConfig('visible') && this.viewModel.getConfig('visible') );
            this.viewModel.on('items:loaded', this._load, this);
            this.viewModel.on('items:added', this._add, this);
        },
        
        /**
        Overrides (nullified) default behaviour from {{#crossLink "Lightsaber.Core.View"}}{{/crossLink}}
        @protected
        **/
        _handleSubViews: function() {
            // Done to override default attachment of SubViews through View algorithm.
            if(this.subViews) {
                this.navSubViews = this.subViews;
            }
        },

        /**
        Renders main and tab templates using provided data, while performing the following tasks:

        1. resets local copy of data
        2. empties the main template's DOM structure (rendered, of course)
        3. calls `_handleTemplate` method from {{#crossLink "Lightsaber.Core.View"}}{{/crossLink}}, which renders the main template
        4. calls `addTabs` method
        
        @method _load
        @protected
        @param {Array} data tabs' data with structure similar to:

        ```javascript
        [
            {id: 'id1', name: 'Tab 1'}, 
            {id: 'id2', name: 'Tab 2'}, 
            {id: 'id3', name: 'Tab 3'}
        ]
        ```
        **/
        _load : function(data) {
            this.tabsData = [];
            this._empty();
            this._handleTemplate();
            this.addTabs(data);
        },
        
        /**
        Handles tab addition.
    
        @method _add
        @private
        **/
        _add : function(tabsData) {
            this._emptyTabs();
            this.addTabs(tabsData);
        },
        
        /**
        @private
        @deprecated
        **/
        position : function(position) {
        },
        
        /**
        Caches jQuery objects to:

        1. root DOM element of the *TabPanel*
        2. DOM element that contains the tabs

        and loads the tabs by calling {{#crossLink "Lightsaber.Web.TabPanelView/config:property"}}{{/crossLink}} method. This is done to ensure that if *ViewModel* already contains initial data (or static data, in some cases) it is loaded.

        @method _postRender
        @protected
        **/
        _postRender : function() {
            this.$tabs = this.$('ul');
            this.$root = this.$tabs.parent();
            this.$tabs = this.$root.find('ul');
            this._load();
        },
        
        /**
        Adds a new tab represented by data of `{id: 'some id', name: 'some name'}` structure where `id` will serve as new tab's ID and `name` as it's name.

        @method addTab
        @param {Object} tabsData data for the tab to be created
        **/     
        addTab : function(tabData) {
            this._add(tabData);
        },
        
        /**
        Internal implementation of tab addition mechanism. Differs from {{#crossLink "Lightsaber.Web.TabPanelView/addTab:method"}}{{/crossLink}} with the context in which called and some additional BWC concerns.

        @method _addTab
        @private
        **/
        _addTab : function(tabData) {
            // backward compatibility to version 1.8
            var instance = $.data( this.$root.get()[0], "ui-tabs" );
            if ( !instance ) {
                    this.$root.tabs( "add", "#tabs-" + (tabData[this.idAttribute] || tabData.code), tabData.name ); 
            } else {
                var compiledTemplate = this.tabTemplate({
                    id: tabData[this.idAttribute] || tabData.code,
                    name: tabData.name
                });

                this.$root.find('> [data-uxf-point="uxf-tabs"]').append(compiledTemplate);
                this.$root.find('[data-uxf-point="uxf-tabs"]').after('<div id="tabs-'+(tabData[this.idAttribute]  || tabData.code)+'"></div>');
                this.$root.tabs( "refresh" ); 
            }
        },
        
        /**
        Adds several new tabs represented by array of data of `{id: 'some id', name: 'some name'}` structure where `id` will serve as new tab's ID and `name` as it's name.

        @method addTabs
        @param {Array <Object>} tabsData data for all the tab to be created
        **/ 
        addTabs : function(tabsData) {  
            var selected, first, tabsDataArr, 
            
            tabsDataArr = this._transformData(tabsData);
            
            for ( var i = 0, l = tabsDataArr.length; i < l; i++) {
                this.tabsData.push(tabsDataArr[i]);                 
            }
            
            this.$root.off('tabsbeforeactivate').on('tabsbeforeactivate', _.bind(this._handleSelect, this));
            this.$root.off('tabsshow').on('tabsshow', _.bind(this._handleSelect, this));
            this.$root.tabs();
            
            for ( var i = 0, l = this.tabsData.length; i < l; i++) {
                this._addTab(this.tabsData[i]);                 
            }
                
            this._makeSelection(tabsDataArr);
            this._handleVisibleAndEnable();
        },
        
        /**
        Covers for deficiencies of data structure as it comes from different mechanisms - to ensure consistency.
    
        @method _transformData
        @private
        **/
        _transformData : function(tabsData) {
            var tabsDataArr;
            
            tabsData = tabsData || this.viewModel.getData() || this.viewModel.get();
            
            if(tabsData && tabsData.item) {
                tabsDataArr = tabsData.item;
            }
            else if(tabsData && !tabsData.items) {
                tabsDataArr = tabsData;
            }
            else if(tabsData && tabsData.items){
                tabsDataArr = tabsData.items;
            }
            else {
                tabsDataArr = [];
            }
            
            if(Object.prototype.toString.call(tabsDataArr) !== '[object Array]') {  
                tabsDataArr = new Array(tabsDataArr);
            }
            
            return tabsDataArr;
        },
        
        /**
        Selects the tab.

        @method _makeSelection
        @private
        **/
        _makeSelection : function(tabsDataArr) {
            var first = tabsDataArr && tabsDataArr[0];

            var selected = this.getConfig('selected') || (  first && ( first[this.idAttribute] || first.code || first.name ) );
            this.select(selected);
        },
        
        /**
        Handles visibility and enablement of the *TabPanel* component.

        Calls {{#crossLink "Lightsaber.Web.TabPanelView/_disableTabs"}}{{/crossLink}} and {{#crossLink "Lightsaber.Web.TabPanelView/_enableTabs"}}{{/crossLink}}, based on {{#crossLink "Lightsaber.Web.TabPanelView/config:property"}}{{/crossLink}} configuration property.

        Hides *TabPanel's* root element (and as a result the entire *TabPanel*), based on {{#crossLink "Lightsaber.Web.TabPanelView/config:property"}}{{/crossLink}} configuration property.

        @method _handleVisibleAndEnable
        @protected
        **/
        _handleVisibleAndEnable : function() {
            if(!this.getConfig('enabled')) {
                this._disableTabs();           
            }
            else {
                this._enableTabs();                             
            }
            
            if(!this.getConfig('visible')) {
                this.$root.hide();
            }
        },
        
        /**
        Get pane (as *jQuery* object) by ID (for population of content, for example).

        @method getPane
        @param {String} id  ID of the tab the pane belongs to
        **/ 
        getPane : function(id) {
            var paneSelector = '#tabs-' + id;
            return this.$(paneSelector);
        },
        
        /**
        Adds HTML as content to a pane with the given ID.

        @method addToPane
        @param {String} id ID of the tab the pane belongs to
        @param {String} html HTML that represents the content to add to the pane
        **/ 
        addToPane : function(id, html) {
            //var paneSelector = '#tabs-' + id, pane = this.$(paneSelector);
            var pane = this.getPane(id);
            pane.append(html);          
        },
        
        /**
        Empties the content that is generated (via main and tab templates) by the *TabPanel*.

        @method _empty
        @protected        
        **/
        _empty : function() {
            this.$root && this.$root.empty() && this.$root.remove();        
        },
        
        /**
        Empties the content that is generated (via tab templates) by the *TabPanel* tabs **only**.

        @method _emptyTabs
        @protected        
        **/
        _emptyTabs : function() {
            this.$root && this.$root.find('> [data-uxf-point="uxf-tabs"]').empty();
        },

        /**
        Selects the tab by given ID.

        If tabs are disabled then no tab is selected.

        @method select
        @param {String} id ID of the tab
        **/
        select : function(id) {
            if (this.selected == id) {
                return;
            }
            // backward compatibility to version 1.8
            var instance = $.data( this.$root.get()[0], "ui-tabs" );
            if ( !instance ) { // in jQuery 1.8.24 naming convention is different, so none is returned
                    var tabindex = this.$root.find('li').index(this.$root.find('li > a[href="#tabs-' + id+'"]').parent());
                    this.$root.tabs('select', tabindex); 
            } else { // in 1.10.3 the selection is by index, not id
                var tabindex = this.$root.find('li').index(this.$root.find('[aria-controls="tabs-'+id+'"]'));
                this.$root.tabs('option','active',tabindex ); 
            }   
            
        },
        
        /**
        Selection handling with some BWC.

        @private
        **/
        _handleSelect : function(event, ui) {
            // need to support both versions 1.8.24 and 1.10.3. 
            // since in 1.10.3 there is ui.newTab and not ui.tab we make here the distinction
            if (ui.tab != undefined) {
                var id = $(ui.tab).attr('href').substr(6);
                this._selectTab(id);    
            } else if (ui.newTab != undefined) {
                var id = $(ui.newTab).attr('aria-controls').split(' ')[0].substr(5);
                this._selectTab(id);
            }
            
            event.stopPropagation();
        },

        /**
        Inner selection logic for tab selection.

        @private
        **/
        _selectTab : function(id) {
            // only refresh dom and trigger event if tab is not already selected. 
            if (this.selected != id) { 
                this.selected = id;
                this._selectPane(id);

                /**
                Fires when a tab is selected.
                @event
                @memberOf Lightsaber.Web.TabPanelView
                @name tab:selected
                @param {String} id of the selected tab
                **/
                this.trigger('tab:selected', id);
            }
        },
        
        /**
        Inner selection logic for tab selection.

        @private
        **/
        _selectPane : function(id) {        
            var $selectedPane = this.$('[id="tabs-'+id+'"]');
            $selectedPane.show();
        },
        
        /**
        Disables tabs. 

        Normally, change of enable/disable state is done via *ViewModel*.

        @private
        **/
        _disableTabs : function(){
            // need to support both versions 1.8.24 and 1.10.3. 
            this.$root.off('tabsshow');
            this.$root.off('tabsbeforeactivate');
                        
            this.$root.tabs("disable");
            this.$root.addClass('ui-state-disabled');
        },
        
        /**
        Enables tabs. 

        Normally, change of enable/disable state is done via *ViewModel*.

        @private
        **/
        _enableTabs : function(){
            this.$root.tabs("enable");
            this.$root.removeClass('ui-state-disabled');
            
            // need to support both versions 1.8.24 and 1.10.3. 
            this.$root.off('tabsshow').on('tabsshow', _.bind(this._handleSelect, this));
            this.$root.off('tabsbeforeactivate').on('tabsbeforeactivate', _.bind(this._handleSelect, this));            
        },

        /**
        Enable/disable change handler.

        Normally is called automatically when the corresponding property on the *ViewModel* is changed

        @method onEnableChange
        @protected
        @param {Object} event event object of {value: '...'} structure
        **/
        onEnableChange : function(event){
            this.setConfig('enabled', this.getConfig('enabled') && this.viewModel.getConfig('enabled') );
            if(event.value === true){
                this._enableTabs();
            }else{
                this._disableTabs();
            }
        }
    });
    
    return tabPanelView;
});

/**
<em>NavBar</em> component.

The UXF *NavBar* extends *TabPanel*, since one can look at it as a *TabPanel* without the panes. Basically *NavBar* allows
definition of a group of buttons.

@class Lightsaber.Web.NavBarView
@namespace Lightsaber
@module Lightsaber.Web
@extends Lightsaber.Web.TabPanelView

@since 9.0.0

@requires jQuery
@requires Underscore
@requires Lightsaber.Core

@constructor
@param {Object} [options] constructor's only parameter
@param {Object} [options.config] main configuration parameter
@param {String} [options.config.template] main <em>TabPanel's</em> template  
@param {String} [options.config.autoRender=true] whether *TabPanel* should render immediately or wait for data from *ViewModel* 
@param {String} [options.config.vmKeys] mapping of expected name of <em>ViewModel</em> properties
property to its actual name in the specific <em>ViewModel</em> that this <em>View</em> 
receives at runtime.

**/
define('src_web/components/navbar/view/NavBarView',[
	'underscore',
    'lightsaber.core',
    'src_web/components/tabpanel/view/TabPanelView'
], function(_, LightsaberCore, TabPanelView) {

    
	var NavBarView = TabPanelView.extend({
	    		
		
		/**
        Caches jQuery objects to:

        1. root DOM element of the *NavBar*
        2. DOM element that contains the buttons
        3. panes DOM element

        and loads the tabs by calling {{#crossLink "Lightsaber.Mobile.NavBarView/config:property"}}{{/crossLink}} method. This is done to ensure that if *ViewModel* already contains initial data (or static data, in some cases) it is loaded.

        @method _postRender
        @protected
        **/
		_postRender : function() {
			var display = 'block';
			if(this.getConfig('orientation') !== 'vertical') {
				display = 'inline';
			}
			this.$tabs = this.$('ul');
			this.$root = this.$tabs.parent();
			this.$tabs = this.$root.find('ul');
			if(this.navSubViews && this.navSubViews.length) {
				for (var i = 0, length = this.navSubViews.length; i < length; i++) {
					var $button = $('<li style="display: ' + display + ';"></li>').append(this.navSubViews[i].viewInstance.$el);
					this.$tabs.append($button);
				};
			}
			else {
				this._load();
			}
		},

		/**
		Processes *SubViews*.

		@method _processSubViews
		@protected
		**/
		_processSubViews : function() {
			for (var i = 0, length = this.navSubViews.length; i < length; i++) {
				var $button = $('<li></li>').append(this.navSubViews[i].viewInstance.$el.attr('data-corners', false));
				this.$tabs.append($button);
			};
			//console.log(this.$tabs[0]);
			this.$root.trigger('create');
		}
	});

	return NavBarView;
});

define('src/components/navbar/viewmodel/SubNavBarViewModel',['underscore',
        'lightsaber.core'],
function(_, Lightsaber) {


    var SubNavBarViewModel = Lightsaber.ViewModel.extend({

            initialize: function(options){
                this.subViewModels.button.on('user:action', function(action) {
                    this.trigger('user:action', action);
                }, this);
            }
    });

    return SubNavBarViewModel;
});
/**
@class Lightsaber.Mobile.SubNavBarView
@namespace Lightsaber
@module Lightsaber.Mobile
@extends Lightsaber.Mobile.NavBarView

@since 9.0.0
@deprecated 9.0.1

@private

**/
define('src_web/components/navbar/view/SubNavBarView',[
    'underscore',
    'src_web/components/navbar/view/NavBarView'
], function(_, NavBarView) {

    
    
    
    var SubNavBarView = NavBarView.extend({
            
        tagName: 'ul',

        initialize: function(options) {
            var subViews = this.getConfig('subViews');
            if (!(subViews.button && subViews.submenu)) {
                throw new Error("Lightsaber.SubNavBarView: 'button' and 'submenu' subviews should be specified");
            }
            this._subMenuDetails = subViews.submenu;
            this.subViews = [subViews.button];
            this.setConfig('subViews', this.subViews);
            this._super(options);
        },

        _postRender: function() {
            var subNavBar = new NavBarView(_.extend({
                    viewModel: this.viewModel,
                    tagName: 'ul'},
                this._subMenuDetails));
            this.$root.children('li').append(subNavBar.$root);
        }

    });

    return SubNavBarView;
});


define('text!src/components/chart/view/template/labelTemplate.html',[],function () { return '<span style="font-weight: bold;" class="uxf-label"><%=value%></span>';});


define('text!src/components/chart/view/template/xAxisLabelTemplate.html',[],function () { return '<span style="font-weight: bold;"><%=value%></span>';});

/**
<em>Chart</em> component. 

<dfn title="">Chart</dfn> is a unique UXF component in that it envelops an external library and doesn't provide
almost any additional capabilities (simply because [Highcharts](http://www.highcharts.com/demo/) is so vast).

Almost all configuration options are passed to the *Highcharts* object as is and it is advised that you 
go to [Highcharts](http://www.highcharts.com/demo/) for full information on *Chart* abilities and limitations.

Passing all options in `highChartsConfig` configuration property of *Chart's* constructor will pass all the options,
**as is, with addition of the *ViewModel* data**, to the *Highcharts object*, ignoring any UXF-specific settings.

A simple example below demonstrates the creation of a *Chart* widget using static data stored in a `ViewModel` and
with configuration options passed into `config` parameter of the `ChartView`.

```javascript
var viewModel = new Lightsaber.Core.ViewModel({
    data: {
        series : [100.5, 10.25, -20.5, 200],
        axisLabels : ['Sep', 'Oct', 'Nov', 'Dec']
    }
});

new Lightsaber.ChartView({
    el: $root,
    viewModel: viewModel,
    config: {
        showPointLabels: true,
        showXAxisLabels: false,
        drawGridlines: false,
        barWidth: 30,
        legend: {
            enabled: true
        }
    }
});
```

## XAxis template

```html
<span style="font-weight: bold;"><%=value%></span>
```

## Label template

```html
<span style="font-weight: bold;" class="uxf-label"><%=value%></span>
```

@class Lightsaber.Mobile.ChartView
@namespace Lightsaber
@module Lightsaber.Mobile
@extends Lightsaber.Core.View

@since 9.0.0

@requires jquery
@requires underscore
@requires highcharts
@requires Lightsaber.Core

@constructor
@param {Object} [options] constructor's only parameter
@param {Object} [options.config] main configuration parameter
@param {String} [options.config.template=accordionTemplate] main <em>Accordion's</em> template  
@param {String} [options.config.collapsibleTemplate=collapsibleTemplate] <em>Accordion's</em> collapsible template  
@param {String} [options.config.autoRender=true] whether *Accordion* should render immediately or wait for data from *ViewModel* 
@param {String} [options.config.idAttribute='id'] name of the property (on the <em>ViewModel</em>), that uniquely identifies a collapsible pane
@param {String} [options.config.vmKeys={}] mapping of expected name of <em>ViewModel</em>
property to its actual name in the specific <em>ViewModel</em> that this <em>View</em> 
receives at runtime.
@param {String} [options.config.expandableAll=false] indicates that multiple collapsible panes are allowed to be expanded simultaneously
@param {String} [options.config.expanded=undefined] array of IDs of collapsible panes that should be expanded by default
**/
define('src/components/chart/view/ChartView',[
	'jquery',
    'underscore', 
    'highcharts',
    'lightsaber.core',
    'text!./template/labelTemplate.html',
    'text!./template/xAxisLabelTemplate.html',
], function($,_, highcharts, Lightsaber, labelTemplate, xAxislabelTemplate) {

	

    
	var BarChart = Lightsaber.View.extend({

				publicMethods : ['getChartObject','setShowPointLabels','setShowXAxisLabels','setShowYAxisLabels'],

		events : {
		},

		/**
		Configuration property that maps expected *ViewModel* properties to the actual ones.
		
		@property {Object} vmKeys
		@param {Object} [vmKeys.data.series='series'] default name of the propery of the *ViewModel*
		@param {Object} [vmKeys.data.axisLabels='axisLabels'] default name of the propery of the *ViewModel*
		@param {Object} [vmKeys.data.labels='labels'] default name of the propery of the *ViewModel*
		@param {Object} [vmKeys.data.lines='lines'] default name of the propery of the *ViewModel*
		@param {Object} [vmKeys.data.generic='generic'] default name of the propery of the *ViewModel*
		that *Accordion* expects to receive the data on
		**/
		vmKeys: {
			"data.series" : "series",
			"data.axisLabels" : "axisLabels",
			"data.labels" : "labels",
			"data.lines" : "lines",
			"data.generic" : "data"
		},

		/**
		Describes default values of the properties (on the ViewModel of the button) for `text` and `label`.
		
		For more information see {{#crossLink "Lightsaber.Core.View"}}{{/crossLink}}.

		@property {Object} vmKeysChangeEvents
		@param {Object} [vmKeys.data.series='render'] default handler of the corresponding property's `change` event
		@param {Object} [vmKeys.data.axisLabels='render'] default handler of the corresponding property's `change` event
		@param {Object} [vmKeys.data.labels='render'] default handler of the corresponding property's `change` event
		@param {Object} [vmKeys.data.lines='render'] default handler of the corresponding property's `change` event
		@param {Object} [vmKeys.data.generic='render'] default handler of the corresponding property's `change` event
		**/
		vmKeysChangeEvents: {
			"data.series" : "render",
			"data.axisLabels" : "render",
			"data.labels" : "render",
			"data.lines" : "render",
			"data.generic" : "render"
		},

		/**
		Main configuration property.

		@property {Object} config
		@param {Boolean} [autoRender=false] whether the *View* should be rendered immediately upon instantiation
		@param {Boolean} [chartConfig={}] configuration of the chart - when provided the entire config is passed as is to *Highcharts* object
		**/
		config: {
			autoRender: false
		},

		// is Stand-Alone. Meaning UXF is merely a container with VM and all config options to highcharts are passed directly via config.chartConfig
		isChartConfig : false,

		/**
		Main-entry method.

		@method initialize
		@protected
		**/
		initialize : function() {

			_.bindAll(this);

			// apply different logic when UXF is only a container of highcharts with VM capabilities
			if (typeof this.getConfig('chartConfig') != 'undefined' ) {
				this.isChartConfig = true;
				return;
			}

			this.dataLabelFormatter = this.getConfig("dataLabelFormatter");

			if(this.dataLabelFormatter == null){
				this.labelTmpl = this.getConfig("labelTmpl") || labelTemplate;
				this.labelTmpl = _.template(this.labelTmpl);
			}

			this.xAxisLabelFormatter = this.getConfig("xAxisLabelFormatter");
			this.yAxisLabelFormatter = this.getConfig("yAxisLabelFormatter");

			if(this.xAxisLabelFormatter == null){
				this.xAxisLabelTmpl = this.getConfig("xAxisLabelTmpl") || xAxislabelTemplate;
				this.xAxisLabelTmpl = _.template(this.xAxisLabelTmpl);
			}

			this.dataLabelPositionY = this.getConfig("dataLabelPositionY");

			this.plotLinesY = [];
			this.plotLinesX = [];

			// backwards compatability 
			if (this._getVMData("data.series") == null && this.viewModel.getDataBinding().length == 0 && 
					this.viewModel.models && this.viewModel.models.items) {
				this.viewModel.dataBindings = [
				   			    			{ 'axisLabels': 'models.items.axisLabels', options: {setOnBind: true} },
				   			    			{ 'series': 'models.items.series', options: {setOnBind: true} },
				   			    			{ 'labels': 'models.items.labels', options: {setOnBind: true} },
				   			    			{ 'lines': 'models.items.lines', options: {setOnBind: true} }
				   			    		];
				 this.viewModel._bindData();
			}
			// end backwards compatability 

			
			var highChartsConfig = this.getConfig('highChartsConfig');
			this.origSeriesConfig = highChartsConfig != undefined &&
					(highChartsConfig.series != undefined || 
							highChartsConfig.plotOptions != undefined && highChartsConfig.plotOptions.series != undefined)
							;
			
			
			if(this._getVMData("data.series") !== undefined || this.origSeriesConfig){
				this.render();
			}

		},

		/**
		Prepares configuration options for the *Highcharts* object.

        @method preRender
        @protected
        **/
		_preRender: function(){
			if (this.isChartConfig) {
				return;
			}

			if(!this._getVMData("data.series")) 
				return;
			
			this.graphRoot = this.$el; 
			this.chartType = this.getConfig('chartType');
			if(this.chartType == undefined){
				if (this.getConfig('barDirection') == undefined || this.getConfig('barDirection') == 'vertical'){
					this.barDirection = 'column';
				}else if(this.getConfig('barDirection') == 'horizontal'){
					this.barDirection = 'bar';
				}else{
					throw "bar direction is wrong!";
				}
				this.chartType = this.barDirection;
			}

			this.mySereies = this._getSeries();
			
			var lines = this.getConfig('lines') != undefined ? this.getConfig('lines') : this._getVMData("data.lines");
			for (var i in lines){
				this._addLine(lines[i]);
			};

			this.xAxisShowTicks = this.getConfig('showXAxisLabels');
			this.yAxisShowTicks = this.getConfig('showYAxisLabels');
			this.pointLabelsShow = this.getConfig('showPointLabels');
			this.xAxislineWidth = this.getConfig('xAxislineWidth') != undefined ? this.getConfig('xAxislineWidth') : 1;
			this.yAxislineWidth = this.getConfig('yAxislineWidth') != undefined ? this.getConfig('yAxislineWidth') : 0;
			this.showXAxisLine = this.getConfig('showXAxisLine') != undefined ? this.getConfig('showXAxisLine') : true;
			this.showYAxisLine = this.getConfig('showYAxisLine') != undefined ? this.getConfig('showYAxisLine') : false;
			this.stackingFlag = this.getConfig('stackSeries') ? 'normal' : undefined;
			this.pointLabelStyle = this.getConfig('pointLabelStyle');
			this.axisLabelStyle = this.getConfig('axisLabelStyle');
			this.preventLegendClick = this.getConfig('preventLegendClick') != undefined ? this.getConfig('preventLegendClick') : false;
			
		},
		
		/**
        @private
        **/
		_getSeries : function(){
			
			var series = this._getVMData("data.series");
			var colors = this.getConfig('seriesColors');
			
			var newSeries;

			if(this.graphRoot.attr('data-series-color') != undefined){
				colors = this.graphRoot.attr('data-series-color').split(",");
			}
			var seriesName = this.getConfig('seriesName');
			var myData = [];

			this.barWidth = this.getConfig("barWidth");
			if(this.graphRoot.attr('data-bar-width') != undefined){
				this.barWidth = this.graphRoot.attr('data-bar-width');
			}

			var sliced = this.getConfig("slicedIndex");
			var axisLabels = this._getVMData("data.axisLabels");
			axisLabels = axisLabels ? axisLabels : [];
			if(this.origSeriesConfig == false){
				for(var i = 0; i < series.length; i++){
					var color = this._getColor(colors, i);
					if( $.isArray(series[i])){
						myData.push({ 
							data: series[i], 
							color: color , 
							name: seriesName != undefined ? seriesName[i] : seriesName
						})
					}else{
						myData.push({ 
							y: series[i], 
							color: color,
							name : this.chartType == 'pie' && axisLabels[i] ?  axisLabels[i] : undefined,
							sliced:  this.chartType == 'pie' && i == sliced ? true : false
						})
					}
				}
				if(this.chartType == 'pie'){
					newSeries = [{
							type: 'pie',
							data : myData 
					}]
				}
				else{
					newSeries =  $.isArray(series[0]) ? myData : [{data : myData, name : seriesName != undefined ? seriesName[0] : undefined }];
				}
			}
			return newSeries;
			
		},

		/**
		Creates the actual *Chart* by instantiating the *Highcharts* object with all the comibined configuration
		options.

		@method postRender
		@protected
		**/
		_postRender : function() {
			if (this.isChartConfig) {
				this._createGenericHighchartsChart();
				return;
			}
			
			if(!this._getVMData("data.series")) 
				return;
			
			var selector = this._getElementSelector();

			if(this.chart !== undefined){
				this.chart.destroy();
			}

			var callback = this.getConfig('highchartcallback');
			this.chart = new Highcharts.Chart(this._getHighChartObject(selector), callback);

			var config = this.getConfig('highChartsConfig');
		},

		/**
        @private
        **/
		_getHighChartObject : function(selector){
			var highChartsObj = $.extend(true, {}, this.getConfig('highChartsConfig'));
			if( highChartsObj == undefined){
				highChartsObj = {};
			}
			this._setChartOptions(highChartsObj, selector);
			this._setTitleOptions(highChartsObj);
			this._setLegendOptions(highChartsObj);
			this._setPlotOptions(highChartsObj);
			this._setXAxisOptions(highChartsObj);
			this._setYAxisOptions(highChartsObj);
			this._setSeriesOptions(highChartsObj);
			this._setTooltipOptions(highChartsObj);
			this._setCreditsOptions(highChartsObj);
			return highChartsObj;
		},
		
		/**
        @private
        **/
		_setChartOptions : function(hcObj, selector){
			if(hcObj.chart == undefined){
				hcObj['chart'] = {};
			}
			
			if(hcObj.chart.renderTo == undefined){
				hcObj.chart['renderTo'] = selector;
			}
			
			if(hcObj.chart.type == undefined){
				hcObj.chart['type'] = this.chartType;
			}
			
			if(hcObj.chart.backgroundColor == undefined){
				hcObj.chart['backgroundColor'] = this.getConfig('backgroundColor') == undefined ? null : this.getConfig('backgroundColor');
			}
		},
		
		/**
        @private
        **/
		_setTitleOptions : function(hcObj){
			if(hcObj.title == undefined){
				hcObj['title'] = this.getConfig('title') != undefined ? 
						this.getConfig('title') : {
							text: ''
						}
			}
		},
		
		/**
        @private
        **/
		_setLegendOptions : function(hcObj){
			if(hcObj.legend == undefined){
				hcObj['legend'] = this.getConfig('legend') != undefined ? 
						this.getConfig('legend') : {
							enabled : false
						}
			}
		},
		
		/**
        @private
        **/
		_setPlotOptions : function(hcObj){

			if(hcObj.plotOptions == undefined){
				hcObj['plotOptions'] = this.getConfig('plotOptions') != null ? this.getConfig('plotOptions') : {};
			}
			
			if(hcObj.plotOptions.series == undefined){
				hcObj.plotOptions['series'] = {};
			}else if(this._getVMData("data.series") != undefined){
				hcObj['series'] = undefined;
			}

			if(hcObj.plotOptions.series.events == undefined){
				hcObj.plotOptions.series['events'] = {};
			}

			var self = this;
			
			if(hcObj.plotOptions.column == undefined){
				hcObj.plotOptions.column = {};
			}
			
			
			
			if(hcObj.plotOptions.column.events == undefined){
				hcObj.plotOptions.column.events ={},
				hcObj.plotOptions.column.events['legendItemClick'] = function(e){
					return !self.preventLegendClick;
				}
			}
			
			else{
				if(hcObj.plotOptions.column.events.legendItemClick == undefined){
					hcObj.plotOptions.column.events['legendItemClick'] = function(e){
						return !self.preventLegendClick;
					}
				}
				
			}
			
			if(hcObj.plotOptions.series.events.click == undefined){
				hcObj.plotOptions.series.events['click'] = function(e){
					self.trigger('barChartData:clicked', e, e.currentTarget.index, e.point.x, e.point.y);
				}
			}

			if(hcObj.plotOptions[this.chartType] == undefined){
				hcObj.plotOptions[this.chartType] = {};
			}

			if(hcObj.plotOptions[this.chartType].stacking == undefined){
				hcObj.plotOptions[this.chartType]['stacking'] = this.stackingFlag;
			}			

			if(hcObj.plotOptions[this.chartType].pointWidth == undefined){
				hcObj.plotOptions[this.chartType]['pointWidth'] = this.barWidth;
			}			

			if(hcObj.plotOptions[this.chartType].shadow == undefined){
				hcObj.plotOptions[this.chartType]['shadow'] = this.getConfig("shadow") != undefined ? this.getConfig("shadow") : false;
			}			

			if(hcObj.plotOptions[this.chartType].borderWidth == undefined){
				hcObj.plotOptions[this.chartType]['borderWidth'] = this.getConfig("borderWidth") != undefined ? this.getConfig("borderWidth") : 0;
			}			

			if(hcObj.plotOptions[this.chartType].dataLabels == undefined){
				hcObj.plotOptions[this.chartType]['dataLabels'] = {};
			}

			if(hcObj.plotOptions[this.chartType].dataLabels.enabled == undefined){
				hcObj.plotOptions[this.chartType].dataLabels['enabled'] = this.pointLabelsShow;
			}

			if(hcObj.plotOptions[this.chartType].dataLabels.y == undefined){
				hcObj.plotOptions[this.chartType].dataLabels['y'] = this.dataLabelPositionY;
			}
			
			if(hcObj.plotOptions[this.chartType].showInLegend == undefined){
				hcObj.plotOptions[this.chartType].showInLegend = this.getConfig('legend');
			}

			if(hcObj.plotOptions[this.chartType].dataLabels.formatter == undefined){
				hcObj.plotOptions[this.chartType].dataLabels['formatter'] = this.dataLabelFormatter != null ? this.dataLabelFormatter :
					function(){
					var newStyle = self._getStyle(self.pointLabelStyle, this.point.x);
					if(this.point.y != null){
						if(newStyle != null){
							return '<span style="' + newStyle + '">' + this.point.y + '</span>';
						}
						else return self.labelTmpl({value: this.point.y});
					}
				};
			}

		},
		
		/**
        @private
        **/
		_setXAxisOptions : function(hcObj){
			if(hcObj.xAxis == undefined){
				hcObj['xAxis'] = this.getConfig('xAxis') != null ? this.getConfig('xAxis') : {};
			}
			
			if(hcObj.xAxis.title == undefined){
				hcObj.xAxis['title'] = {};
			}
			
			if(hcObj.xAxis.title.text == undefined){
				hcObj.xAxis.title['text'] = this.getConfig('xAxisTitle');
			}
			
			if(hcObj.xAxis.type == undefined){
				hcObj.xAxis['type'] = this.getConfig('xAxisType');
			}
			
			if(hcObj.xAxis.categories == undefined){
				hcObj.xAxis['categories'] = this._getVMData("data.axisLabels");
			}
			
			if(hcObj.xAxis.labels == undefined){
				hcObj.xAxis['labels'] = {};
			}
			
			if(hcObj.xAxis.labels.rotation == undefined){
				hcObj.xAxis.labels['rotation'] = this.getConfig('xRotation');
			}
				
			if(hcObj.xAxis.labels.enabled == undefined){
				hcObj.xAxis.labels['enabled'] = this.xAxisShowTicks;
			}
				
			var self = this;
			if(hcObj.xAxis.labels.formatter == undefined){
				hcObj.xAxis.labels['formatter'] = this.xAxisLabelFormatter != null ? this.xAxisLabelFormatter :
					function(){
					var count = 0;
					var size = self.viewModel.get('axisLabels') != null ? self.viewModel.get('axisLabels').length : 0;
					if(self.getConfig('xAxisType') != 'datetime'){
						return function() {
							var newStyle = self._getStyle(self.axisLabelStyle, count % size);
							count++;
							if(newStyle != null){
								return '<span style="' + newStyle + '">' + this.value + '</span>';
							}
							else
								return self.xAxisLabelTmpl({value: this.value});
						}
					}
				}()
			}

			if(hcObj.xAxis.stackLabels == undefined){
				hcObj.xAxis['stackLabels'] = {};
			}
				
			if(hcObj.xAxis.stackLabels.enabled == undefined){
				hcObj.xAxis.stackLabels['enabled'] = true;
			}

			if(hcObj.xAxis.plotLines == undefined){
				hcObj.xAxis.stackLabels['plotLines'] = this.plotLinesX;
			}

			if(hcObj.xAxis.lineWidth == undefined){
				hcObj.xAxis.stackLabels['lineWidth'] = this.showXAxisLine ? this.xAxislineWidth : 0;
			}

		},

		/**
        @private
        **/
		_setYAxisOptions : function(hcObj){
			if(hcObj.yAxis == undefined){
				hcObj['yAxis'] = this.getConfig('yAxis') != null ? this.getConfig('yAxis') : {};
			}
			
			if(hcObj.yAxis.title == undefined){
				hcObj.yAxis['title'] = {}; 
			}
			
			if(hcObj.yAxis.title.text == undefined){
				hcObj.yAxis.title['text'] = this.getConfig('yAxisTitle'); 
			}
			
			if(hcObj.yAxis.stackLabels == undefined){
				hcObj.yAxis['stackLabels'] = {}; 
			}
			
			if(hcObj.yAxis.stackLabels.enabled == undefined){
				hcObj.yAxis.stackLabels['enabled'] = true; 
			}
			
			var self = this;
			
			if(hcObj.yAxis.stackLabels.formatter == undefined){
				hcObj.yAxis.stackLabels['formatter'] = (this.dataLabelFormatter != null) ? this.dataLabelFormatter :
					function(){
					var newStyle = self._getStyle(self.pointLabelStyle, this.x);
					var total = this.total;
					if(total != null){
						total = Highcharts.numberFormat(total, 1); 
						if(newStyle != null){
							return '<span style="' + newStyle + '">' + total + '</span>';
						}
						else return self.labelTmpl({value: total});
					}
				} 
			}
			
			if(hcObj.yAxis.gridLineWidth == undefined){
				hcObj.yAxis['gridLineWidth'] = this.getConfig('yGridLineWidth') != undefined ? this.getConfig('yGridLineWidth') : 0; 
			}
			
			if(hcObj.yAxis.labels == undefined){
				hcObj.yAxis['labels'] = {}; 
			}
			

			if(hcObj.yAxis.labels.enabled == undefined){
				hcObj.yAxis.labels['enabled'] = this.yAxisShowTicks; 
			}
			
			if(hcObj.yAxis.labels.rotation == undefined){
				hcObj.yAxis.labels['rotation'] = this.getConfig('yRotation'); 
			}
			
			if(hcObj.yAxis.labels.formatter == undefined){
				hcObj.yAxis.labels['formatter'] = this.yAxisLabelFormatter != null ? this.yAxisLabelFormatter : null; 
			}
			
			if(hcObj.yAxis.plotLines == undefined){
				hcObj.yAxis['plotLines'] = this.plotLinesY; 
			}
			
			if(hcObj.yAxis.lineWidth == undefined){
				hcObj.yAxis['lineWidth'] = this.showYAxisLine ? function(){
					return self.yAxislineWidth == 0 ? 1 : self.yAxislineWidth;
				}() : 0 
			}
			
		},
		
		/**
        @private
        **/
		_setSeriesOptions : function(hcObj){
			if(hcObj.series == undefined){
				hcObj['series'] = this.mySereies;
			}
			
		},
		
		/**
        @private
        **/
		_setTooltipOptions : function(hcObj){
			if(hcObj.tooltip == undefined){
				hcObj['tooltip'] = this.getConfig('tooltip') != undefined ? this.getConfig('tooltip') : {};
			}

			if(hcObj.tooltip.formatter == undefined){
				hcObj.tooltip['formatter'] = function(){return false;
				}
			}
		},
		
		/**
        @private
        **/
		_setCreditsOptions : function(hcObj){
			if(hcObj.credits == undefined){
				hcObj['credits'] = this.getConfig('credits') != undefined ? this.getConfig('credits') : {};
			}
			
			if(hcObj.credits.enabled == undefined){
				hcObj.credits['enabled'] = false;
			}
		},

		/**
        @private
        **/
		_getStyle: function(styleArr, index){
			if(styleArr != null){
				for(var i = 0; i < styleArr.length; i++){
					if(styleArr[i].barIndex == index)
						return styleArr[i].newStyle;
				}
				return null;
			}else 
				return null;
		},

		/**
        @private
        **/
		_addLine : function(line){
			var myLine = {
					value: line.coordinate,
					width: line.width == undefined ? '3' : line.width,
							color: line.color == undefined ? 'black' : line.color ,
									dashStyle: line.lineType != undefined ? 'dash' : line.lineType,
											label : {
												text : line.label == undefined ? "" : line.label.text, 
														style: line.label == undefined ? "" : line.label.style 
											}
			, zIndex : line.zIndex != undefined ? line.zIndex : 1001
			};
			if(line.axis == 'y' || line.axis == undefined){
				this.plotLinesY.push(myLine);
			}else{
				this.plotLinesX.push(myLine);
			}

		},
		
		/**
        @private
        **/
		_getColor: function(colorArr, i){
			var color = null;
			if (colorArr != null && $.isArray(colorArr)){
				if (colorArr.length > 1){
					color = colorArr[i];
				}
				else{
					color = colorArr[0];
				}
			}
			return color;
		},

		/**
		Returns the *Highcharts* object in case it is to be used for UXF-unsupported operations

		@method getChartObject
		@return {Highcharts}  *Highcharts* object
		**/
		getChartObject : function() {
			return this.chart;
		},

		/**
        @private
        **/
		setShowPointLabels: function(show){
			if (this.isChartConfig) {
				throw new Error("Method not supported in SA mode");
			}
			this.pointLabelsShow = show;
		},

		/**
        @private
        **/
		setShowYAxisLabels: function(show){
			if (this.isChartConfig) {
				throw new Error("Method not supported in SA mode");
			}
			this.yAxisShowTicks = show;
		},

		/**
        @private
        **/
		setShowXAxisLabels: function(show){
			if (this.isChartConfig) {
				throw new Error("Method not supported in SA mode");
			}
			this.xAxisShowTicks = show;
		},

		/**
        @private
        **/
		_createGenericHighchartsChart : function () {
			if(!this._getVMData("data.generic")) 
				return;
			
			if(this.chart !== undefined){
				this.chart.destroy();
			}

			var callback = this.getConfig('highchartcallback');
			this.chart = new Highcharts.Chart(this._getGenericHighChartObject(), callback);
		},

		/**
        @private
        **/
		_getGenericHighChartObject : function(){
			var highChartsObj = $.extend(true, {}, this.getConfig('chartConfig'));
			if( typeof highChartsObj === 'undefined'){
				highChartsObj = {};
			}

			highChartsObj = $.extend({}, highChartsObj, this._getVMData("data.generic"));

			if(highChartsObj.chart.renderTo === undefined){
				highChartsObj.chart['renderTo'] = this._getElementSelector();
			}

			return highChartsObj;
		},

		/**
        @private
        **/
		_getElementSelector: function() {
			var selector = this.$el.selector;
			if(!selector) {
				var uniqueSelector = _.uniqueId('chart_');
				this.$el.attr('id', uniqueSelector);
				selector = uniqueSelector;
			}
			if (selector.charAt(0) == "#") {
				selector = selector.substring(1);
			}
			return selector;
		},

		/**
		Cleans up and removes the *ChartView* by calling *Highcharts* corresponding method.

        @method destroy
        **/
        destroy: function() {
            var chartObject = this.getChartObject();
            chartObject && chartObject.destroy();
        }
	});

	return BarChart;

});

/**
 * @class ProxyViewModel
 * @type ViewModel
 * @memberOf Lightsaber.ViewModel
 * @name ProxyViewModel
 * @description
 * Represents a Proxy to (the only) <code>Lightsaber.Core.Model</code> model's data
 * @constructor
 *	@param {Lightsaber.Core.Model} model The model to be exposed by proxy.
 *	@param {Boolean} [config.transactional=false] There are two options to work
 *	with <code>ProxyViewModel</code>, 'transactional' and 'live'. If <code>transactional</code> is set to
 *	<code>true</code>, non of the changes that is being made will apply to the model until the
 *	<code>commit()</code> function is called.
 *	Else, <code>ProxyViewModel</code> is working in live mode, where each change in the model will be directly applied
 *	to the original model.
 *	<em>Note:</em> In any case, you must call <code>save()</code> function in order to save changes to the data-source.
 *	@param {Object} [options] All <code>Lightsaber.Core.ViewModel</code> options.
 *	See <code>Lightsaber.Core.ViewModel</code>'s documentation to get more information.
 *
 * @example
 * var formViewModel = new Lightsaber.ProxyViewModel({
		 model: myCoolModel,
		 config: {
		 	transactional: false //live mode
		 }
	});
 */
define('src/components/proxy/viewmodel/ProxyViewModel',[ 'jquery', 'underscore', 'lightsaber.core' ], function($, _, Lightsaber) {

    var ProxyViewModel = Lightsaber.ViewModel.extend({
        /**
         * @lends Lightsaber.ProxyViewModel.prototype
         */

		/**
		 this event is a called when the view should refresh itself
		@memberOf Lightsaber.ViewModel.ProxyViewModel
		 @name model:refresh
		 @event
		 @function		 
		 */     
		/**
		 this event is a called when there was an error in the CRUD on the model
		@memberOf Lightsaber.ViewModel.ProxyViewModel
		 @name model:error
		 @event
		 @function		 
		 */     
		/**
		 this event is a called when the model was deleted
		 @memberOf Lightsaber.ViewModel.ProxyViewModel
		 @name model:destroy
		 @event
		 @function		 
		 */     

    	
		/**
		 * @property model
		 * @description
		 * The current <code>Lightsaber.Core.Model</code>
		 */
        model: null,

		/**
		 * @property isTransactional
		 * @description
		 * Defines working method: transactional or live.
		 */
		isTransactional: false,

	
        initialize:function(options){
             if(options.model){
                this.model = options.model;
            }
            else{
                throw new Error("model property in options is mandatory!")
            }
			this.isTransactional = this.getConfig('transactional') || this.isTransactional;
			var that = this;
			this.model.on("destroy", function(evt) {
				that.trigger("model:destroy");
			})
			// this.model.on("all", function(evt) { console.log("EVNT: " + evt)});
			this.model.on("error", this._error, this);
			this._setWorkingModel();
       },
		/**
		 * Handles the errors from the model in case the CRUD operations failed.
		 * Triggers "model:error" event.
		 */
		_error : function(model, errorMessage, options) {
	           this.trigger('model:error', errorMessage);
		},

		/**
		 * Get the current value of an attribute from the model.
		 * @param {String} [attribute] The attribute name.
		 * In case <code>attribute</code> is not defined, all the model's attributes are returned.
		 * @return {Object} The value of the given attribute.
		 */
        get: function(attribute){
			return this.workingModel.get(attribute);
        },

		/**
		 * Set a hash of attributes (one or many) on the model.
		 * If any of the attributes change the models state, a <code>change</code> event will be triggered,
		 * unless <code>{silent: true}</code> is passed as an option.
		 * @param {String} key The attribute key name
		 * @param {Object} value The attribute value
		 * @param {Object} [options] error callback and/or event triggering.
		 * @return {*}
		 */
        set: function(key, value, options){
			return this.workingModel.set(key, value, options);
        },

		/**
		 * Remove an attribute by deleting it from the internal attributes hash.
		 * Fires a <code>change</code> event unless <code>silent</code> is passed as an option.
		 * @param {String} attribute The attribute to be removed.
		 * @param {Object} [options=undefined]
		 */
		unset: function(attribute, options){
			return this.workingModel.unset(attribute, options);
		},

		/**
		 * Commit changes that has been made in the model.
		 * Using this function is a <em>MUST</em> when using <code>transactional = true</code>
		 * in order to save changes and later update the data-source.
		 */
		commit: function() {
			if(this.isTransactional){
				this.model.set(this.workingModel.get());
			}
		},

		/**
		 * Commit changes that has been made in the model and save changes in the data-source.
		 * Using this function is a <em>MUST</em> when using <code>transactional = true</code>
		 * @param {Object} [attributes] Specific attributes to save.
		 * @param {Object} [options] <code>success</code> and <code>error</code> callbacks in the options hash,
		 * which are passed <code>(model, response)</code> as arguments.
		 */
		commitAndSave: function(attributes, options) {
			this.commit();
			this.model.save(attributes, options);
		},

        /**
         * Resets the model's state from the data-source.
         * @param {Object} [options] <code>success</code> and <code>error</code> callbacks in the options hash,
         * which are passed <code>(model, response)</code> as arguments.
         */
        fetch: function(options){
           this.model.fetch(options);
        },

        /**
         * Save a model to your database or alternative persistence layer.
         * @param {Object} [attributes] Specific attributes to save.
         * @param {Object} [options] <code>success</code> and <code>error</code> callbacks in the options hash,
         * which are passed <code>(model, response)</code> as arguments.
         */
        save: function(attributes, options){
            this.model.save(attributes, options);
        },

        /****
         * Sets the model back to the last saved model in case of transactional mode.
         * Does nothing for the non transactional mode.
         */
        rollback : function() {
        	this._setWorkingModel();
        	this.trigger("model:refresh");
        },
        
        /**
         * Destroys the model on the data-source
         * @param {Object} [options] <code>success</code> and <code>error</code> callbacks in the options hash,
         * which are passed <code>(model, response)</code> as arguments.
         */
        destroy: function(options){
   			this.workingModel = null;
            this.model.destroy(options);
        },
        /****
         * Sets the model we are actually working on in the form. can either be the input
         * model or a cloned model in case we are transactional.
         */	
        _setWorkingModel : function() {
			if(this.isTransactional){
				this.workingModel = new Lightsaber.Model(this.model.get()) //_.clone(this.model);
			} else {
				this.workingModel = this.model;
			}
       }
    });
    return ProxyViewModel;
});

define('text!src/components/form/view/template/formCollapsible.html',[],function () { return '<fieldset class="uxf-formcollapsible"><legend><b><span data-uxf-point="openFields"></span><%=key%></b></legend>\t\n\t<div id="<%=divId%>" type="<%=type%>">\n\t\t\t\n\t\t\t<div style="display: none" class="collapsible" id="collapse_<%=divId%>">\n\t\t\t\t\t\t\n\t\t\t\t\t<div class="myObject">\n\t\t\t\t\t\t<small><span data-uxf-point="myButtons" ></span></small>\n\t\t\t\t\t\t<table><tbody data-uxf-point="myFields" ></tbody></table>\n\t\t\t\t\t\t<div data-uxf-point="myObjects" ></div>\n\t\t\t\t\t</div>\n\t\t\t</div>\n\t</div>\n</fieldset>\n';});


define('text!src/components/form/view/template/elementTemplate.html',[],function () { return '<tr id="<%=divId%>" key="<%=key%>">\n<td nowrap>\n\t<span data-uxf-point="myButtons" ></span>\n</td>\n<td width="100%">\n\t<div data-uxf-point="myInputElement" ></div>\n</td>\n</tr>';});


define('text!src/components/form/view/template/addNewField.html',[],function () { return '<div class="myAddFieldForm">\n\t<div>\n\t\t<div data-uxf-point="myKeyField" ></div>\n\t\t<div data-uxf-point="myFieldOptions" ></div>\n\t</div>\n\t<div data-uxf-point="mySubmitButton" ></div>\n</div>';});


define('text!src/components/form/view/template/errorMessages.html',[],function () { return '<div data-uxf-point="errorMessage" style="display:none" class="uxf-error LS-error">\n\t<fieldset><label>Error</label>\n\t<div data-uxf-point="errorMessageText" ></div>\n\t</fieldset>\n</div>';});

/**
@memberOf Lightsaber.Web
@name PopupView
@class PopupView
@type View
@description
Dialog view for web, is based on jqueryui dialog.
Additional info <a href="http://jqueryui.com/demos/dialog/" target="_blank">jQueryUi - Dialog page</a>


@constructor 

	@param {ViewModel}  options.viewModel
    View model object for <code>PopupView</code>
	@param {Object} 	[config.buttons={}]
	Specifies which buttons should be displayed on the dialog.<br> Each element of the array must be an Object defining the properties to set on the button.
	@param {String} 	[config.autoShow=true]
	In case set to false, the data will be prepared but the dialog will not open till render method will be called by implementation callback
	@param {String} 	[config.title=""]
	Specifies the title of the dialog. Any valid HTML may be set as the title. The title can also be specified by the title attribute on the dialog source element.
	@param {String} 	[config.closeIcon=undefined]
	In case set to false, close icon is not shown and only text is visible, in case set to css class, this is the icon that will be shown for close in the header
	@param {String} 	[config.closeText=undefined]
	Text that will be shown for close button in the header in case closeIcon is set to false
	@param {String} 	[config.closeTitle=undefined]
	Title that will be shown for close button in the header
	@param {String} 	[config.position="center"]
	Specifies where the dialog should be displayed. Possible values: 
	<br>1) a single string representing position within viewport: 'center', 'left', 'right', 'top', 'bottom'. 
	<br>2) an array containing an x,y coordinate pair in pixel offset from left, top corner of viewport (e.g. [350,100]) 
	<br>3) an array containing x,y position string values (e.g. ['right','top'] for top right corner)..
	@param {Boolean} 	[config.modal=false]
	If set to true, the dialog will have modal behavior; other items on the page will be disabled 
	@param {Boolean} 	[config.closeOnEscape=true]
	Specifies whether the dialog should close when it has focus and the user presses the esacpe (ESC) key.
	@param {Boolean} 	[config.draggable=true]
	If set to true, the dialog will be draggable will be draggable by the titlebar.
	@param {Number} 	[config.height="auto"]
	The height of the dialog, in pixels. Specifying 'auto' is also supported to make the dialog adjust based on its content
	@param {String} 	[config.hide=null]
	The effect to be used when the dialog is closed.
	@param {String} 	[config.show=null]
	The effect to be used when the dialog is opened.	
	@param {Boolean} 	[config.draggable=true]
	If set to true, the dialog will be resizable.
	@param {Boolean} 	[config.draggable=true]
	Specifies whether the dialog will stack on top of other dialogs. This will cause the dialog to move to the front of other dialogs when it gains focus.



	@example
//example for html usage
			var popupView1 =  new Lightsaber.PopupView({
				viewModel : popupViewModel,
				config : {
					//closeIcon : 'ui-icon-clipboard',
					closeIcon : false,
					closeTitle : 'MyTitle',
					closeText : 'MyClose',
					createContent : function()
				    {
				    	return "<ul data-role='listview'><li>Some</li><li>List</li><li>Items</li></ul>";
				    }
				   
				}
			});
		popupView1.render();

		@example
//example for structure passed as parameter 
			var popupView2 =  new Lightsaber.PopupView({
				viewModel : popupViewModel,
				config : {
				    createContent: function()
				    {
				    	return "<form>"+
				    "<fieldset>"+
					"<label for='name'>Name</label>"+
					"<input type='text' name='name' id='name' class='text ui-widget-content ui-corner-all' />"+
					"<label for='emai'>Email</label>"+
					"<input type='text' name='email' id='email' value='' class='text ui-widget-content ui-corner-all' />"+
					"<label for='password'>Password</label>"+
					"<input type='password' name='password' id='password' value='' class='text ui-widget-content ui-corner-all' />"+
					"</fieldset>"+
					"</form>"
				    },
					buttons: {
						Ok: function() {
							$( this ).dialog( "close" );
						}
					}
				}
			});

		@example
		//example for blank mode with widget usage
		var popupView3 =  new Lightsaber.PopupView({
				viewModel : popupViewModel,
				config: {	
					hide: "explode",
					buttons: {
						Ok: function() {
							$( this ).dialog( "close" );
						}
					},
					createContent: function (){ 
						var viewModel = new Lightsaber.ItemListViewModel({
							models : {items : [{"id":"AD", "name":"Andorra2"},{"id":"AE", "name":"United Arab Emirates"},{"id":"AF", "name":"Afghanistan"}]
							},
							config : {
							autoUpdate : true
							}
						});
						

						innerView = new Lightsaber.ItemListView({
							viewModel : viewModel,
							config : {
								sortFieldName : "name"			
							}
						});
						
						return innerView.$el
					}					 
					
				}
			}); 

		popupView3.render();
 */

define('src/components/popup/view/PopupView',[
  'jquery',
  'underscore',
  'lightsaber.core'

  
], function($, _, LightsaberCore) {

         
         var popupView = LightsaberCore.View.extend({
            
            publicMethods : ['close','show'],
        	innerData : "",   	
        	config: {   
        		autoRender:false,
    			autoShow : true,
    			blankContent : "<div id = 'blankContent'></div>"
        	},
        	
    		
            initialize: function() {
                _.bindAll(this, 'render', 'show', 'destroy','close');
                
            },
            
            /**
    		 * Opens the popup view. <br>Method combine configuration
    		 * from view and viewmodel and creates the element per configuration
    		 * <br>In case the data need to load before opening the dialog, set autoShow to false 
    		 * <br> and subscirbe to event that prepares the data with call to show. 
    		 *  
    		 * @methodOf Lightsaber.Web.PopupView  
    		 * @name render
    		 */
            render: function() {
            	var that = this;  
            	this._prepareData();
            	this.innerData.open = function(){
            		that._prepareHeader(this);
            		if(that.getConfig('open'))
            			{
            				that.getConfig('open')(this);
            			}
            	}
            	if(this.getConfig('autoShow'))
            	{
            		this.show();
            	}
            },
            /**
             * This method is creating data before invoking simple dialog
             */
            _prepareData : function()
            {
            	var viewModelData = this.viewModel.get();
            	var viewData = this.getConfig();
             	this.innerData = $.extend({}, viewData, viewModelData); 
             	
             	var createContent = this.getConfig('createContent');
             	if(createContent)
            	{	
             		var createContent = createContent(this);
             		if(createContent)
             			{
             				this.innerData.blankContent = createContent;
             			}
              	}
             	
            },
            /**
             * This method is taking care of header configuration
             */
            _prepareHeader : function(sd)
            {
            	var header = $(sd).parent().children().first();
               	
            	
            	if(this.innerData.closeIcon===false)
        		{
            		header.addClass('dialogui-custom');
        		}
            	if(this.innerData.closeIcon)
            		{
            			$('.ui-icon-closethick',header).addClass(this.innerData.closeIcon);
            		}
            	else {
            		if (this.innerData.closeText)
    	      		{
            			$('.ui-icon',header).text(this.innerData.closeText);
            			if(!this.innerData.closeTitle)
            				{
            					$('.ui-dialog-titlebar-close',header).attr('title',this.innerData.closeText);
            				}
            		}
            	}
            	if(this.innerData.closeTitle)
    			{
    				$('.ui-dialog-titlebar-close',header).attr('title',this.innerData.closeTitle);
    			}
            },
          
            /**
    		 * Should be triggered by envent in case autoShow is set to false, do not call this method otherwise.  
    		 *  
    		 * @methodOf Lightsaber.Web.PopupView  
    		 * @name show
    		 */     
            show : function() {
            	if(this.getConfig('createContent'))
            		{
            			this.$el.html(this.innerData.blankContent);
            		}
            	this.$el.dialog(this.innerData);
            	this.$el.attr('data-loaded', 'true');
            	this.trigger('popup:show');
             },
             
            destroy : function ()
            {
            	if(this.$el.attr('data-loaded') === 'true')
                {
            		this.$el.attr('data-loaded', 'false');
            		this.$el.dialog('destroy');
                }
            },
            
            /**
    		 * Destroys the dialog.  
    		 *  
    		 * @methodOf Lightsaber.Web.PopupView  
    		 * @name close
    		 */ 
            close : function ()
            {
            	if(this.$el.attr('data-loaded') === 'true')
                {
            		this.$el.attr('data-loaded', 'false');
                    var $instance = this.$el.dialog('destroy');
                    $instance.remove();
                }
            }
        });
         
        return popupView;
        
        

});
/**
 * @name BaseFormView
 * @memberOf Lightsaber.Mobile
 * @type View
 * @description The Form View represents a model with the ability to change its
 *              attributes by UI widget such as input texts, drop-downs, date
 *              pickers and etc.
 * @constructor
 * @param {Object}
 *            [options] All the regular options the
 *            <code>Lightsaber.Core.View</code> permits. See
 *            <code>Lightsaber.Core.View</code> documentation to get more
 *            information.
 * @param {Array}
 *            [config.buttons=[]] An array to set the controllers buttons labels
 *            and order. The appearance order of the buttons is set by their
 *            order in the array. Note: The array MUST contain 2-5 buttons only.
 *            Please refer to the following example to see usage.
 * @param {String}
 *            [config.showDeleteButtons=true] Indicator if to show the elements
 *            delete buttons.
 *            [config.showAddButtons=true] Indicator if to show the elements
 *            add fields buttons.
 *            [config.formCollapsibleLabel='label'] formCollapsibleLabel
 * @param {Array} [config.excludeFields=[]] An array with "fieldNames" which needs to
 *	      be excluded from Form Rendering
 * @example
 * 
 * var formView = new Lightsaber.FormView({ el:this.el, insertMethod:'append',
 * viewModel:formViewModel, config: {
 * buttons:[{submit:'Submit'},{fetch:'Fetch'},{delete:'Delete'},{cancel:'Cancel'}] }
 * });
 */
// 
define('src/components/form/view/BaseFormView',[ 'underscore', 'text!./template/formCollapsible.html', 'text!./template/elementTemplate.html', 'text!./template/addNewField.html',
        'text!./template/errorMessages.html', 'lightsaber.core',
        'src/components/forminput/view/InputTextView', 'src/components/forminput/view/CheckboxView', 'src/components/forminput/view/SelectView',
        'src/components/popup/view/PopupView', 'src/components/button/view/ButtonView' ],
        function(_, formCollapsibleTmpl, elementTemplate, addNewFieldTemplate, errorMessageTemplate, Lightsaber, InputTextView,
                CheckboxView, SelectView, PopupView, ButtonView) {
	        var FormView = Lightsaber.View.extend({
	        	publicMethods : ['refresh'],
	            /**
				 * @lends Lightsaber.FormView.prototype
				 */

	            config : {
	                formCollapsibleTemplate : formCollapsibleTmpl,
	                addNewFieldTemplate : addNewFieldTemplate,
	                elementTemplate : elementTemplate,
	                errorMessageTemplate : errorMessageTemplate,
	                showDeleteButtons : true,
	                showAddButtons : true
	            },

	            initialize : function(options) {
		            _.bindAll(this);
		            this.viewModel.on('change:config:enabled', this.onEnableChange);
		            this.viewModel.on('model:refresh', this.refresh);
		            // this.viewModel.on('model:destroy', this.deleted);
		            this.viewModel.on('model:error', this.error);
		            // this.viewModel.on("all", function(evt) {
		            // console.log(evt);
		            // });
		            this.showDeleteButtons = this.getConfig('showDeleteButtons');
		            this.showAddButtons = this.getConfig('showAddButtons');
		            this.formTemplate = _.template(this.getConfig('addNewFieldTemplate'))({});
		            this.errorMessageTemplate = _.template(this.getConfig('errorMessageTemplate') )( {});
		            this.fieldTypes = [ {
		                name : "string",
		                value : "string"
		            }, {
		                name : "number",
		                value : "number"
		            }, {
		                name : "boolean",
		                value : "boolean"
		            }, {
		                name : "array",
		                value : "array"
		            }, {
		                name : "object",
		                value : "object"
		            } ];
			       this.excludeFields = this.getConfig('excludeFields'); //Fields to be excluded from Rendering
			       this.formCollapsibleLabel = this.getConfig('formCollapsibleLabel') || "Fields";
	            },

	            /**
				 * Renders the form view.
				 */
	            render : function() {

		            // creating our root element
		            var rootElement = $("<div></div>");
		            this.placeRoot(rootElement);
		            this.$root.append(this.getConfig("errorMessageTemplate"));
		            // getting the data from the viewMode
		            var formElements = this.viewModel.get();
		            
		            //Exclude Fields
		            formElements = this._handleExcludeFields(formElements);
		            
		            // creating the root fields element
		            this._createCollapsibleElement(rootElement, formElements, this.formCollapsibleLabel, null, "object");
		            // setting the controller buttons
		            this.getConfig('buttons') && this._generateFormControllers(this.getConfig('buttons'));
		            // enabling/disabling the form
		            var enabled = !(this.viewModel.getConfig('enabled'));
		            enabled && this._formEnableChange(this.$root, enabled);
		            // doing stuff after setup by touchpoint
		            this._enhanceMarkup(this.$root);

	            },

	            /**
				 * Updates the form when data changed (usually due to viewModel
				 * event)
				 * 
				 * @param {Event}
				 *            event the event for the refresh
				 */
	            refresh : function(event) {
		            this.$root.empty();
		            this.render();
	            },
	            /**
				 * Updates the form when data changed (usually due to viewModel
				 * event)
				 * 
				 * @param {Event}
				 *            event the event for the refresh
				 */
	            deleted : function(event) {
		            this.$root.empty();
		            // this._formEnableChange(this.$root,false);
		            this.trigger("form:emtpy");
	            },
	            /***************************************************************
				 * Handles error from the proxyviewmodel on the model
				 */
	            error : function(errorMessage) {
		            var myError = errorMessage;
		            if (errorMessage.statusText != null) {
			            myError = errorMessage.statusText;
		            }
		            this.$root.find("[data-uxf-point='errorMessageText']").append(myError + "<br>");
		            this.$root.find("[data-uxf-point='errorMessageText']").focus();
		            this.$root.find("[data-uxf-point='errorMessage']").show();
	            },

	            _clearError : function() {
		            this.$root.find("[data-uxf-point='errorMessage']").hide();
		            this.$root.find("[data-uxf-point='errorMessageText']").empty();
	            },
	            /**
				 * handler for enabled events. Sets enables/disabled on the form
				 * elmements. Note that link typed buttons can not be disable.
				 * 
				 * @param {Event}
				 *            event the event for the refresh
				 */
	            onEnableChange : function(event) {
		            if (this.$root) {
			            this._formEnableChange(this.$root, !event.value);
		            }
	            },

	            /**
				 * Constructs the form controllers and attaches the appropriate
				 * action handlers.
				 * 
				 * @param buttonsArray
				 *            The buttons array, containing each button's label
				 */
	            _generateFormControllers : function(buttonsArray) {
		            var controllers = this._getFormControllerHTMLElement(buttonsArray);
		            for ( var i in buttonsArray) {
			            var button = null;
			            if (buttonsArray[i]['submit']) {
				            button = this._createInputButtonController({
				                label : buttonsArray[i]['submit'],
				                tagType : 'submit',
				                actionHandler : this.submitButtonHandler
				            });
			            } else if (buttonsArray[i]['cancel']) {
				            button = this._createInputButtonController({
				                label : buttonsArray[i]['cancel'],
				                actionHandler : this.cancelButtonHandler
				            });
			            } else if (buttonsArray[i]['fetch']) {
				            button = this._createInputButtonController({
				                label : buttonsArray[i]['fetch'],
				                actionHandler : this.fetchButtonHandler
				            });
			            } else if (buttonsArray[i]['delete']) {
				            button = this._createInputButtonController({
				                label : buttonsArray[i]['delete'],
				                actionHandler : this.deleteButtonHandler
				            });
			            }
			            controllers.append(button.$root);
		            }
		            this.$root.append(controllers);
	            },

	            /**
				 * Creates controller button with given options. This is a hook
				 * function and can be overridden.
				 * 
				 * @param {String}[options.label:undefined]
				 *            The text to be labeled on the button.
				 * @param {String}[options.tagType:button]
				 *            The type of the input button. Possible values:
				 *            <code>button</code>,<code>submit</code>.
				 * @param {Function}[options.actionHandler:undefined]
				 *            The action handler of the button's click event.
				 * @returns {Lightsaber.ButtonView} The generated button's view.
				 */
	            _createInputButtonController : function(options) {
		            var label = options && options.label;
		            var tagType = (options && options.tagType) || 'button';
		            var actionHandler = options && options.actionHandler;
		            return new ButtonView({
		                viewModel : new Lightsaber.ViewModel({
		                    data : {
			                    label : label
		                    },
		                    config : {
			                    actions : {
				                    click : actionHandler
			                    }
		                    }
		                }),
		                config : {
		                    tagName : 'input',
		                    tagType : tagType,
		                    wrapper : this._getButtonWrapper()
		                }
		            });
	            },

	            /***************************************************************
				 * Initialized the form for the add field/ add value for null
				 * form. We are using databinding so that the form will update
				 * the model and we do not need references to our form in order
				 * to retrieve the data
				 */
	            _initializeFieldOptionsForm : function(formModel) {
		            var form = $(this.formTemplate);
		            // add the key inputfield
		            var isKeyVisible = (formModel.get("method") == "create");
		            var fieldKey = new InputTextView({
		                viewModel : new Lightsaber.ViewModel({
		                    data : {
			                    label : "Key: "
		                    },
		                    models : {
			                    textModel : formModel
		                    },
		                    dataBindings : [ {
		                        'fieldValue' : 'models.textModel.key',
		                        options : {
		                            setOnBind : true,
		                            twoWay : true
		                        }
		                    } ],
		                    config : {
			                    visible : isKeyVisible
		                    }
		                }),
		                el : form.find("[data-uxf-point='myKeyField']")
		            });
		            // add the select for the type
		            var selectViewModel = new Lightsaber.ViewModel({
		                data : {
			                label : "Type: "
		                },
		                models : {
		                    items : this.fieldTypes,
		                    textModel : formModel
		                },
		                config : {
			                optionsModelName : "items"
		                },
		                dataBindings : [ {
		                    'fieldValue' : 'models.textModel.fieldType',
		                    options : {
		                        setOnBind : true,
		                        twoWay : true
		                    }
		                } ]
		            });
		            var fieldType = new SelectView({
		                viewModel : selectViewModel,
		                el : form.find("[data-uxf-point='myFieldOptions']")
		            });
		            var button = this._createInputButtonController({
		                label : "Create",
		                actionHandler : this._createFieldHandler
		            });
		            button.$root.attr("rel", "close");// this will cause popup to close
		            form.find("[data-uxf-point='mySubmitButton']").append(button.$root);
		            return form;
	            },

	            /**
				 * Creates form elements out of the model items, based on the
				 * model item type (string, boolean, number, array or object).
				 * 
				 * @param {Object}
				 *            rootElement root element to which to append the
				 *            created form element
				 * @param {Object}
				 *            elements Current model item being handled.
				 * @param {String}
				 *           namespace/id for new element
				 * @param {Object}
				 *            in case we are changing a null value to a type. this will appear in this spot.
				 * 
				 */
	            _createModelMembers : function(rootElement, elements, namespace, replaceElement) {
		            // for every element in our form create its keys and values
					// html elements.
		            var fieldsElement = rootElement.find("[data-uxf-point='myFields']").first();
		            var objectsElement = rootElement.find("[data-uxf-point='myObjects']").first();
		            for ( var elem in elements) {
			            var newNameSpace;
			            if (namespace != null) {
				            newNameSpace = namespace + "." + elem;
			            } else {
				            newNameSpace = elem;
			            }
			            // create input text incase value is string, number or
						// boolean or null
			            if (elements[elem] == null) {
				            this._createInputTextElement(fieldsElement, elements[elem], elem, null, newNameSpace, replaceElement);
			            } else if (typeof elements[elem] == "string") {
				            this._createInputTextElement(fieldsElement, elements[elem], elem, "string", newNameSpace, replaceElement);
			            } else if (typeof elements[elem] == "number") {
				            this._createInputTextElement(fieldsElement, elements[elem], elem, "number", newNameSpace, replaceElement);
			            } else if (typeof elements[elem] == "boolean") {
				            this._createInputTextElement(fieldsElement, elements[elem], elem, "checkbox", newNameSpace, replaceElement);
			            }
			            // create collapsible element, in case value is an
						// object or array
			            else if (typeof elements[elem] == "object") {
				            if (Array.isArray(elements[elem])) {
					            // this is an object
					            // this is an array. we will create the header
								// and then loop through the elements
					            var arrayHeaderElem = this._createCollapsibleElement(objectsElement, {}, elem, newNameSpace, "array");
					            arrayHeaderElem = arrayHeaderElem.find("[data-uxf-point='myObjects']").first();
					            for ( var i = 0; i < elements[elem].length; i++) {
						            this._createArrayElement(arrayHeaderElem, elements[elem][i], newNameSpace, i);
					            }
				            } else {
					            this._createCollapsibleElement(objectsElement, elements[elem], elem, newNameSpace, "object", replaceElement)
				            }
			            }
		            }
	            },
	            /***************************************************************
				 * Creates an item in the array element.
				 */
	            _createArrayElement : function(root, element, namespace, index) {
		            var itemNameSpace = namespace + "." + index;
		            var arrayEntryElem = this._createCollapsibleElement(root, {}, "Item " + (index + 1), itemNameSpace, "object");
		            this._createModelMembers(arrayEntryElem, element, itemNameSpace);

	            },

	            /**
				 * Creates a collapsible element. Used for model items of type
				 * objects and arrays. Creates recursively the object's items.
				 * 
				 * @param {Object}
				 *            valueObject the object for which to create a
				 *            collapsible element.
				 * @param {String}
				 *            key the key (name) of the presented object.Will be
				 *            set as the collapsible label.
				 */
	            _createCollapsibleElement : function(root, valueObject, key, namespace, type, replaceElement) {
		            var divId = (namespace) ? this._makeNamespaceIntoID(namespace) : "MAIN";
		            var isMain = (namespace) ? "" : "MAIN";
		            var collapsibleTemplate = _.template(this.getConfig('formCollapsibleTemplate'))( {
		                key : key,
		                divId : divId,
		                type : type,
		                isMain : isMain
		            });
		            // in case we changed the type, we will have to remove it to add it to the objects section
		            if (replaceElement) {
		            	replaceElement.remove();
		            }
		            var myobject = $(collapsibleTemplate).appendTo(root);
		            // at the side of each element set a delete button to enable
					// deletion of the element.
		            this._showFieldButtons(myobject, namespace, key, type, true);
		            // collapsing through our children
		            this._createModelMembers(myobject, valueObject, namespace);
		            return myobject;
	            },
	            /***************************************************************
				 * Adds the delete and add buttons for the fields and objects
				 */
	            _showFieldButtons : function(myobject, namespace, key, type, showWithText) {
		            if (namespace != null && this.showDeleteButtons) {
			            var deleteText = (showWithText) ? "Delete" : null;
			            this._createButton('Delete this field', this.deleteElementHandler, myobject.find("[data-uxf-point='myButtons']"), namespace, 'delete', deleteText);
		            }
		            if (this.showAddButtons && (type == "object" || type == "array")) {
			            var addText = (showWithText) ? "Add Field" : null;
			            this._createButton('Add a field', this._addElementHandler, myobject.find("[data-uxf-point='myButtons']"), namespace, 'plus', addText);
		            }
		            if (type == null) {
			            var createText = (showWithText) ? "Create" : null;
			            this._createButton('Create value', this._addValueElementHandler, myobject.find("[data-uxf-point='myButtons']"), namespace, 'arrow-r', createText);
		            }
		            this._addMoreFieldButtons(myobject, namespace, key, type, showWithText);
	            },

	            /**
				 * Creates a input text type element. Used for model items of
				 * types strings, boolean and numbers.
				 * 
				 * @param {Object}
				 *            root the element to which to append the created
				 *            input text element
				 * @param {String}
				 *            value the value of the element
				 * @param {String}
				 *            key the key of the element
				 * @param {String}
				 *            [type=text] if populated, defines the type of the
				 *            input text element (like checkbox or number)
				 * @param {String}
				 *            [template=formInputTextTemplate] if populated,
				 *            defines alternative template for the input text
				 *            element
				 * 
				 */
	            _createInputTextElement : function(root, value, key, type, namespace, replaceElement) {
		            var inputViewModel = new Lightsaber.ViewModel({
		                data : {
		                    label : key,
		                    fieldValue : value
		                },
		                config : {
			                enabled : (type != null)
		                }
		            });
		            var myelem = null;
		            // checking whether we are replacing a current field or adding a new one.
		            if (replaceElement) {
		            	replaceElement.find('[data-uxf-point="myInputElement"]').empty();
		            	replaceElement.find('[data-uxf-point="myButtons"]').empty();
		            	myelem = replaceElement;
		            } else {
			            myelem = _.template(this.getConfig('elementTemplate'))( {
			                key : key,
			                divId : this._makeNamespaceIntoID(namespace)
			            });
			            myelem = $(myelem).appendTo(root);		            	
		            }
		            var inputView = null;
		            var inputType = (type == null || type == "string") ? "text" : type;
		            var inputObj = {
		                viewModel : inputViewModel,
		                attributes : {
			                'data-namespace' : namespace
		                },
		                config : {
		                    inputAttributes : {
		                        'data-namespace' : namespace,
		                        type : inputType
		                    },
		                    isMinimalTemplate : true
		                }
		            };
		            // creating the correct UI element
		            if (type == "checkbox") {
			            inputObj.config.falseValue = "false";
			            inputView = new CheckboxView(inputObj);
			            var state = value;
			            if (typeof value != "boolean") {
			            	state = value === "checked" ? true : false;
			            }
			            
			            inputView.$root.find("input").prop("checked", state);
		            } else {
			            inputView = new InputTextView(inputObj);
		            }
		            // registering to events
		            inputView.on('keyboard', this._onKeyboard);
		            inputView.on('changed:value', this._changed);
		            // create delete/add type element button to be appended to
					// our input text element
		            this._showFieldButtons(myelem, namespace, key, type, false);
		            myelem.find("[data-uxf-point='myInputElement']").last().append(inputView.$el);		            			            	
		            return inputView;
	            },

	            /**
				 * Handler for change events. Updates the form element (set the
				 * model) with the change the user made to the element.
				 * 
				 * @param {Event}
				 *            evt the change event
				 */
	            _changed : function(context) {
		            // get the namespace of the changed element.
		            var key = context.event.target.getAttribute('data-namespace');
		            // get the changed value
		            var changedValue = context.value;
		            // update the changed value to the elment and model
		            this._updateFormElements('change', key, changedValue);
		            context.event.preventDefault();
		            context.event.stopImmediatePropagation();
	            },

	            /**
				 * Go over the form elemenets recursively to disable/enable
				 * each.
				 * 
				 * @param {Object}
				 *            formElement the element to disable/enable
				 * @param {boolean}
				 *            disabled indicate if the element should be
				 *            disabled or enabled
				 */
	            _formEnableChange : function(formElement, disabled) {
		            _.each(formElement.children(), function(element) {
			            element = $(element);
			            element.prop('disabled', disabled);
			            !disabled && element.removeClass('ui-disabled');
			            this._formEnableChange(element, disabled);
		            }, this);
	            },

	            /**
				 * Handler for the submit button. Saves the model's new data as
				 * changes in the form. This is a hook function and can be
				 * overridden.
				 */
	            submitButtonHandler : function() {
		            this._clearError();
		            // this._formEnableChange(this.$root,true);
		            var that = this;
		            this.viewModel.commitAndSave({
		                success : function() {
			                that._formEnableChange(this.$root, false);
		                },
		                error : function(model, response) {
			                that.error(response.statusText);
		                }

		            });
	            },

	            /**
				 * Handler for the fetch button. retrieves the model's data from
				 * the data source. This is a hook function and can be
				 * overridden.
				 */
	            fetchButtonHandler : function() {
		            this._clearError();
		            var that = this;
		            // this._formEnableChange(this.$root,true);
		            this.viewModel.fetch({
			            success : function(response) {
				            // refreshing the working model and sending event to
							// view
				            that.viewModel._setWorkingModel();
				            that.refresh();
			            }
		            });
	            },

	            /**
				 * Handler for the delete button. Deletes the model from the
				 * data source. This is a hook function and can be overridden.
				 */
	            deleteButtonHandler : function() {
		            // this._formEnableChange(this.$root,true);
		            this._clearError();
		            var that = this;
		            this.viewModel.destroy({
		                success : function(response) {
			                that.deleted();
		                },
		                error : function(model, response) {
			                that.error(response.statusText);
		                }
		            });
	            },

	            /**
				 * Handler for the cancel button. This is a hook function and
				 * can be overridden.
				 */
	            cancelButtonHandler : function() {
		            // this._formEnableChange(this.$root,true);
		            this._clearError();
		            this.viewModel.rollback();
	            },

	            /**
				 * Handler for deleting an element. Deletes the appropriate
				 * field in the model. This is a hook function and can be
				 * overridden.
				 */
	            deleteElementHandler : function(event) {
		            var key = event.target.getAttribute('data-namespace');
		            this._updateFormElements('delete', key);
		            var deleteField = $.find("#" + this._makeNamespaceIntoID(key))
		            $(deleteField).empty();
		            event.preventDefault();
		            event.stopImmediatePropagation();
	            },

	            /**
				 * Handler for adding an element can be of all types.
				 */
	            _addElementHandler : function(event) {
		            var namespace = $(event.srcElement).attr("data-namespace");
		            var rootElement = null;
		            if (namespace != null) {
			            var rootElement = $("#" + this._makeNamespaceIntoID(namespace));
		            } else {
			            var rootElement = $("#MAIN");
		            }
		            if (rootElement.attr("type") == "array") {
			            // for the array, we can already create the object
		            	this._initNewValueModel(namespace, "create", null);
			            this._createFieldHandler();
		            } else {
			            this._openPopupForm("create", namespace, null);
		            }

	            },

	            /***
	             * Creates input model for the form for creating new values
	             */
	            _initNewValueModel : function(namespace, method, key, fieldType) {
	            	if (!fieldType) fieldType = "string";
	            	this.newValueModel = new Lightsaber.Model({
	    		        namespace : namespace,
	    		        method : method,
	    		        key : key,
	    		        fieldType : fieldType
	    		    });
	            	return this.newValueModel;
	            },
	            
	            /***************************************************************
				 * Creates the popup for changing the type of a null field
				 */
	            _addValueElementHandler : function(event) {
		            var namespace = $(event.srcElement).attr("data-namespace");
		            var rootElement = $("#" + this._makeNamespaceIntoID(namespace));
		            if (namespace.indexOf(".") < 0) {
			            namespace = null;
		            } else {
			            namespace = namespace.substring(0, namespace.lastIndexof("."));
		            }
		            this._openPopupForm("change", namespace, rootElement.attr("key"));
	            },
	            /**
				 * Handler for adding an element can be of all types.
				 */
	            _createFieldHandler : function(event) {
		            this._closePopup();
		            var namespace = this.newValueModel.get("namespace");
		            var method = this.newValueModel.get("method");
		            var keyName = this.newValueModel.get("key");
		            var type = this.newValueModel.get("fieldType");

		            var newNamespace = (namespace) ? namespace + "." + keyName : keyName;
		            // getting the initial value for the field.
		            var changedValue = "";
		            if (type == "boolean") {
			            changedValue = true;
		            } else if (type == "number") {
			            changedValue = 0;
		            } else if (type == "object") {
			            changedValue = {};
		            } else if (type == "array") {
			            changedValue = [""];
		            }
		            // adding to the model
		            var workingItem = this._updateFormElements(method, newNamespace, changedValue);
		            // continuing for the UIm getting the root element for adding an element to the form according to the namespace
		            var fieldElement = null;
		            var replaceElement = null;
		            if (method == "change") {
			            // removing the current field and replacing it now that we know what we will have
			            fieldElement = $("#" + this._makeNamespaceIntoID(newNamespace));
			            var containerElement = fieldElement.parentsUntil(".myObject").parent();
			            replaceElement = fieldElement;
			            fieldElement = containerElement;
		            } else {
			            if (namespace != null) {
				            fieldElement = $("#" + this._makeNamespaceIntoID(namespace));
			            } else {
				            fieldElement = $("#MAIN");
			            }
		            }
		            var type = fieldElement.attr("type");
		            if (type && type == "array") {
			            this._createArrayElement(fieldElement.find("[data-uxf-point='myObjects']").first(), {}, namespace, workingItem.length - 1);
		            } else {
			            // setting the input element to create the new element in the form
			            var inputElements = {};
			            inputElements[keyName] = changedValue;
			            // adding to the element
			            this._createModelMembers(fieldElement, inputElements, namespace, replaceElement);
		            }
		            // additional touchpint UI	            		
		            this._enhanceMarkup(fieldElement);
	            },
	            /***
	             * Turns the namespace into a jquery ID so that we can quickly search for the element
	             */
	            _makeNamespaceIntoID : function(namespace) {
		            var id = namespace.replace(/ /g, "_");
		            id = id.replace(/\./g, "_");
		            return id;
	            },

	            /**
	             * Handler for keyboard events. Used to catch enter events to be handled by the change events. 
	             * @param {Object} context event context 
	             * @param {Event} event the on keyboard event
	             * @private
	             */
	            _onKeyboard : function(context) {
		            if (context.event.keyCode == 13) { // enter key
			            context.event.preventDefault();
			            context.event.stopImmediatePropagation();
			            this._changed(context);
		            }
	            },

	            /**
	             * Updates form element after change or delete. 
	             * @param {String} method indicats if the update is due to change or delete
	             * @param {String} key the key namespace of the updated element
	             * @param {String} [changedValue] the changed value, in case method used is "change"
	             */
	            _updateFormElements : function(method, key, changedValue) {
		            if (key) {
			            var formElements = this.viewModel.get();
			            var items = key.split('.');
			            var initialItem = formElements[items[0]];
			            //updated item is a main object in our formElements
			            if (items.length == 1) {
				            if (method == 'delete') {
					            delete formElements[items[0]];
					            this.viewModel.unset(items[0]);
				            } else if (method == 'change') {
					            formElements[items[0]] = changedValue
					            this.viewModel.set(items[0], changedValue)
				            } else if (method == 'create') {
					            this.viewModel.set(key, changedValue);
				            }
				            return this.viewModel;
			            } else { //updated item is a nested item in our formElements
				            var currItem = formElements[items[0]];
				            //nested inside our main object till we get to our changed element
				            for ( var index = 1; index < items.length - 1; index++) {
					            currItem = currItem[items[index]];
				            }
				            var keyTarget = items[items.length - 1];
				            if (method != "create") {
					            method == 'delete' ? (delete currItem[keyTarget]) : (currItem[keyTarget] = changedValue);
				            } else {
					            if (currItem.length) {
						            // adding object to an array
						            currItem[currItem.length] = changedValue;
					            } else {
						            currItem[keyTarget] = changedValue;
					            }
				            }
				            this.viewModel.set(items[0], initialItem);
				            return currItem;
			            }
		            }
	            },

	            /**
	             * Exclude Fields from Rendering
	             */
	            _handleExcludeFields : function(formElements){
	            	var copy = {};
	            	if(typeof this.excludeFields == "object") {
			            if (Array.isArray(this.excludeFields)) {			            	
				            var keys = _.keys(formElements);
				            for(var key in keys){
				            	  elemKey = keys[key];
				            	  if(_.indexOf(this.excludeFields,elemKey) == -1){
				            		  copy[elemKey] = formElements[elemKey];
				            	  }
				            }				            
			            }
	            	}	     
	            	if(!_.isEmpty(copy)){
	            		return copy;
	            	}else{
	            		return formElements;
	            	}	            	
	            },
	            
	            /**************************************************************
	             * T O U C H P O I N T   S P E C I F I C   M E T H O D S 
	             **************************************************************/
	            /**
	             * Creates the button markup.This is a hook function. If necessary, 
	             * it should be overriden per touch point logic.
	             */
	            _enhanceMarkup : function(element) {
	            },
	            /***
	             * Wrapper for the buttons that appear in the form for mobile
	             */
	            _getButtonWrapper : function() {
		            return 'div"';
	            },
	            /****
	             * Sets the div around the form controller buttons at the bottom. depends
	             * on the number of buttons
	             */
	            _getFormControllerHTMLElement : function(buttonsArray) {
		            var controllers = $('<div>');
		            return controllers;
	            },
	            /****
	             * Use to add additional buttons on elements
	             */
	            _addMoreFieldButtons : function(myobject, namespace,key, type, showWithText) {
		            //
	            },

	            /***
	             * creates a button
	             */
	            _createButton : function(label, clickHandler, el, namespace, buttonIcon, buttonText) {

	            },

	            /****
	             * Creates the popup form for choosing the type (and key for a new) field
	             */
	            _openPopupForm : function(method, namespace, key) {
	            },

	            _closePopup : function() {

	            }
	        });

	        return FormView;
        });
/**
 * @name FormView
 * @memberOf Lightsaber.Web
 * @description The Form View represents a model with the ability to change its
 *              attributes by UI widget such as input texts, drop-downs, date
 *              pickers and etc.
 * @constructor
 * @param {Object}
 *            [options] All the regular options the
 *            <code>Lightsaber.Core.View</code> permits. See
 *            <code>Lightsaber.Core.View</code> documentation to get more
 *            information.
 * @param {Array}
 *            [config.buttons=[]] An array to set the controllers buttons labels
 *            and order. The appearance order of the buttons is set by their
 *            order in the array. Note: The array MUST contain 2-5 buttons only.
 *            Please refer to the following example to see usage.
 * @param {String}
 *            [config.showDeleteButtons=true] Indicator if to show the elements
 *            delete buttons.
 *            [config.formCollapsibleLabel='label'] formCollapsibleLabel
 * @example
 * 
 * var formView = new Lightsaber.FormView({ el:this.el, insertMethod:'append',
 * viewModel:formViewModel, config: {
 * buttons:[{submit:'Submit'},{fetch:'Fetch'},{delete:'Delete'},{cancel:'Cancel'}] }
 * });
 */
// 
define('src/components/form/view/FormView',[ 'underscore', 'text!./template/formCollapsible.html', 'text!./template/elementTemplate.html', 'text!./template/addNewField.html',
        'text!./template/errorMessages.html', 'lightsaber.core', 
        'src/components/forminput/view/InputTextView', 'src/components/forminput/view/CheckboxView', 'src/components/forminput/view/SelectView',
        'src/components/popup/view/PopupView', 'src/components/button/view/ButtonView',
        'src/components/form/view/BaseFormView' ], function(_, formCollapsibleTmpl, elementTemplate, addNewFieldTemplate, errorMessageTemplate,
        Lightsaber, InputTextView, CheckboxView, SelectView, PopupView, ButtonView, BaseFormView) {

	var WebFormView = BaseFormView.extend({

	    /***********************************************************************
		 * T O U C H P O I N T S P E C I F I C M E T H O D S
		 **********************************************************************/
	    /***********************************************************************
		 * Wrapper for the buttons that appear in the form for mobile
		 */
	    _getButtonWrapper : function() {
		    return 'div style="float:left"';
	    },
	    /***********************************************************************
		 * Sets the div around the form controller buttons at the bottom.
		 * depends on the number of buttons
		 */
	    _getFormControllerHTMLElement : function(buttonsArray) {
		    var controllers = $('<div>');
		    return controllers;
	    },
	    /***********************************************************************
		 * Adds the toggle on the collapsible elements
		 */
	    _addMoreFieldButtons : function(myobject, namespace, key, type, showWithText) {
		    if (type == "object" || type == "array") {
			    var addText = (showWithText) ? "Open Elements" : null;
			    this._createButton('Open Fields', this._openElementHandler, myobject.find("[data-uxf-point='openFields']"), namespace, 'arrow-r', null);
		    }
	    },
	    /***********************************************************************
		 * Handles the toggle of the collapsible elements
		 */
	    _openElementHandler : function(evt) {
		    var divId = $(evt.srcElement).closest("[divId]").attr("divId");
		    var collapseDiv = this.$root.find("#collapse_" + divId);
		    collapseDiv.toggle();
		    var isVisible = (collapseDiv.is(":visible"));
		    $(evt.srcElement).prev().removeClass("ui-icon-circle-triangle-s");
		    $(evt.srcElement).prev().removeClass("ui-icon-circle-triangle-e");
		    if (isVisible) {
			    $(evt.srcElement).prev().addClass("ui-icon-circle-triangle-s");
		    } else {
			    $(evt.srcElement).prev().addClass("ui-icon-circle-triangle-e");
		    }
	    },
	    // creating web button
	    _createButton : function(label, clickHandler, el, namespace, buttonIcon, buttonText) {

		    if (el.length == 0)
			    return;
		    // replacing jquery mobile button with jquery ui buttons
		    if (buttonIcon == "delete") {
			    label = null;
			    buttonIcon = "ui-icon-circle-close"
		    } else if (buttonIcon == "plus") {
			    label = null;
			    buttonIcon = "ui-icon-circle-plus"
		    } else if (buttonIcon == "arrow-r") {
			    label = null;
			    buttonIcon = "ui-icon-circle-triangle-e"
		    }

		    var myButtonEl = $("<span></span>").appendTo(el);
		    var viewModelInput = {
		        data : {label : label},
		        config : {
			        actions : { click : clickHandler}
		        }
		    };
		    var divId = (namespace) ? this._makeNamespaceIntoID(namespace) : "MAIN";
		    var buttonAttributes = {divId : divId, tagName : 'a', wrapper : 'span'};

		    if (buttonIcon) {
			    buttonAttributes["icons"] = {primary : buttonIcon}
		    }
		    if (buttonText) {
			    viewModelInput.data.label = buttonText;
		    }
		    var bView = new ButtonView({
		        viewModel : new Lightsaber.ViewModel(viewModelInput),
		        config : buttonAttributes,
		        el : myButtonEl,
		        insertMethod : 'append'
		    });
		    bView.$root.attr("divId", divId);
		    bView.$root.find("span").attr("data-namespace", namespace);
		    return bView;
	    },

	    // removing the toggle for the main item
	    _enhanceMarkup : function() {
		    var mainDiv = this.$root.find("#collapse_MAIN");
		    if (mainDiv && mainDiv.length && !mainDiv.is(":visible")) {
			    // opening up the fields on the main node
			    this.$root.find("#collapse_MAIN").show();
			    // not showing the collapsible button
			    this.$root.find("[divId='MAIN']").first("button").hide()
		    }
	    },
	    /***********************************************************************
		 * Creates the popup form for choosing the type (and key for a new)
		 * field
		 */
	    _openPopupForm : function(method, namespace, key) {
		    // initializing the popup view
		    var that = this;
		    var model = this._initNewValueModel(namespace, method, key);
		    this.popupView = new PopupView({
		        viewModel : new Lightsaber.ViewModel(),
		        config : {
		            headerText : "Add Field",
		            createContent : function() {
			            $('#blankContent').empty();
			            var myForm = that._initializeFieldOptionsForm(model);
			            $('#blankContent').append(myForm);
			            that._enhanceMarkup($('#blankContent'));
			            return myForm;
		            }
		        }
		    });
		    this.popupView.render();

	    },
	    /***
	     * Closes the web popup.
	     */
	    _closePopup : function() {
	    	if (this.popupView && this.popupView.close) {
			    this.popupView.close();	    		
	    	}
	    }
	});

	return WebFormView;
});

define('text!src/components/carousel/view/template/carousel.html',[],function () { return '<div class="uxf-carousel carousel" style="overflow: hidden;">\n\t<ul data-role="carousel" class="carousel_container">\n\t</ul>\n</div>';});


define('text!src/components/carousel/view/template/carouselItem.html',[],function () { return '<div>\n</div>';});

/**
@class CarouselView
@type View
@memberOf Lightsaber.Mobile
@name CarouselView

@description
View to show the carousel widget.

@example 1 Carousel is created with item list view model


		var model = new Lightsaber.Core.Collection();
		model.url = 'vasia/vasia';


		var carouselViewModel = new Lightsaber.CollectionViewModel({
			models : {
				items : model
			}

		});

		var myCarousel = new Lightsaber.CarouselView({
			el : '#carousel',
			viewModel : carouselViewModel,
			config: {  
				direction : 'horizontal',
				cyclic : 'true',
				itemsdisplayed : '4',
				itemsstep : '2',
				itemsindicator : 'true',
				animationstatus : 'on',
				animationduration : '6000',
				layout : '3d',
				rootClass : '',
				templateItem : itemtemplate
			}
		});
			
		model.fetch({
		});


@example 2 Carousel is created by adding views


			var myCarousel = new Lightsaber.CarouselView({
				el : '#carousel1',
				viewModel : carouselViewModel,
				config: {  
							direction : 'horizontal',
							cyclic : 'true',
							itemsdisplayed : '4',
							itemsstep : '2',
							itemsindicator : 'true',
							animationstatus : 'on',
							animationduration : '6000',
							layout : '2d'
				}
			}); 
			var myItems = [
			      "item1", "item2"
			];
			
			myItems[myItems.length] = '<div id="graph" style="width: 200px; z-index: 1001;"></div>';
			myItems[myItems.length] = '<div class="package_item_title">Data</div>' + 
	          '<div class="package_item_details"><img src="http://amx.dev.volasent.com/R9/trunk/Web/Content/images/temp/package_graph3.png" alt="" /></div>' +
	          '<div class="package_item_desc">500 MB</div>' +
	          '<div class="package_item_price"><strong>$41.85</strong>/mo.</div>';
			  
			myCarousel.addHtmlElements(myItems);
			
			var model = new Lightsaber.Core.Model();
			model.set('series', [40, 50, 90]);
			model.set('axisLabels', ["Oct", "Nov", "Dec"]);		

			var barChartViewModel = new Lightsaber.BarChartViewModel({
				models : {
					items : model
				}
			});
	
			this.barChartView = new Lightsaber.BarChartView({
				el : 'graph',
				viewModel : barChartViewModel,
	
				config : {
					barDirection: 'vertical',
					showPointLabels: true,
					showYAxisLabels: false,
					drawGridlines: false,
					barWidth: 10
				}
			});
			
			
@example 3

			<div class="ui-grid-a">
				<div  class="ui-block-a">
					<input id="prev-button1" name="prev" type="button" value="prev">
				</div>
				<div class="ui-block-b">
					<input id="next-button1" name="next" type="button" value="next">
				</div>
			</div>
			<div id="carousel2"></div>
			
			
		var myCarousel22 = new Lightsaber.CarouselView({
			el : '#carousel2',
			viewModel : carouselViewModel,
			config: {  
						direction : 'horizontal',
						cyclic : 'false',
						itemsdisplayed : '1',
						itemsstep : '1',
						itemsindicator : 'true',
						//animationstatus : 'on',
						//animationduration : '6000',
						layout : '2d'
			}
		}); 
		
		//modelInternal.fetch({});
		
		myCarousel22.addHtmlElement('Carousel Item 1');
		myCarousel22.addHtmlElement('Carousel Item 2');
		myCarousel22.addHtmlElement('Carousel Item 3');
		
		
		myCarousel22.on('Carousel:prevEvent', function (e) {
			$('#prev-button1').button(e.hasMore?'enable':'disable'); 
		});

		myCarousel22.on('Carousel:nextEvent', function (e) {
			$('#next-button1').button(e.hasMore?'enable':'disable'); 
		});
		
		$('#next-button1').on('click', function() {
			myCarousel22.nextItem();
		});

		$('#prev-button1').on('click', function() {
			myCarousel22.previousItem();
		});			



@constructor 

@memberOf Lightsaber.Mobile.CarouselView
	@param Object 		[Lightsaber.CollectionViewModel]	Model with the data for the carousel items
	@param {String} 	[config.direction='vertical']		The bar direction['vertical' or 'horizontal']
	@param {boolean} 	[config.cyclic]						Indicates whether the carousel is cyclic 
															or has a next/previous boundary
	@param {number} 	[config.itemsdisplayed=3]			items number displayed on the page, default 3 
	@param {number} 	[config.outmargin]					this param specifies a margin that will reduce 
															the carousel view port in order to see if there 
															is more items on the left/right. It is a size in 
															pixelIt is usefull if there is no itemindicators. 
	@param {boolean} 	[config.itemsstep]					amount of items to move when next or previous 
															are clicked (or corresponding swipe events)
	@param {boolean} 	[config.itemsindicator]				page indicators
	@param {boolean} 	[config.animationstatus]			if 'on' the carousel will scroll automatically (the delay between
															each scroll is set by the data-animationDuration param).
	@param {number} 	[config.animationduration=6000]		The delay (in ms) between each auto scroll.
	@param {string} 	[config.layout]						'2d' | '3d' | 'flat_3d'
	@param {boolean} 	[config.templateItem]				template of carousel item
	@param {String} 	[options.vmKeys.action.select='']
	@param {boolean}	[config.avoidBlank]					Specify if NOT to allow empty slots when having
															the 'cyclic' attribute as false.
	@param {number} 	[config.absoluteitemsstep]			Same as ItemSteps except it allows only N*ItemSteps to come into focus. Should be used with avoidBlank=false and cyclic=false.					
	The name of the action event that will be sent when an item has been selected. default is "select"
 */

define('src/components/carousel/view/BaseCarouselView',[
		'jquery',
        'underscore',
        'backbone',
        'text!./template/carousel.html',
        'text!./template/carouselItem.html',
        'carousel',
        'lightsaber.core'
        ], 
        function($, _, Backbone, template, carouselItem, Carousel, Lightsaber) {

        	

	var CarouselView = Lightsaber.View.extend({

		
		/** @lends CarouselView.prototype */
		publicMethods : ['addHtmlElement','addHtmlElements','removeHtmlElement','remove','empty','refresh','selectItem','nextItem','previousItem','firstItem','lastItem'],

		vmKeys : {
			"action.select"	: "select"
		},
		initialize : function() {
			_.bindAll(this, 'empty', '_selectedVm', '_selectedHtml', 'refresh', 'render', '_notsupported', 
					'_addModelItems', '_refreshModelItems', 'removeHtmlElement', '_addItem','addHtmlElement', 
					'addHtmlElements', '_show', 'remove', '_load', '_setClickHandler', 'selectItem', '_unBindClickEvent', '_handleSelectEvent');
			_.bind(this._setIdexUpdateHandler, this);
			this.items = [];
			this.carousel = null;
			this.carouselRoot = null;
			this.clickHandlerAttempt = 0;
            this.template = this.getConfig("template") || _.template(template);
            this.templateItem = this.getConfig("templateItem") || carouselItem;
            this.templateItem = _.template(this.templateItem);
			this.viewModel.on('items:loaded', this._refreshModelItems, this);
			this.viewModel.on('items:added', this._addModelItems, this);
			this.viewModel.on('items:refreshed', this._refreshModelItems, this);
			this.viewModel.on('items:emptied', this._refreshModelItems, this);
			this.viewModel.on('items:removed', this._refreshModelItems, this);
			this.viewModel.on('items:changed', this._refreshModelItems, this);
			this.viewModel.on('items:emptied', this.empty, this);
		},

		render : function() {
			this.placeRoot( $(this.template()));
			this.carouselRoot = this.$root.find('ul[data-role="carousel"]');
			if (this.carouselRoot.attr("id") == null) {
				this.carouselRoot.attr("id", this.cid);				
			}
			this.carouselRoot.attr('data-avoidBlank', this.getConfig('avoidBlank'));
			this.carouselRoot.attr('data-cyclic', this.getConfig('cyclic'));
			this.carouselRoot.attr('data-direction', this.getConfig('direction'));
			this.carouselRoot.attr('data-itemsdisplayed', this.getConfig('itemsdisplayed'));
			this.carouselRoot.attr('data-itemsstep', this.getConfig('itemsstep'));
			this.carouselRoot.attr('data-itemsindicator', this.getConfig('itemsindicator'));
			this.carouselRoot.attr('data-animationstatus', this.getConfig('animationstatus'));
			this.carouselRoot.attr('data-animationduration', this.getConfig('animationduration'));
			
			this.carouselRoot.attr('data-render', this.getConfig('layout') === undefined ? undefined : this.getConfig('layout').toLowerCase());
			this.carouselRoot.attr('data-outmargin', this.getConfig('outmargin'));
			this.carouselRoot.attr('data-height', this.getConfig('height'));
			this.carouselRoot.attr('data-absoluteitemsstep', this.getConfig('absoluteitemsstep'));
			if (this.rootCSS) {
				this.carouselRoot.addClass(this.rootCSS);
				this.carouselRootCSS = this.rootCSS;
			}
			
            this._load(this.viewModel.getData());
		},
		
		configChanged: function(changed) {
			if (changed && changed.rootCSS != null) {
				this.carouselRoot.removeClass(this.carouselRootCSS);
				this.carouselRoot.addClass(this.rootCSS);
				this.carouselRootCSS = this.rootCSS;
			}
		},
		
		/**
		 Method called when an HTML item is added to the carousel that is not part of a model.
		 Adding a JSON item to the carousel must be done through the ViewModel exposed method
		 @memberOf Lightsaber.Mobile.CarouselView
		 @name addHtmlElement
		 @param item HTML element to be added to the carousel
		 function		 
		 */	
		addHtmlElement : function(item) {
			this.items.push(item);
			this._addHtmlElement(item);
			this.refresh();
			
		},

		/**
		 Method called to remove an HTML element from the carousel
		 @name removeHtmlElement
		 @param index index of the element to remove
		 function		 
		 */	
		removeHtmlElement : function(index) {
			if(this.carousel != null){
				this.items.splice(index, 1);
				this.carousel.removeItem(index);	
				this.refresh();
			}
		},

		/**
		 Method called when a number of HTML items are added to the carousel (that are not part of a model).
		 Adding a JSON item to the carousel must be done through the ViewModel exposed method
		 @memberOf Lightsaber.Mobile.CarouselView
		 @name addHtmlElements
		 @param items list of HTML elements to be added to the carousel
		 @function		 
		 */	
		addHtmlElements : function(items) {
			this.carouselRoot.hide();			
			for (var i in items) {
				this.items.push(items[i]);
				this._addHtmlElement(items[i]);
			}
			this.carouselRoot.show();			
			this._show();
		},

		/**
		 Method used for removing the carousel from the DOM
		 @memberOf Lightsaber.Mobile.CarouselView
		 @name remove
		 @function		 
		 */	
		remove: function(){
			this.carousel = null;
			this.items.splice(0, this.items.length);
			this.viewModel.off('items:loaded', null, this);
			this.viewModel.off('items:added', null, this);
			this.viewModel.off('items:refreshed', null, this);
			this.viewModel.off('items:emptied', null, this);
			this.viewModel.off('items:removed', null, this);
			this.viewModel.off('items:changed', null, this);
			this.$root.remove();
		},
		
		/**
		 Method used to refresh the carousel.
		 This will take the items and recreate the carousel
		 @memberOf Lightsaber.Mobile.CarouselView
		 @name remove
		 @function		 
		 */	
		refresh: function(){
			if (this.carousel != null) {
				this._unBindClickEvent();
				this.carousel.refresh();		
				this._setClickHandler();
			}else{
				this._show();
			}

		},
		
		/**
		 Method used to unbind click event on each item of the carousel.
		 */			
		_unBindClickEvent :function(){
			// override
			},
		
		empty : function() {
			if (this.carousel != null) {
		         this.carousel.empty();							
			}
		},
		
		/***
		 * Used to throw errors for unsupported model events
		 */
		_notsupported: function() {
			throw ("Not supported functionality");
		},
		/****
		 * Loads the carousel data onto the DOM
		 */
		_load : function(data){
			if (data == null || (data.items && data.items.length < 1)) return;
			this.carouselRoot.hide();
			for(var i = 0; i < data.items.length; i++){
				this._addItem({item: data.items[i]}, false);
			}
			this.carouselRoot.show();
			this._show();
		},
		/****
		 * Will refresh the items from the viewmodel model. will rebuild the
		 * carousel and handle add/remove and refresh events
		 */
		_refreshModelItems : function(data) {
			this.items.splice(0, this.items.length);
			this.empty();
			if (data.items != null) {
				this._load(data);								
			} else {
				this._load(this.viewModel.getData());				
			}
		},
		/****
		 * Method called to add an item when the model has new item
		 */
		_addModelItems : function(data) {
        	if (data.length) {
        		for (var i=0;i<data.length;i++) {
             		this._addItem(data[i]);  	         		        			
        		}
        	} else {
         		this._addItem(data);  	         		
        	}
		},
		

		/***
		 * Adds a model item to the carousel
		 */
		_addItem : function(dataItem, show) {
			var item = this.getPopulatedTemplate(this.templateItem, dataItem);
			this.items.push(item);
			this._addHtmlElement(item);
			if (show || show == undefined) {
				this.refresh();
			}
		},
		/**
		 * Adds HTMl element to the DOM list
		 */
		_addHtmlElement : function(item) {
			var listItem = $('<li></li>');
			listItem.append(item);
			// checking if we are adding before or after init
			if (this.carousel != null) {
				this.carousel.addItem(listItem);
				this.refresh();
	        } else {
				this.carouselRoot.append(listItem);	        	
	        }

		},
		/***
		 * Used to show the carousel on the page
		 */
		_show : function(){
			var itemsdisplayed = this.getConfig('itemsdisplayed');
			var initialIndex = 0;
			if(itemsdisplayed > 1) {
				initialIndex = 1;
			}
			var view = this;
			if(this.items.length >= 0 && this.carousel == null){
				this.clickHandlerAttempt = 0;
				this.carousel = this.carouselRoot.LSCarousel().data("plugin_LSCarousel");
				var carousel = this.carousel;
				if(carousel.view.currentIndex === initialIndex) {
					view.trigger('carousel:first');
				}
				if(carousel.view.items.length && (carousel.view.currentIndex === carousel.view.items.length - itemsdisplayed )) {
					view.trigger('carousel:last');
				}
				if((carousel.view.currentIndex !== initialIndex) && !(carousel.view.items.length && (carousel.view.currentIndex === carousel.view.items.length - itemsdisplayed ))) {
					view.trigger('carousel:middle');
				}
				this.carouselRoot.on('lsc_controlNext', function() {
					if(carousel.view.currentIndex === initialIndex) {
						view.trigger('carousel:first');
					}
					if(carousel.view.items.length && (carousel.view.currentIndex === carousel.view.items.length - itemsdisplayed )) {
						view.trigger('carousel:last');
					}
					if((carousel.view.currentIndex !== initialIndex) && !(carousel.view.items.length && (carousel.view.currentIndex === carousel.view.items.length - itemsdisplayed ))) {
						view.trigger('carousel:middle');
					}
				});
				$(this.el).trigger('create');
				this._setClickHandler();
				this._setIdexUpdateHandler(this);
				this._prevControl(this);
				this._nextControl(this);
			} else {
				this.refresh();
				if(this.carousel.view.currentIndex === initialIndex) {
					view.trigger('carousel:first');
				}
				if(this.carousel.view.items.length && (this.carousel.view.currentIndex === this.carousel.view.items.length - itemsdisplayed )) {
					view.trigger('carousel:last');
				}
				if((this.carousel.view.currentIndex !== initialIndex) && !(this.carousel.view.items.length && (this.carousel.view.currentIndex === this.carousel.view.items.length - itemsdisplayed ))) {
					view.trigger('carousel:middle');
				}
			}
		},

		/***
		 * Sets the click handler on the carousel. depends on whether model or html
		 */
		_setClickHandler : function() {
			if (this.carousel != null) {
				// checking if the view or the viewmodel should trigger the event (VM only for collection VM and for backwards
				// compatibility
				if(this.viewModel.viewModelType == 'Collection') {
					this._selectedVm();
				} else {
					this._selectedHtml();
				}
				this.clickHandlerAttempt = 0;
			} else {
				if (this.clickHandlerAttempt > 5) {
					throw "Could not initialize carousel"
				}
				setTimeout(this._setClickHandler, 300);					
				this.clickHandlerAttempt++;				
			}
		},
		
		/************
		 * Handles the click event and send the relevant triggers.
		 */
		_handleSelectEvent : function(event, itemId, triggerName, triggerObject) {
			triggerObject.trigger(triggerName, {"itemId" : itemId, "event" : event});
			// sending the action from the viewmodel
			var selectObj = {"itemId" : itemId, "event" : event};
			this.viewModel.handleAction(this.vmKeys['action.select'], selectObj);
			//event.stopPropagation();
			//event.preventDefault();
		},
		
		/***
		 * this event is a called when an current item in the carousel has been changed
		 @memberOf Lightsaber.Mobile.CarouselView
		 @name Carousel:indexUpdate
		 @event
		 @param Event evt
		 @param this view
		 @function		 
		 */
		_setIdexUpdateHandler : function(that){
			that.carouselRoot.on("lsc_indexUpdate", 
					function(e){
						that.trigger('Carousel:indexUpdate', e);
					});
		},
		/*** 
		 * Used to send selected event to the viewmodel to pass event on
		 */
		_selectedVm : function() {
			//override
		},
		/***
		 * Used to trigger event for select for instances that do not have a model associated
		 */
		/**
		 this event is a called when an item in the carousel has been clicked
		 for carousels that do not have an associated collection viewModel and model
		 @memberOf Lightsaber.Mobile.CarouselView
		 @name carousel:selected
		 @event
		 @param Event evt
		 @param String itemId
		 @function		 
		 */
		_selectedHtml : function() {
			//override
		},
		
		/**
		 Method called to display specific item of carousel
		 @name selectItem
		 @param index index of the element to be dysplayed
		 function		 
		 */	
		selectItem : function(index, animateFlag){
			if(this.carousel != null){
				this.carousel.selectItem(index, animateFlag);
			}
		},
		
		/**
		 Method called to display next item of carousel
		 @name nextItem
		 function		 
		 */	
		nextItem: function(){
			if(this.carousel != null){
				this.carousel.next();
			}
		},
		
		/**
		 Method called to display previous item of carousel
		 @name nextItem
		 function		 
		 */	
		previousItem: function(){
			if(this.carousel != null){
				this.carousel.previous();
			}
		},
		
		/**
		 Method called to display first item of carousel
		 @name nextItem
		 function		 
		 */	
		firstItem: function(){
			if(this.carousel != null){
				this.carousel.first();
			}
		},
		
		
		/**
		 Method called to display last item of carousel
		 @name nextItem
		 function		 
		 */	
		lastItem: function(){
			if(this.carousel != null){
				this.carousel.last();
			}
		},
		
		/***
		 * this event is a called when an current item in the carousel has been changed to previous item
		 @memberOf Lightsaber.Mobile.CarouselView
		 @name Carousel:prevEvent
		 @event 
		 @param Event evt, evt.hasMore : true if there are more previous items
		 @param this view
		 @function		 
		 */
		_prevControl : function(that){
			that.carouselRoot.on("lsc_controlPrevious", 
					function(e){
						that.trigger('Carousel:prevEvent', e);
					});
		},
		
		/***
		 * this event is a called when an current item in the carousel has been changed to next item
		 @memberOf Lightsaber.Mobile.CarouselView
		 @name Carousel:nextEvent
		 @event 
		 @param Event evt, evt.hasMore : true if there are more next items
		 @param this view
		 @function		 
		 */
		_nextControl : function(that){
			that.carouselRoot.on("lsc_controlNext", 
					function(e){
						that.trigger('Carousel:nextEvent', e);
					});
		},

        destroy: function() {
        	if(this.carouselRoot) {
            	this.carouselRoot.off();
            	this.carouselRoot.remove();
            }
            this._super();
        }
	});
	
	

	return CarouselView;

});


/**
@class CarouselView
@type View
@memberOf Lightsaber.Web
@name CarouselView

@description
View to show the carousel widget.

@example 1 Carousel is created with item list view model


		var model = new Lightsaber.Core.Collection();
		model.url = 'vasia/vasia';


		var carouselViewModel = new Lightsaber.CollectionViewModel({
			models : {
				items : model
			}

		});

		var myCarousel = new Lightsaber.CarouselView({
			el : '#carousel',
			viewModel : carouselViewModel,
			config: {  
				direction : 'horizontal',
				cyclic : 'true',
				itemsdisplayed : '4',				
				itemsstep : '2',
				itemsindicator : 'true',
				animationstatus : 'on',
				animationduration : '6000',
				layout : '3d',
				rootClass : '',
				templateItem : itemtemplate
			}
		});
			
		model.fetch({
		});


@example 2 Carousel is created by adding views


			var myCarousel = new Lightsaber.CarouselView({
				el : '#carousel1',
				viewModel : carouselViewModel,
				config: {  
							direction : 'horizontal',
							cyclic : 'true',
							itemsdisplayed : '4',							
							itemsstep : '2',
							itemsindicator : 'true',
							animationstatus : 'on',
							animationduration : '6000',
							layout : '2d'
				}
			}); 
			var myItems = [
			      "item1", "item2"
			];
			
			myItems[myItems.length] = '<div id="graph" style="width: 200px; z-index: 1001;"></div>';
			myItems[myItems.length] = '<div class="package_item_title">Data</div>' + 
	          '<div class="package_item_details"><img src="http://amx.dev.volasent.com/R9/trunk/Web/Content/images/temp/package_graph3.png" alt="" /></div>' +
	          '<div class="package_item_desc">500 MB</div>' +
	          '<div class="package_item_price"><strong>$41.85</strong>/mo.</div>';
			  
			myCarousel.addHtmlElements(myItems);
			
			var model = new Lightsaber.Core.Model();
			model.set('series', [40, 50, 90]);
			model.set('axisLabels', ["Oct", "Nov", "Dec"]);		

			var barChartViewModel = new Lightsaber.BarChartViewModel({
				models : {
					items : model
				}
			});
	
			this.barChartView = new Lightsaber.BarChartView({
				el : 'graph',
				viewModel : barChartViewModel,
	
				config : {
					barDirection: 'vertical',
					showPointLabels: true,
					showYAxisLabels: false,
					drawGridlines: false,
					barWidth: 10
				}
			});
			
			
@example 3

			<div class="ui-grid-a">
				<div  class="ui-block-a">
					<input id="prev-button1" name="prev" type="button" value="prev">
				</div>
				<div class="ui-block-b">
					<input id="next-button1" name="next" type="button" value="next">
				</div>
			</div>
			<div id="carousel2"></div>
			
			
		var myCarousel22 = new Lightsaber.CarouselView({
			el : '#carousel2',
			viewModel : carouselViewModel,
			config: {  
						direction : 'horizontal',
						cyclic : 'false',
						itemsdisplayed : '1',						
						itemsstep : '1',
						itemsindicator : 'true',
						//animationstatus : 'on',
						//animationduration : '6000',
						layout : '2d'
			}
		}); 
		
		//modelInternal.fetch({});
		
		myCarousel22.addHtmlElement('Carousel Item 1');
		myCarousel22.addHtmlElement('Carousel Item 2');
		myCarousel22.addHtmlElement('Carousel Item 3');
		
		
		myCarousel22.on('Carousel:prevEvent', function (e) {
			$('#prev-button1').button(e.hasMore?'enable':'disable'); 
		});

		myCarousel22.on('Carousel:nextEvent', function (e) {
			$('#next-button1').button(e.hasMore?'enable':'disable'); 
		});
		
		$('#next-button1').on('click', function() {
			myCarousel22.nextItem();
		});

		$('#prev-button1').on('click', function() {
			myCarousel22.previousItem();
		});			



@constructor 

@memberOf Lightsaber.Web.CarouselView
	@param Object 		[Lightsaber.CollectionViewModel] 	Model with the data for the carousel items
	@param {String} 	[config.direction='vertical']		The bar direction['vertical' or 'horizontal']
	@param {boolean} 	[config.cyclic]						Indicates whether the carousel is cyclic 
															or has a next/previous boundary
	@param {boolean} 	[config.itemsdisplayed]				items number displayed on the page 
	@param {boolean} 	[config.outmargin]					this param specifies a margin that will reduce 
															the carousel view port in order to see if there 
															is more items on the left/right. It is a size in 
															pixelIt is usefull if there is no itemindicators. 
	@param {boolean} 	[config.itemsstep]					amount of items to move when next or previous 
															are clicked (or corresponding swipe events)
	@param {boolean}	[config.avoidBlank]					Specify if NOT to allow empty slots when having
															the 'cyclic' attribute as false.
	@param {boolean} 	[config.itemsindicator]				page indicators
	@param {boolean} 	[config.animationstatus]			animation status on | off 
	@param {boolean} 	[config.layout]						'2d' | '3d' | 'flat_3d'
	@param {boolean} 	[config.templateItem]				template of carousel item
 */

define('src/components/carousel/view/CarouselView',[
        'underscore',
        'backbone',
        'text!./template/carousel.html',
        'text!./template/carouselItem.html',
        'carousel',
        'lightsaber.core',
        'src/components/carousel/view/BaseCarouselView'
        ], 
        function(_, Backbone, template, carouselItem, Carousel, Lightsaber, BaseCarouselView) {

        	
	var view = BaseCarouselView.extend({
		
				
		/**
		 Method used to unbind click event on each item of the carousel.
		 */			
		_unBindClickEvent :function(){
			this.carouselRoot.children().off();
		},
		/*** 
		 * Used to send selected event to the viewmodel to pass event on
		 */
		_selectedVm : function() {
			
			var that = this;
			this.carouselRoot.children().each(function(index){
				$(this).off().on('click', function(event){
					event.itemId = index;
					that._handleSelectEvent (event, index, 'items:selected', that.viewModel);
				});
			});
			
		},
		/***
		 * Used to trigger event for select for instances that do not have a model associated
		 */
		/**
		 this event is a called when an item in the carousel has been clicked
		 for carousels that do not have an associated collection viewModel and model
		 @methodOf Lightsaber.Web.CarouselView
		 @name carousel:selected
		 @event
		 @param Event evt
		 @param String itemId
		 @function		 
		 */
		_selectedHtml : function() {
			var that = this;
			this.carouselRoot.children().each(function(index){
				$(this).off().on('click', function(event){
					that._handleSelectEvent (event, index, 'carousel:selected', that);
				});
			});

		}
		
		
	});
	
	

	return view;

});


/**
Base Web <em>Navigation</em> component. Is overriden by *Module* component.

@class Lightsaber.Web.Navigation
@namespace Lightsaber.Web
@module Lightsaber.Web
@extends Backbone.View

@requires jquery
@requires backbone
@requires Lightsaber.Utils

@examples none
@guides ["Core Concepts/Application and Navigation"]

@param {Object} [options] the <em>Navigation</em> configuration object
**/
define('src_web/components/application/view/Navigation',[
    'jquery',
	'backbone',
	'src/core/util/Utils'
], function($, Backbone, Utils) {

	

	var Navigation = Backbone.View.extend({
		
		childParams : {},

		/**
		Handles routes, by deducing, from current and previous routes, which modules should be 
		removed and which loaded.

		@method _handleRoutes
		@protected
		@param {Array} routes routes to load
		@param {Object} options configuration options
		**/
		_handleRoutes : function(routes, options) {
			var previousRoutes = this._getPreviousRoutes();
			var moduleConfig;				
			
			var newRoutes = this._normalizeRoutes(_.difference(routes, previousRoutes)); 
			var oldRoutes = this._normalizeRoutes(_.difference(previousRoutes, routes));
			
			var childModulesToRemove = this._getChildModulesToRemove(newRoutes);			
			
			oldRoutes = _.uniq(oldRoutes.concat(childModulesToRemove)); //add to oldRoutes children that not in url, but need to be removed
						
			if((newRoutes.length === oldRoutes.length) && (newRoutes.length === 0)) {
				newRoutes.push(this.lastReloadedRoute);
			}
	
			var parentsToReload = _.uniq(this._clearModules(oldRoutes, options)); //collect all parents that might need to reload default modules
			this._loadModules(newRoutes, options);
			this._reloadDefaultModules(parentsToReload);
			this.route = this._calculateRouteByRoutes(routes);	
		},
		
		/**
		@private
		**/
		_getPreviousRoutes : function() {
			var previousRoutes = this.route.split(this.separator);
			previousRoutes = this._normalizeRoutes(previousRoutes);
			return previousRoutes;
		},
		
		/**
		@private
		**/
		_normalizeRoutes : function(routes) {
			var normalizedRoutes = routes;
			if(normalizedRoutes.length === 1 && normalizedRoutes[0] === '') { // TODO make this more efficient
				normalizedRoutes = [];
			}
			
			return normalizedRoutes;
		},
		
		/**
		Clears modules (by calling {{#crossLink "Lightsaber.Mobile.Navigation/_clear:method"}}{{/crossLink}}) method 
		for each.

		@method _clearModules
		@protected
		@param {Array} routes routes to clear
		@param {Object} options configuration options
		**/
		_clearModules : function(routes, options) {
			var parentsToReload = [];
			var moduleConfig;
			for (var i = 0; i < routes.length; i++) {
				moduleConfig = this._getModuleConfig(routes[i]);
				if(moduleConfig)
				{
					parentsToReload = parentsToReload.concat(this._clear(moduleConfig, routes[i]));
				}
			}
			return parentsToReload;
		
		},

		/**
		@private
		**/
		_getChildModulesToRemove : function (newRoutes)
		{	
			var modulesToRemove = [];	
			var allChildren = this.getAllChildrens()||[];
			var childConfig;
			var newConfig;

			for(var i = 0; i < allChildren.length; i++)
			{
				childConfig = this._getModuleConfig(allChildren[i]);
				for(var j = 0; j < newRoutes.length; j++)
				{
					newConfig = this._getModuleConfig(newRoutes[j]);
					if(newConfig&&childConfig!==newConfig&&childConfig.el===newConfig.el)
					{
						modulesToRemove.push(allChildren[i]);
					}
				}
			}
			return modulesToRemove;
		},
		
		/**
		@private
		**/
		_reloadDefaultModules : function (modulesToReload)
		{
			var moduleConfig;

			for(var i = 0; i < modulesToReload.length; i++)
			{
				moduleConfig = this._getModuleConfig(modulesToReload[i]);
				if(moduleConfig&&moduleConfig.instance)
				{
					moduleConfig.instance._reloadDefaultModules();
				}
			}
		},

		/**
		Loads modules (by calling {{#crossLink "Lightsaber.Mobile.Navigation/_loadModule:method"}}{{/crossLink}}) method 
		for each.

		@method _loadModules
		@protected
		@param {Array} routes routes to clear
		@param {Object} options configuration options
		**/
		_loadModules : function(routes, options) {
			var moduleConfig;
			for (var i = 0; i < routes.length; i++) {
				moduleConfig = this._getModuleConfig(routes[i]);
			
				this._loadModule(moduleConfig, routes[i], options);
			}
		 this.route = this._calculateRouteByRoutes(routes);
		},

		/**
		Unloads the module.

		@method _unloadModule
		@protected
		**/
		_unloadModule: function() {
			var parent = this.options.parent;
			var regex = this.options.regex;
			var moduleConfig;

			if(parent && parent.children) {
				parent.children = _.filter(parent.children, function(childRoute) {
				    return !regex.test(childRoute);
				});

				moduleConfig = _.find(this.modules, function(module) {
                    return module.id === regex;
                });

                moduleConfig.instance = null;
			}

			this.destroy();                        
		},

		/**
		@private
		**/
		_requireModule : function(moduleConfig, parentRef, route) {
			moduleConfig.parent._requireMap = moduleConfig.parent._requireMap || {};
			var requireMap = moduleConfig.parent._requireMap;
				
			if(requireMap[moduleConfig.el]){
				parentRef.loading.splice(_.indexOf(parentRef.loading, requireMap[moduleConfig.el]), 1);
			}

			requireMap[moduleConfig.el] = route;

			var doLoad = function(Module) {
				if(moduleConfig.parent._requireMap[moduleConfig.el] === route){
					moduleConfig.instance = new Module(moduleConfig);
					moduleConfig.instance._propagateEvent('load:', route, moduleConfig.parent);
					moduleConfig.instance._triggerFlowEvent('flow:load:step');
					delete moduleConfig.parent._requireMap[moduleConfig.el];
				}

				parentRef.loading.splice(_.indexOf(parentRef.loading, route), 1);
			};

			requirejs([moduleConfig.module || moduleConfig.path], doLoad);
		},

		/**
		Loads a module. If module is defined as cached - reloads it instead (by calling 
		{{#crossLink "Lightsaber.Mobile.Module/reload:method"}}{{/crossLink}}) method)

		@method _loadModule
		@protected
		@param {Object} moduleConfig augmented (with various meta-information) module configuration
		@param {String} route route that is used to load the module
		@param {Object} options configuration options
		**/	
		_loadModule : function(moduleConfig, route, options) {
			var parentRef = this;

			if(!moduleConfig)//if module is not registred yet, wait for registretion event before load
			{
				var cleanRoute = route.split('/')[0];
				this.on('registered:'+ cleanRoute, function() {
					this.off('registered:'+ cleanRoute);
					moduleConfig = this._getModuleConfig(route);
					this._loadModule(moduleConfig, route, options);
				});
			}
			else
			{
				this.loading = this.loading||[];
				if(_.indexOf(this.loading, route)!=-1) 
				{
					return;
				}
				
				this.loading.push(route);
				moduleConfig.parent.children.push(route);//add module to chilren list of parents
				var args = this.options.router._extractParameters(moduleConfig.regex, route);
				moduleConfig.params = this._createParams(moduleConfig.id, args);	
				moduleConfig.loadParams = options;
				this.routeToTarget[route] = moduleConfig.el;
				if(this.isApp) {
					moduleConfig.app = this;
				} else {
					moduleConfig.app = this.options.app;
				}
			
				if(moduleConfig.instance && moduleConfig.cached) { // Reload cached module
					moduleConfig.instance.$root.show();
					moduleConfig.instance.reload(moduleConfig);
					moduleConfig.instance._propagateEvent('load:', route, moduleConfig.parent);
					moduleConfig.instance._triggerFlowEvent('flow:load:step');
					parentRef.loading.splice(_.indexOf(parentRef.loading, route), 1);
				}
				else if(moduleConfig.instance && !moduleConfig.cached) { // Reload not cached module
					this._clear(moduleConfig, route);
					this._requireModule(moduleConfig, parentRef, route);
				}
				else { // Load module
					this._requireModule(moduleConfig, parentRef, route);
				}	
			}		
		},
		
		/**
		@private
		**/
		_propagateEvent : function(event, route, parent) {
			this.trigger(event + route, parent);
			this.options && this.options.parent && this.options.parent._propagateEvent(event, route, parent);
		},

		/**
		@private
		**/
		_triggerFlowEvent: function(event) {
			if(this.options.originalStepID) {
				var viewModel = this.options.router.getViewModel();
				if(viewModel) {
					viewModel.trigger(event, this.options, this.getFlowState());
				}
			}
		},

		/**
		@private
		**/
		_calculateNewRoute : function(route, options) {
			var routeToReplace = '';
			var result = this.route;
			
			var currentRoute = this._getHash();
			if(!(options && options.skipReplace && this._isSubRoute(currentRoute, route))) {
			var routes = result.split(this.separator);			
			var moduleConfig = this._getModuleConfig(route) || {};
				var allChildren = this.getAllChildrens();
				var childConfig;
				var newConfig;
				var hiddenRouteToReplace ='';
				for(var k = 0; k<allChildren.length;k++)
				{
					childConfig = this._getModuleConfig(allChildren[k]);
					newConfig = this._getModuleConfig(route);
					if(newConfig&&childConfig.el===newConfig.el)
					{
							hiddenRouteToReplace = allChildren[k];
							break;
					}
					
					
				}
				
				for (var i = 0; i < routes.length; i++) {
					if( this.routeToTarget && (this.routeToTarget[routes[i]] === moduleConfig.el)) {
						routeToReplace = routes[i];
						break;
					}
				}
				
				if(routeToReplace) {
					result = result.replace(routeToReplace, route);
					var configToReplace = this._getModuleConfig(routeToReplace);
					var children = (configToReplace.instance&&configToReplace.instance.getAllChildrens())||[];
					for(var z = 0; z<children.length;z++)
					{
						result = result.replace(this.separator+children[z], '');
					}
				}
				else {
					if(result) {
						result = result + this.separator + route;
						if(hiddenRouteToReplace)
						{
							var configToReplace = this._getModuleConfig(hiddenRouteToReplace);
							var children = (configToReplace.instance&&configToReplace.instance.getAllChildrens())||[];
							for(var z = 0; z<children.length;z++) //TODO  improve this part
							{
								result = result.replace(this.separator+children[z], ''); //TODO only one of them need to be done
								result = result.replace(children[z]+this.separator, '');
								result = result.replace(children[z], '');
							}
						}
					}
					else {
						result = route;
					}				
			}
			} else {
				result = currentRoute;
			}
			
			return result;
		},

		/**
		@private
		**/
		_isSubRoute: function(route, subRoute) {
			var result = false;
			if(route !== '') {
				if(route.indexOf(route) >= 0) {
					result = true;
				}
			} 
			return result;
		},

		/**
		@private
		**/
		getAllChildrens : function()
		{
			var children = [];
			var childConfig;
			for(var x = 0; x< this.children.length; x++)
			{
				childConfig = this._getModuleConfig(this.children[x]);
				children.push(this.children[x]);
				if(childConfig.instance)
				{
					children = children.concat(childConfig.instance.getAllChildrens());
				}
			}
			return children;
		},
		
		/**
		@private
		**/
		_getModuleConfig : function(route) {
			var moduleConfig;
			for(var i = this.registeredModules.length - 1; i >= 0; i--) {
				var regex = this.registeredModules[i].regex;
				if(regex.test(route)) {
					moduleConfig = this.registeredModules[i];
					break;
				}
			}
			if(!moduleConfig&&this.options.app) //if module is not local bring it from parent
			{
				moduleConfig = this.options.app._getModuleConfig(route);
			}
			return moduleConfig;
		},
		
		/**
		Returns augmented module configuraiton object (with various meta-information).

		@method getModuleConfig
		@param {String} route route that defines the module to load
		**/
		getModuleConfig : function(route) {
			return this._getModuleConfig(route);
		},
		
		/**
		Clears a module. If module is defined as cached - hides it instead.

		@method _clear
		@protected
		@param {Object} moduleConfig augmented (with various meta-information) module configuration
		@param {String} route route that is used to load the module
		@param {Object} options configuration options
		**/	
		_clear : function(moduleConfig, route, forceClear) {
			var routeConfig = this._getModuleConfig(route);
			var parentsToReload = [];
			//console.log('clear '+ moduleConfig.id);
			

			
			parentsToReload.push(moduleConfig.parent.id);
		
				if(!forceClear&&moduleConfig.cached) {
					moduleConfig.instance.$root.hide();
					// moduleConfig.instance._triggerFlowEvent('flow:cancel');
				}
				else {
					for(var i = 0; i < moduleConfig.parent.children.length; i++)
					{
						if(routeConfig === this._getModuleConfig(moduleConfig.parent.children[i]))
						{
							moduleConfig.parent.children.splice(i,1);
							break;
						}
					}
					
					if(moduleConfig.el && moduleConfig.instance) {
						if(moduleConfig.instance.$el === moduleConfig.instance.$root) {
							// fix for IE otherwise Iframe isnt unloaded from memory
							moduleConfig.instance.$root.children().not(':hidden').find('iframe').attr('src', '');
							moduleConfig.instance.$root.children().not(':hidden').remove();	
						}
						else {
							// fix for IE otherwise Iframe isnt unloaded from memory
							moduleConfig.instance.$el.children().not(':hidden').find('iframe').attr('src', '');
							moduleConfig.instance.$el.children().not(':hidden').remove();						
						}
						// moduleConfig.instance._triggerFlowEvent('flow:cancel');
					}
					if(moduleConfig.instance) {
						moduleConfig.instance._requireMap = {};
						moduleConfig.instance.removeChildren(moduleConfig);
						moduleConfig.instance._unregisterChildren(moduleConfig);
                        moduleConfig.instance.destroy(moduleConfig);
						moduleConfig.instance._propagateEvent('clear:', route, moduleConfig.parent);
						// moduleConfig.instance._triggerFlowEvent('flow:cancel');
						delete moduleConfig.instance;
					}
				}
			
			return parentsToReload;
		},

		/**
		@private
		**/
		removeChildren: function(moduleConfig) {
			var childConfig;
				var childList  = _.clone(this.children);
			for(var j = 0; j< childList.length;j++)
			{
				childConfig = this._getModuleConfig(childList[j]);
				if(childConfig.instance) {
					childConfig.instance._clear(childConfig,childList[j],true);
				}
			}
            if(this.___children) {
                for (var i = this.___children.length - 1; i >= 0; i--) {
                    if(this.___children[i]) {
                        this.___children[i].destroy();
                        delete this.___children[i];
                    }
                };
            }
        },

        /**
		@private
		**/
        _unregisterChildren : function()
        {
        	this.options.app.unregisterModules(this.modules);
        },

        /**
		@private
		**/
        unregisterModules : function(moduleConfigs) {
			var moduleConfig;
			if(moduleConfigs) {
				for(var i = moduleConfigs.length - 1 ; i >= 0; i--) {
					moduleConfig = moduleConfigs[i];
					this.unregisterModule(moduleConfig, this);
				}
			}
		},
		
		/**
		@private
		**/
		unregisterModule : function(moduleConfig, parent) {
			if(_.indexOf(this.registeredModules, moduleConfig)!=-1)
			{
				this.registeredModules.splice(_.indexOf(this.registeredModules, moduleConfig), 1);
			}
			else if(this.options.app)
			{
				this.options.app.registeredModules.splice(_.indexOf(this.options.app.registeredModules, moduleConfig), 1);
			}
		},
		
		/**
		@private
		**/
		_calculateRouteByRoutes : function(routes) {
			var route = '';
			for(var i = 0; i < routes.length; i++) {
				route += routes[i]+ this.separator;
			}
			if(route !== '') {
				route = route.slice(0, -(this.separator.length));
			}
			return route;
		},

		/**
		@private
		**/
		_createParams : function(id, args) {
			var params = id.split('/').slice(1), index = 0;

			var paramsObject = {}, param;
			for(var i = 0, length = params.length; i < length; i++){
				param = params[i];
				if(!(param.substring(0, 1) === ':' || param.substring(0, 1) === '*')) {
					continue;
				}
				paramsObject[param.substring(1)] = args[index++];
			}
			
			return paramsObject;
		},
		
		/**
		@private
		**/
		_applyParams : function(id, params) {
			var regex, route = id;
			for(var param in params) {
				regex = new RegExp('[(:)(\\*)]\\b' + param + '\\b([\/]?)', 'gi');
				route = route.replace(regex, params[param] + '$1');
			}
			
			return route;
		},
		
		/**
		@private
		**/
		_createRouteConfig : function(options, external) {
			var configuration = $.extend(true, {}, options);	
			
			if(configuration.trigger === undefined) {
				configuration.trigger = true;
			}
			
			configuration.external = external;
			
			return configuration;
		},
		
		/**
		@private
		**/
		_getHash : function() {
			return Backbone.history.getFragment();
		},
		
		create : Utils.create
		
		
	});	
	
	Navigation.extend = Utils.extend;
	
	return Navigation;
});

define('text!src_web/components/application/view/template/moduleTemplate.html',[],function () { return '<div></div>';});

/**
Base Web <em>Module</em> component. Is overriden by all *Module* components.

> **Note** that *Module* component is not intended to be instantiated directly, rather registered
> on other *Modules* and on the *Application* to be instantiated, when needed, when navigation 
> (inlvolving this specific module) is performed.
> 
> Also **note** that there is **no difference** between page and "regular" *Modules.* In some cases
> **the same Module** may serve as "page" and in some cases it may be an inner "fragment" of another
> *Module*.

The following shows registration of *Web* (read: logical JQM) page modules:

```javascript
new Lightsaber.Application({
    router: router,
    modules: [
        {
            el: '#main', 
            title: 'Main Page',
            path: 'app/pages/MainPage'
        },
        {
            el: '#page1', 
            title: 'Page 1', 
            path: 'app/pages/Page1'
        }
    ]
});
```

In addition, *Module* allows to perform applicative navigation between its inner *Modules* - complete with `back` and `forward` 
actions. That is to say, that any inner *Module* that is loaded is added to inner stack and using 
{{#crossLink "Lightsaber.Web.Module/back:method"}}{{/crossLink}} and {{#crossLink "Lightsaber.Web.Module/forward:method"}}{{/crossLink}}
one can **programmatically** navigate bewteen them, much like between "real" pages.

@class Lightsaber.Web.Module
@namespace Lightsaber.Web
@module Lightsaber.Web
@extends Lightsaber.Web.Navigation

@since 9.0.0
@protected

@requires jquery
@requires backbone
@requires Lightsaber.Core.Utils
@requires Lightsaber.Web.Navigation
@requires Lightsaber.Core.Utils

@examples none
@guides ["Core Concepts/Application and Navigation"]

@param {Object} [options] the <em>Module</em> configuration object
**/
define('src_web/components/application/view/Module',[
    'jquery',
	'backbone',
	'src/core/model/Model',
	'src_web/components/application/view/Navigation',
	 'src/core/util/Utils',
	'text!./template/moduleTemplate.html'
], function($, Backbone, Model, Navigation, Utils, template) {

    

	
	var Module = Navigation.extend({

		
        /**
        Inner *Modules* definitions.

        Similar to page *Modules* defintions on {{#crossLink "Lightsaber.Web.Application"}}{{/crossLink}} - this
        property defines inner *Modules*, sometimes called **fragments**, of a *Module*.

        Such registration allows to treat them as units of encapsulation:

        ```javascript
        ...
        modules : [
            {id: 'module1', name: 'Module 1', el: '#target', module: 'app/modules/Module', browserHistory: false}
            {id: 'module2', name: 'Module 2', el: '#target', module: 'app/modules/Module', isDefault: true}
            {id: 'module3', name: 'Module 3', el: '#target', module: 'app/modules/Module'}
        ]
        ...
        ```

        Possible configuration options include:

        * `id` - the ID of the module which is used in programmatic navigation via `this.load('module1')` calls
        * `name`, `title`, ... - any custom property that will be passed to the *Module's* constructor
        * `module` - path to the *Module's* JavaScript file
        * `browserHistory` - `true`/`false`, indicating whether loading of the *Module* should be reflected in browser's history
        * `isDefault` - `true`/`false`, indicating whether the *Module* should be loaded, **by default**, with the parent *Module*

        @property {Array} modules
        @default `[]`
        **/

        /**
        Main configuration property.

        > **Note** that configuration properties are merged when *Modules* are extended.

        @property {Object} config
        @default `{}`
        **/
		config: {},
		
        mergeProperties: {
            config: 'merge'        
        },

        /**
        Retrieves configuration setting by its key.

        @method getConfig
        @param {String} key key
        **/
		getConfig: function(key) {
			return arguments.length === 0 ? this._config.toJSON() : this._config.get(key);
		},

        /**
        Main-entry method for the *Module*.

        The method does the following:

        * registers any inner modules defines by `modules` property
        * initialize inner stack that allows applicative navigation
        * render *Module's* template
        * call {{#crossLink "Lightsaber.Web.Module/preInit:method"}}{{/crossLink}}
        * call {{#crossLink "Lightsaber.Web.Module/init:method"}}{{/crossLink}}
        * call {{#crossLink "Lightsaber.Web.Module/postInit:method"}}{{/crossLink}}
        * call {{#crossLink "Lightsaber.Web.Module/_handlePage:method"}}{{/crossLink}}
        * trigger `loaded:<id>` event with this *Module's* ID

        @method initialize
        @protected
        @param {Object} options configuration options received by *Router's* constructor
        **/
		initialize : function(options) {
			this._config = new Model(this.config);
			this.optionsMap = options.optionsMap || this.optionsMap || {};			
			this.separator = '/#!/';
			this.routeToTarget = {};
			this.registeredModules = [];
			this.defaultModules = [];
			this.children = []; //stores children loaded by this module
			this.route = '';	
			this.routesStack = [];
			this.stackPosition = -1;
			this.navigated = true;
			this.renderTemplate(options);
			this._setDefaultModules(this.modules);
			this._init(options);

			this._defineRoute(options);
			var modules = this.modules = this._process(this.modules);	
			var fragments = this._process(this.fragments);	
			this.registerModulesWithHistoryFalse(modules);					
			this.registerModulesWithHistoryFalse(fragments, true);

			this.preInit(options);
			this.init(options);
			this.postInit(options);

					
			this.registerModules(modules);					
			this.registerModules(fragments, true);

			this._loadDefaultChildren(options);
			if(options.hash) {
				Backbone.history.loadUrl(Backbone.history.fragment);
			}				
			this._handlePage(options);

			this.options.app.trigger('loaded:' + this.options.id);
		},

        /**
        @private
        **/
		_process : function(modules) {
			var augmentedModules = [];
			var augmentedModule;
			if(!_.isArray(modules)) {
				for(var module in modules) {
					augmentedModule = modules[module];
					augmentedModule.id = module;
					augmentedModules.push(augmentedModule);
				}
				modules = augmentedModules;
			}
			// prevent from the module to register to itself
            modules = _.filter(modules, function(module){
                 return this.id != module.id;
            }, this);
			
			return modules;
		},
		
        /**
        @private
        **/
		_handlePage : function(options) {
			// Left empty by design
		},
		
        /**
        No-op.

        Pre-initialization hook. Intended to be overridden by extending *Modules*.
        @method preInit
        @param {Object} options  configuration options as they were passed to the *Module's* constructor
        **/
		preInit : function(options) {
			// Should be overriden by extending Modules
		},
		
        /**
        No-op.

        Initialization hook. Intended to be overridden by extending *Modules*.
        @method init
        @param {Object} options  configuration options as they were passed to the *Module's* constructor
        **/
		init : function(options) {
			// Should be overriden by extending Modules
		},

        /**
        No-op.

        Post-initialization hook. Intended to be overridden by extending *Modules*.
        @method postInit
        @param {Object} options  configuration options as they were passed to the *Module's* constructor
        **/
		postInit : function(options) {
			// Should be overriden by extending Modules
		},
		
        /**
        @private
        **/
		_init : function(options) {
		},
		
        /**
        Renders the *Module's* template.

        @method renderTemplate
        @param {Object} options configuration options that were passed as parameter to the *Module's* constructor; options are used 
        as template's rendering context, so any `<%= ... %>` tokens work as usual
        **/
		renderTemplate : function(options) {
			if(options.el) {
				var template = options.template || this.template || template;
				var templateStr;
				if(typeof template === 'string') {
					templateStr = _.template(template, options);					
				} else if(typeof template === 'function') {
					templateStr = template(options);
				}
				this.$root = $(templateStr).appendTo($(options.el));
			}
			else {
				this.$root = $('<div></div>').appendTo($('body'));
				this.$el = this.$root;
			}
			
		},
	
        /**
        Registers inner *Modules*. 

        Calls to {{#crossLink "Lightsaber.Web.Module/registerModule:method"}}{{/crossLink}} method for each of the passed
        *Module's* configurations.

        @method registerModules
        @param {Object} moduleConfigs *Modules* configuration, with structure explained at the top of this document
        @param {Boolean} skipHistory whether to not register *Modules* in browser history (for all, instead of one)
        **/
		registerModules : function(moduleConfigs) {
			var moduleConfig;
			if(moduleConfigs) {
				for(var i = moduleConfigs.length - 1 ; i >= 0; i--) {
					moduleConfig = moduleConfigs[i];
					if(moduleConfig.browserHistory === false)
					{
						continue;
					}
					this.registerModule(moduleConfig, this);
				}
			}
		},

        /**
        @private
        **/
		registerModulesWithHistoryFalse : function(moduleConfigs) {
			var moduleConfig;
			if(moduleConfigs) {
				for(var i = moduleConfigs.length - 1 ; i >= 0; i--) {
					moduleConfig = moduleConfigs[i];
					if(moduleConfig.browserHistory === false)
					{
						this.registerModule(moduleConfig, this);
					}
				}
			}
		},
		
        /**
        Registers single innner *Modules*. 

        @method registerModule
        @param {Object} config *Module* configuration, with structure explained at the top of this document
        @param {Lightsaber.Web.Module|Application} parent *Module* that loaded this one (registered it)
        **/
		registerModule : function(config, parent) {
			this.options.parent.registerModule(config, parent);
		},

        /**
        @private
        **/
		registerLocalModule : function(config, parent) {
			var moduleConfig = $.extend(true, {}, config);
			moduleConfig.app = this.options.app;
			moduleConfig.router = this.options.router;
			moduleConfig.parent = parent;
			moduleConfig.regex = this.options.router._routeToRegExp(moduleConfig.id);
			this.registeredModules.push(moduleConfig);
			var cleanId = moduleConfig.id.split('/')[0];
			this.trigger("registered:"+cleanId); //trigger that module is loaded
		},
		
		/**
        Programmatically navigates to the route defined by `route` by calling to
        {{#crossLink "Lightsaber.Core.Router/navigate:method"}}{{/crossLink}} method.

        @method navigate
        @param {String} ID of route ot *Module* to be navigated to/loaded
        @param {Object} options options to be passed to {{#crossLink "Lightsaber.Core.Router/navigate:method"}}{{/crossLink}} method
        **/
		navigate : function(route, options) {
			var config = this._createRouteConfig(options, true);
			this.options.router.navigate(route, config);
		},
		
        /**
        @deprecated
        **/
		loadFragment : function(route, options) {
			this.load(route, options);
		},
		
        /**
        @deprecated
        **/
		openModal : function(route, options) {
			this.load(route, options);
		},
		
        /**
        Programmatically loads a *Module* with ID of `route`.

        @method load
        @param {String} ID of route ot *Module* to be navigated to/loaded
        @param {Object} options options configuration options
        **/
		load : function(route, options) {
			var config = this._createRouteConfig(options);
			var moduleConfig = this._getModuleConfig(route);
			
			if(moduleConfig && moduleConfig.browserHistory===false) {
				this.loadModule(route, config);
			}
			else {
				this.options.parent.load(route, options);
			}		
		},
		
        /**
        Programmatically loads a *Module* with ID of `route`.

        @method load
        @protected
        @param {String} ID of route ot *Module* to be navigated to/loaded
        @param {Object} options options configuration options
        **/
		loadModule : function(route, options) { // TODO may be consolidate with "load"? What to do with options? Pass to module?
			var newRoute = this._calculateNewRoute(route);
			if(this.route.indexOf(route) !== -1) {
				this.lastReloadedRoute = route;
			}

			this.trigger('route:' + newRoute, options);
		},
		
        /**
        @private
        **/
		_defineRoute : function(options) {
			var self = this; // For consistency between fragments and modules (instead of providing "this" as 
							 // the third argument to "on" call).
			this.on('all', function() {
				if(arguments[0].indexOf('route:') === 0) {
					var routes = arguments[0].replace('route:', '').split(self.separator);
					self._handleRoutes(routes, arguments[1]); // options parameter passed to trigger
					self._handleStack();
				}
				else if(arguments[0].indexOf('clear:') === 0) {
					// currently do nothing
				}
			});
		},

        /**
        @private
        **/
		_setDefaultModules : function (modules)
		{
			if(!modules)
			{
				return;
			}
			for(var i = 0; i < modules.length; i++ )
			{
				if(modules[i].isDefault)
				{
					this.defaultModules.push(modules[i].id)
				}
			}
		},

        /**
        @private
        **/
		_loadDefaultChild : function (route,options)
		{
			var moduleConfig;
			var childConfig;
		
			moduleConfig = this._getModuleConfig(route);
			var hash = [];
			if(this.options.app._getHash()!=='')
			{
				hash = this.options.app._getHash().split(this.separator);
			}
			for(var i = 0; i< hash.length;i++)
			{
				childConfig = this._getModuleConfig(hash[i]);//if el occupied no need to reload defaults
				if(childConfig&&moduleConfig.el===childConfig.el)
				{
					return;
				}
			}
			route = this._applyParams(route, this.childParams[moduleConfig.id]);
			this._loadModule(moduleConfig, route, options);
		},

        /**
        @private
        **/
		_reloadDefaultModule : function (route,options)
		{
			var moduleConfig;
			var childConfig;
		
			moduleConfig = this._getModuleConfig(route);
			for(var i = 0; i< this.children.length;i++)
			{
				childConfig = this._getModuleConfig(this.children[i]);//if el occupied no need to reload defaults
				if(moduleConfig.el===childConfig.el)
				{
					return;
				}
			}
			route = this._applyParams(route, this.childParams[moduleConfig.id]);
			this._loadModule(moduleConfig, route, options);
		},

        /**
        @private
        **/
		_reloadDefaultModules : function()
		{
		
			for(var i = 0; i< this.defaultModules.length;i++)
			{
				this._reloadDefaultModule(this.defaultModules[i]);
			}
		},

        /**
        @private
        **/
		_loadDefaultChildren : function(options)
		{
			
			for(var i = 0; i< this.defaultModules.length;i++)
			{
				
				this._loadDefaultChild(this.defaultModules[i]);
			}
		},
		
        /**
        @private
        **/
		_handleStack : function() {
			if(this.navigated) {
				if(this.backPressed) {
					this._updateStack();
					this.backPressed = false;
				}
				else {
					this._addToStack();
				}				
			}
			
			this.navigated = true;
		},
		
        /**
        @private
        **/
		_addToStack : function() {
			if((this.routesStack.length === 0) || (this.routesStack[this.stackPosition].indexOf(this.route)) < 0) {
				this.routesStack.push(this.route);
				this.stackPosition++;
			}
		},
		
        /**
        @private
        **/
		_updateStack : function() {
			if(this.backPressed) {
				this.routesStack = this.routesStack.slice(0, this.stackPosition + 1);
				this._addToStack();
				this.backPressed = false;
			}
		},
		
        /**
        @private
        **/
		_nextInStack : function() {
			this.stackPosition++;
        	return this.routesStack[this.stackPosition] || '';
		},
		
        /**
        @private
        **/
		_prevInStack : function() {
			this.stackPosition--;
        	return this.routesStack[this.stackPosition] || '';
		},

		/**
        No-op. 

        Is called when a **cached** *Module* is loaded.

        Intended to be overridden by the extending *Modules*.

        @method reload
        @protected
        @param {Object} options options configuration options
        **/
		reload : function(options) {
			// May be overriden by extending Modules
		},
		
        /**
        Unloads (inlcuding removing from the parent) the module.
    
        @method reload
        @protected
        @param {Object} options options configuration options
        **/
        unload : function() {
            this._unloadModule();
        },
        
        /**
        Is called when a *Module* is destroyed.

        Intended to be overridden by the extending *Modules*.

        @method reload
        @protected
        @param {Object} options options configuration options
        **/
		destroy : function(options) {
			// Should (!) be overriden by extending Modules
			if(this.$root) {
				delete this.$root;
			}                
			if (this.$el) {               
				delete this.$el;
			}
			this.off();
		},
		
        /**
        No-op. 

        Is called when a *Module* is programmatically loaded after 
        calling {{#crossLink "Lightsaber.Mobile.Module/back:method"}}{{/crossLink}} method.

        Intended to be overridden by the extending *Modules*.

        @method onBack
        @protected
        **/
		onBack : function() {
			// May be overriden by extending Modules
		},
		
        /**
        No-op. 

        Is called when a *Module* is programmatically loaded after 
        calling {{#crossLink "Lightsaber.Mobile.Module/forward:method"}}{{/crossLink}} method.

        Intended to be overridden by the extending *Modules*.

        @method onBack
        @protected
        **/
		onForward : function() {
			// May be overriden by extending Modules
		},
		
        /**
        **Programmatic** back navigation between inner *Modules*. 

        @method back
        **/
		back : function() {
			if(this.stackPosition > 0) {
				this.navigated = false;
				this.backPressed = true;
	        	var newRoute = this._prevInStack();
	        	this.trigger('route:' + newRoute);
	        	this.onBack(newRoute);
			}
			else if(this.stackPosition === 0) {
				this.navigated = false;
				this.backPressed = true;
				this._prevInStack();
				this.trigger('route:' + '');
				this.onBack('');
			}			
        },
        
        /**
        **Programmatic** forward navigation between inner *Modules*. 

        @method back
        **/
        forward : function() {
        	if(this.stackPosition <= this.routesStack.length - 2) {
        		this.navigated = false;
        		var newRoute = this._nextInStack();
            	this.trigger('route:' + newRoute);
            	this.onForward(newRoute);
        	}
        	else {
        		this.backPressed = false;
        	}
        },

        /**
        *Flow Management* specific method. Requests, in context of a step in a flow, a specific
        action to be taken. For more information see {{#crossLink "Lightsaber.Core.FlowManager"}}{{/crossLink}}.

        @method requestAction
        @param {String} action action
        @param {Object} config configuration for the action
        @param {Object} options options for the action
        **/
        requestAction: function(action, config, options) {
        	options = options || {};
        	this.options.router.executeAction(
        		action, 
        		config, 
        		this.options.app, 
                options);
        },

        /**
        *Flow Management* specific method. Requests, in context of a step in a flow, a specific
        action to be taken, **after the current execution stack is cleared**. This is done to allow
        proper initialization of the module, when an action is requested during module's initialization
        process.
        @method queueAction
        @param {String} action action
        @param {Object} config configuration for the action
        @param {Object} options options for the action
        **/
        queueAction: function(action, config, options) {
            var context = this;
            _.defer(function() {
                context.requestAction(action, config, options);
            }, 0);
        },
        /**
        Forwards to {{#crossLink "Lightsaber.Core.Router/getFlowState:method"}}{{/crossLink}} method.

        @method getFlowState
        **/
        getFlowState: function(flowID) {
        	return this.options.router.getFlowState(flowID);
     	},

        /**
        Forwards to {{#crossLink "Lightsaber.Core.Router/getFlowData:method"}}{{/crossLink}} method.

        @method getFlowData
        **/
     	getFlowData: function(key) {
			return this.options.router.getFlowData(key);
		},

        /**
        Forwards to {{#crossLink "Lightsaber.Core.Router/setFlowData:method"}}{{/crossLink}} method.

        @method setFlowData
        **/
		setFlowData: function(key, value) {
			this.options.router.setFlowData(key, value);
		},

        /**
        Forwards to {{#crossLink "Lightsaber.Core.Router/resetFlowData:method"}}{{/crossLink}} method.

        @method resetFlowData
        **/
		resetFlowData: function() {
			this.options.router.resetFlowData();
		},

        /**
        Forwards to {{#crossLink "Lightsaber.Core.Router/deleteFlowData:method"}}{{/crossLink}} method.

        @method deleteFlowData
        **/
		deleteFlowData: function(key) {
			return this.options.router.deleteFlowData(key);
		},

        /**
        Forwards to {{#crossLink "Lightsaber.Core.Router/getFlowConfig:method"}}{{/crossLink}} method.

        @method getFlowConfig
        **/
		getFlowConfig: function(flowID) {
			return this.options.router.getFlowConfig(flowID);
		},

		markStepAs: function(mark) {
			this.options.router.markStepAs(mark, this.options);
		},

		unmarkStepAs: function(mark) {
			this.options.router.unmarkStepAs(mark, this.options);
		},

		clearRoute: function() {
			this.options.app.clearRoute();
		}
        
	});	
	
	// TODO remove after MCSS retrofits.
	Module.extend = function(protoProps, classProps) {
		if(!protoProps.init && protoProps.initialize) {
			protoProps.init = protoProps.initialize;
			protoProps.initialize = Module.prototype.initialize;
		}
		
		return Utils.extend.apply(this, arguments);
	};

	Module.prototype.create = Utils.create;
	
	return Module;
});



define('text!src_web/components/application/view/template/pageTemplate.html',[],function () { return '<div data-role="header"></div>\n<div data-role="content"></div>\n<div data-role="footer"></div>';});


define('text!src/components/application/view/template/pageLoader.html',[],function () { return '<div data-uxf-point="ajaxLoader" class=\'ajaxLoader\'></div>';});

/**
@memberOf Lightsaber.Mobile
@name LoadingView
@private

@class LoadingView
@type View

@description
Used for showing the loading screen when an module/view or application is being loaded.
This reads the configuration file in order to nkow whether is is active or not.

@example
			view = new Lightsaber.BaseFormElementView({
				viewModel : new Lightsaber.ViewModel({}),
				el : testMe,
				config : {
					handleAllAjaxRequests : false
				}
			});
			
@constructor 
@memberOf Lightsaber.Core.View

	@param {boolean} 	[config.handleAllAjaxRequests]	Indicates whether this view will catch all ajax requests from the application
														Application Config can override this setting.
*
*/
define('src/components/application/view/LoadingView',[
	    'jquery',
	    'underscore',
	    'backbone',
		'lightsaber.core',
		'src/core/util/Configuration',
		'text!./template/pageLoader.html'], 
function($, _, Backbone, Lightsaber, Configuration, pageLoaderTemplate) {
	
	/**
	 * @constructor
	 * @memberOf Lightsaber.LoadingView
	 * @augments Lightsaber.View
	 */
		var LoadingView =  Lightsaber.View.extend({
			render: function() {
				if (this.getConfig("handleAllAjaxRequests") != null && this.getConfig("handleAllAjaxRequests") == true) {
					var loadConfiguration = Configuration.get('ShowPageAjaxLoadingIndicator');
					if (loadConfiguration == null || loadConfiguration.show == false) {
						return;
					}
					// adding the loading element to the page
					var loadingTemplate = _.template(pageLoaderTemplate);
					this.$el.append(loadingTemplate());
					// making sure we do not show it until the first AJAX call
					var loadingEl = this.$el.find("[data-uxf-point='ajaxLoader']");
					loadingEl.hide();
					// adding the listeners
					var ajaxTimeoutCall = null;
					loadingEl.ajaxStart(function() {
						loadingEl.show();
						// adding the timeout call if the page gets stuck
						if (loadConfiguration.pageAjaxTimeout != null && loadConfiguration.pageAjaxTimeout > 0) {
							ajaxTimeoutCall = setInterval(function(){
								loadingEl.hide();
							},loadConfiguration.pageAjaxTimeout);
						}
					});

					
					loadingEl.ajaxStop(function() {
						window.clearInterval(ajaxTimeoutCall)
						loadingEl.hide();
					});

					/*
					 * following is for debugging purposes
					var counter = 0;
					loadingEl.ajaxComplete(function() {
						counter --;
						console.log(counter + "-" + 'Triggered ajaxComplete handler.');
					});


					loadingEl.ajaxSend(function(event, jqXHR, ajaxOptions) {
						counter++;
						console.log(counter + "-" + 'Triggered ajaxSend handler. url: ' + ajaxOptions.url);
					});

					loadingEl.ajaxError(function() {
						 console.log(counter + "-" + 'Triggered ajaxError handler.');
					});

					loadingEl.ajaxSuccess(function() {
						 console.log(counter + "-" + 'Triggered ajaxSucccess handler.');
					});
					*/									
				}
			}
			

		});
		
		return LoadingView;
	}
);

/**
Core Web <em>Application</em> component. Normally <strong>is not</strong> intended to be extended.

*Application* component's main purpose is to register pages and connect between them and the *Router*:

```javascript
new Lightsaber.Application({
    router: router,
    modules: [
        {
            el: '#main', 
            title: 'Main Page',
            path: 'app/pages/MainPage'
        },
        {
            el: '#page1', 
            title: 'Page 1', 
            path: 'app/pages/Page1'
        }
    ]
});
```
@class Lightsaber.Web.Application
@namespace Lightsaber.Web
@module Lightsaber.Web
@extends Lightsaber.Web.Navigation

@since 9.0.0

@requires jquery
@requires backbone
@requires Lightsaber.Core.Utils
@requires Lightsaber.Core.ViewModel
@requires Lightsaber.Web.Module
@requires Lightsaber.Web.Navigation
@requires Lightsaber.Core.Utils

@examples none
@guides ["Core Concepts/Application and Navigation"]

@param {Object} [options] the <em>Module</em> configuration object
**/
define('src_web/components/application/view/Application',[
	'jquery',
	'underscore',
	'backbone',
    './Module',
    'src_web/components/application/view/Navigation',
    'src/core/util/Utils',
    'src/core/viewModel/ViewModel',
    'text!./template/pageTemplate.html',
    'src/components/application/view/LoadingView'
], function($, _, Backbone, Module, Navigation, Utils, ViewModel, template, LoadingView) {
		

	var Application = Navigation.extend({


		isApp: true, 
        config: {},
		
		/**
		Main-entry method for the *Application*.

		The method does the following:

		* register all flows
		* register all *Modules*
		* trigger `loaded:<id>` event with this *Module's* ID

		@method initialize
		@protected
		@param {Object} options configuration options received by *Router's* constructor
		**/
		initialize : function(options) {	
			this.options.router.app = this;
			this.separator = '/#!/';
			this.routeToTarget = {};
			this.registeredModules = [];
			this.urlMap = {};
			this.children = []; //stores children loaded by this module
			
			this.route = '';

			this._init(options); 
			var flows = this.options.router.configuration.flows;
			this.registerFlows(flows);
			this.registerModules(this.configuration.modules);			
			this._loadDefaultModule();
			this.init(options);
		},		
		
		/**
        No-op.

        Initialization hook. Intended to be overridden by extending *Application*.
        @method init
        @param {Object} options  configuration options as they were passed to the *Module's* constructor
        **/
		init : function(options) {
			// Should be overriden by extending Modules
		},
		
		/**
        @private
        **/
		_init : function(options) {
			Backbone.history.start({root : '', pushState : false});
			this.configuration = $.extend(true, {}, options);			
			this.configuration.modules = this.configuration.modules || this.configuration.pages || {};
		},

        /**
        Returns the value of a configuration property defined by `key`.

        @method getConfig
        @param {String} key key that represents the property
        @returns {...} configuration property value
        **/
        getConfig: function(key) {
            return arguments.length === 0 ? this.config : this.config[key];
        },

		/**
        @private
        **/
		_getFlowsConfig: function() {
			var config = {};
			if(this.options && this.options.router && this.options.router.configuration && this.options.router.configuration.flows) {
				config = this.options.router.options.flows;
			}

			return config;
		},

		/**
        Registers flows. 

        Calls to {{#crossLink "Lightsaber.Mobile.Application/registerFlow:method"}}{{/crossLink}} method for each of the passed flows.

        @method registerFlows
        @param {Object} flowsConfig flows configuration
        **/
		registerFlows: function(flowsConfig) {
			var moduleConfig, flow;
			this.options.router.fm.resetFlows();
			if(flowsConfig && flowsConfig.flows) {
				for (var i = 0; i < flowsConfig.flows.length; i++) {
					flow = flowsConfig.flows[i];
					for(var j = 0; j < flow.steps.length; j++) {			
						moduleConfig = $.extend(true, {}, flow.steps[j]);
						moduleConfig.originalStepID = moduleConfig.id;
						moduleConfig.flowID = flow.id;
						moduleConfig.id = '[' + flow.id + '/' + moduleConfig.id + ']';
						moduleConfig.flowConfig = flow;
						this.registerModule(moduleConfig, this);
						this._storeModuleURL(moduleConfig);
					}
					this._processFlow(flow);
				};
			}
		},

        /**
        Registers *single* flow. 

        Calls to {{#crossLink "Lightsaber.Mobile.Application/_processFlow:method"}}{{/crossLink}} method for each of the passed flows.

        @method registerFlow
        @param {Object} flowsConfig flow configuration
        **/
        registerFlow: function(flowsConfig) {
            
        },


		/**
		Processes a new flow in the application.

		Registering a flow allows to connect a set of independent steps into one flow, that shares data and
		reacts based on that data (if necessary) according to a set of pre-defined rules for some (or all) steps.

		@method _processFlow
        @protected
		@param {Object} flow flow to register, of structure similar to:

		```javascript
		{
			"flows": [
				{	
					"id": "flow1",
					"steps": [
						...
						{
							"id": "step3",
							"el": "[data-uxf-point='content']",
							"path": "app/flows/flow1/steps/Step1Module",
							"next": "step4",
							"prev": {
								"default": "step3",
								"rules": [
									{
										"condition": "...", 
										"target": "step1" 						
									},
									...
								]
						}
						...
					]
				}
			]
		}
		```

		**/
		_processFlow: function(flow) {
			if(this.options && this.options.router && this.options.router.fm) {
				this.options.router.fm.registerFlow(flow);
			}
		},

		/**
		Registers inner *Modules*. 

		Calls to {{#crossLink "Lightsaber.Mobile.Module/registerModule:method"}}{{/crossLink}} method for each of the passed
		*Module's* configurations.

		@method registerModules
		@param {Object} moduleConfigs *Modules* configuration
		**/
		registerModules : function(moduleConfigs) {
			var moduleConfig;
			if(moduleConfigs) {
				for(var i = moduleConfigs.length - 1 ; i >= 0; i--) {
					moduleConfig = moduleConfigs[i];
					this.registerModule(moduleConfig, this);
					this._storeModuleURL(moduleConfig);
				}
			}
			this._defineRoute();
		},
		
		/**
        Registers single inner *Modules*. 

        @method registerModule
        @param {Object} config *Module* configuration
        @param {Lightsaber.Mobile.Module|Application} parent *Module* that loaded this one (registered it)
        **/
		registerModule : function(moduleConfig, parent) {
			moduleConfig.path = moduleConfig.module || moduleConfig.path; // TODO see if the module is an instance
			
			moduleConfig.app = this;
			moduleConfig.router = this.options.router;
			moduleConfig.parent = parent;
			moduleConfig.regex = this.options.router._routeToRegExp(moduleConfig.id);
			this.registeredModules.push(moduleConfig);
			var cleanId = moduleConfig.id.split('/')[0];
			this.trigger("registered:"+cleanId); //trigger that module is loaded
		},

		/**
		@private
		**/
		_storeModuleURL: function(moduleConfig) {
			if(moduleConfig.url) {
				this.urlMap[moduleConfig.url] = moduleConfig.id;
			}
		},
		
		/**
		@private
		**/
		_loadDefaultModule : function() {			
			var result = this._getRouteByURL();
			var moduleConfig = this._getModuleConfig(result.route);
			this.queryParams = result.queryParams;
			this._augmentModuleDefaultTemplate(moduleConfig);
			this._loadPageModule(moduleConfig);
		},
		
		/**
		@private
		**/
		_getRouteByURL : function() {
    		var result = {}, param, pathParts, origPathName = pathName = window.location.href.replace(window.location.hash, ''), url; // TODO validate
    		origPathName = pathName = decodeURI(pathName);
    		pathParts = decodeURI(window.location.search);
			if(pathParts) {
				result.queryParams = {};
				pathName = pathName.replace(pathParts, '');
				pathParts = pathParts.slice(1).split('&');
				for (var i = 0; i < pathParts.length; i++) {
					param = pathParts[i].split('=');
					if(param) {
						if(param.length === 1) {
							result.queryParams[$.trim(param[0])] = $.trim(param[0]);
						} else if(param.length > 1) {
							result.queryParams[$.trim(param[0])] = $.trim(param[1]);
						}
					}
				};
			}

    		if (pathName.substr(-1) === '#') {
				pathName = pathName.substring(0, pathName.length - 1);
			}	
			var index = pathName.lastIndexOf('/') + 1;
			var id = index != pathName.length ? pathName.substring(index) : 'index.html';
			
    		result.route = this._findRoute(id, pathName, origPathName);

    		return result;
    	},

    	/**
		@private
		**/
    	_findRoute: function(id, pathName, origPathName) {
    		var resultRoute = this.urlMap[id];

			if(!resultRoute) {
				for(var urlID in this.urlMap) {
	    			if(urlID.split('#')[0] === id) {
	    				resultRoute = this.urlMap[urlID];
	    				break;
	    			}
	    		}
			}

    		if(!resultRoute) {
    			for(var route in this.options.router.routes) {
        			if(this.options.router.routes[route].path === id) {
        				resultRoute = route;
        				break;
        			}
        		}
    		}

    		if (origPathName.substr(-1) === '#') {
				origPathName = origPathName.substring(0, origPathName.length - 1);
			}	
			var index = origPathName.lastIndexOf('/') + 1;
			id = index != origPathName.length ? origPathName.substring(index) : 'index.html';

    		if(!resultRoute) {
    			for(var qproute in this.options.router.routes) {
        			if(this.options.router.routes[qproute].path === id) {
        				resultRoute = qproute;
        				break;
        			}
        		}
    		}

    		return resultRoute;
    	},

    	/**
		@private
		**/
    	_augmentModuleDefaultTemplate : function(moduleConfig) {
			if(moduleConfig.template !== false) {
				moduleConfig.defaultTemplate = moduleConfig.template || this.pageTemplate || template;
			}			
		},
		
		/**
		@private
		**/
		_loadPageModule : function(moduleConfig) {
			this.children.push(moduleConfig.id);//update children list with loaded module
			// setting the loading screen for pages
			new LoadingView({
				viewModel : new ViewModel({}),
				el : $("body"),
				config : {
					handleAllAjaxRequests : true
				}
			});
			if(moduleConfig.module) {	
				// Instantiate existing module
				moduleConfig.hash = this._getHash();
				moduleConfig.instance = new moduleConfig.module(moduleConfig); 
				moduleConfig.instance._triggerFlowEvent('flow:load:step');
	        }
	        else if(moduleConfig.path) {
	        	// Load the module by its path using RequireJS
                requirejs([moduleConfig.path], _.bind(function(Module) { 
                	moduleConfig.hash = this._getHash();
                	moduleConfig.instance = new Module(moduleConfig);
                	moduleConfig.instance._triggerFlowEvent('flow:load:step');
	 	        }, this));
	        }
	        else { 
	        	// Instantiate default module
	        	moduleConfig.hash = this._getHash();
	        	moduleConfig.instance = new Module(moduleConfig); 
	        	moduleConfig.instance._triggerFlowEvent('flow:load:step');
	        }
		},
				
		/**
        Programmatically navigates to the route defined by `route` by calling to
        {{#crossLink "Lightsaber.Core.Router/navigate:method"}}{{/crossLink}} method.

        @method navigate
        @param {String} ID of route ot *Module* to be navigated to/loaded
        @param {Object} options options to be passed to {{#crossLink "Lightsaber.Core.Router/navigate:method"}}{{/crossLink}} method
        **/
		navigate : function(route, options) {
			var config = this._createRouteConfig(options, true);
			this.options.router.navigate(route, config);
		},
		
		/**
        Programmatically loads a *Module* with ID of `route`.

        @method load
        @param {String} ID of route ot *Module* to be navigated to/loaded
        @param {Object} options options configuration options
        **/
		load : function(route, options) {
			var config = this._createRouteConfig(options);
			this.loadModule(route, config);
		},
		
		/**
		@private
		**/
		loadModule : function(route, options) {
			var newRoute = this._calculateNewRoute(route, options); // TODO called twice per load???
			this.lastReloadedRoute = route;
			if(newRoute === this.route)
			{
				Backbone.history.loadUrl(newRoute);
			}
			else {
				this.options.router.navigate(newRoute, options); 
			}   
		},
		
		/**
        @private
        **/
		_defineRoute : function() {
			var self = this;
			this.configuration.router.route('*all', '', function() {
				var routes = '';
				if(arguments[0]) {
					routes = arguments[0].split(self.separator);
				}
				
				self._handleRoutes(routes);
			});
		
		},

		/**
        @private
        **/
		clearRoute: function() {
			this.route = '';
		}
		
	});
	
	Application.extend = Utils.extend;
	
	return Application;
});
define('src_web/components/application/view/PopupModule',[
	'underscore',
	'lightsaber.core',
	'./Module',
	'src/components/popup/view/PopupView'
], 
function(_, Lightsaber, Module, PopupView ){
	
	var PopupModule = Module.extend({
		
		config : {
            closeIcon: false,
            closeText: false,
            sync:true,
            closeTitle: false
			
        },
        
		init : function(options){
			if(options.template !== false) {
				this.$el.append(options.template || this.template || options.defaultTemplate);
			}
			
            _.bindAll(this,'_createContent','initContent', '_onClose', 'close');
            this.popupViewModel = new Lightsaber.ViewModel();
            
            this.config.createContent = _.bind(function(){return this.$el}, this);
            this.config.beforeClose = this._onClose;
            
            this.popupView = new PopupView({
                viewModel : this.popupViewModel,
                config: this.config
            });
			this.popupView.close = this._onClose;
			this.popupView.on('popup:show', this._createContent, this);
			this.popupView.render();
        },
        
		_createContent : function(context){
			this.initContent(this.options);
		},
		
        initContent : function(options){
            
        },

        _onClose : function(){
			this.destroy && this.destroy();
			this.options.onClose && this.options.parent[this.options.onClose] && this.options.parent[this.options.onClose].call(this.options.parent);
			this.close();
        },
		
		close : function(){
			PopupView.prototype.close.call(this.popupView);
		},
		
		center : function(){
			this.popupView.$el.dialog('option', 'position', 'center');
		},
		
		/**
		 * Change the pop-up header title
		 * @param {String} title
		 * Pop-up title to set
		 */
		setHeaderTitle : function(title){
			this.popupView.$el.dialog('option', 'title', title);
		},

		destroy : function(options) {
			this.close();
		}
	});		
	
    	return PopupModule;
	
});

/**
 * @memberOf Lightsaber.Web
 * @name TableView
 * @class TableView
 * @type View
 * 
 * @description
 * Provides visual representation for Table web layout. 
 * @constructor
 * @memberOf Lightsaber.Web.TableView
 * @param {Boolean} [autoRender=false] indication whether to render the <strong>View</strong> automatically
 * @param {Array} [config.colModel] Array list of columns to use.
 * @param {Array} [config.searchitems] Array  list of columns to use for searching the results. Default : false.
 * @param {String} [config.sortname] initial column to sort on. Not necessary to give. But it should be same as defined in model.
 * @param {Boolean} [config.usePager='false'] indication to turn on or off page navigation buttons.
 * @param {Boolean} [config.singleSelect='false'] indication that only one row can be selected at a time.
 * @param {String} [config.title] title which will appear at the top of the grid.
 * @param {Boolean} [config.showTableToggleBtn=true] indication to enable/disable minimization of the grid with an icon in the top right corner.
 * @param {Array} [config.buttons] Array list of buttons on top of grid specifying a callback function.
 * @param {nowrap} [config.nowrap=false] indication whether to wrap the contents of the cell.
 * @param {height} [config.height=''] height of table widget
 *   
 * @example
 * var ItemModel = Lightsaber.Core.Model.extend({});
 * ItemModel.idAttribute = "iso";
 * var MyColl = Lightsaber.Core.Collection.extend({ model: ItemModel });
 * var rowsModel = new MyColl( null, {
 * 		url: 'get/rows', 
 * 		rest: { readPage: {method:'GET', supportsPagination:true, supportsSorting:true, supportsFiltering:true }},
 * 		pagination: { pageSize: 5 },
 * 		sorting : { fieldName : 'iso', asc : true }
 * });
 * var viewModel = new Lightsaber.TableViewModel({
 * 		models : {items : rowsModel},
 * 		config : { autoUpdate : true }
 * });
 * var tableView = new Lightsaber.TableView({
 * 		viewModel : viewModel,
 * 		config : { 
 * 			dataType: 'json',
 * 			el : $("#flex1"),		
 * 			colModel : [{display: 'ISO', name : 'iso', width : '15%', sortable : true, align: 'center'},
 * 				{display: 'Name', name : 'name', width : '15%', sortable : true, align: 'left'},
 * 				{display: 'Printable Name', name : 'printable_name', width : '15%', sortable : true, align: 'left'},
 * 				{display: 'ISO3', name : 'iso3', width : '15%', sortable : true, align: 'left'},
 * 				{display: 'Number Code', name : 'numcode', width : '15%', sortable : true, align: 'right'}],
 * 			rpOptions: [5,10,15,20],
 * 			rp : 5,
 * 			usepager: true,
 * 			title: 'Countries',
 * 			showTableToggleBtn: true,
 * 			buttons : []
 * 		}		
 * });
 * rowsModel.fetch();
 * @example
 * The JSON example:
 * 		[	{"iso":"ZW","name":"Zimbabwe", "printable_name" : "Zimbabwe", "iso3" : "ZWE", "numcode" : "716"},
 * 		{"iso":"AF","name":"Afghanistan", "printable_name" : "xyz", "iso3" : "AFG", "numcode" : "4"},
 * 	    {"iso":"IQ","name":"Israel", "printable_name" : "abc", "iso3" : "IL", "numcode" : "1"},
 * 	    {"iso":"IN","name":"India", "printable_name" : "pqr", "iso3" : "IN", "numcode" : "5"},
 * 	    {"iso":"ZM","name":"Zambia", "printable_name" : "Zambia", "iso3" : "ZMB", "numcode" : "894"}	]
 */
define('src_web/components/ftable/view/TableView',[
  'jquery', 
  'flexigrid',
  'underscore',
  'lightsaber.core'
], function($, flexigrid, _, LightsaberCore) {

	
	var tableView = LightsaberCore.View.extend({

		
		publicMethods : ['refresh'],
		/**
		 * Default values
		 */
		config : {
			autoRender : false,
			//searchitems : [],
			sortname : '',
			usePager : true,
			dataType : 'json',
			onReload: false,
			onChangePageSize: false,
			onChangePage : false,
			onRpChange : false,
			nowrap : false,
			height : ''
			
		},
		/**
		 * @methodOf Lightsaber.Web.TableView
		 * @name initialize
		 * @description Initializes the TableView view according to a given configuration.
		 * @param {Object} options the configuration options
		 */
		initialize: function() {			
			_.bindAll(this, 'render', 'refresh', '_getData', 'convertToFGFormat');
			var colModels = this.getConfig('colModel');
			var that = this;
			// To set percentage width into pixels - start
			var totalWidth = this.getConfig('width');
			if(!totalWidth) // Total width not set. Get width of document
				totalWidth = $(document).width();
			if(colModels)
				for(var i=0;i<colModels.length;i++){ // Calculate width of column from percentage to pixel.
					var width = colModels[i].width;
					if(typeof(width)!='number' && width.substring(width.length-1, width.length)=='%'){ // If "%" symbol is present then only convert it to pixel otherwise not.
						width = width.substring(0,width.length-1);
						colModels[i].width = ((width/100)*totalWidth);
					}
				}
			// To set percentage width into pixels - end
			
			this.setConfig("usePager",this.getConfig("usePager"));
			
			// To break long string while wrapping the contents of cell - start
			if(colModels)
				for(var i=0;i<colModels.length;i++){ 
					var process= colModels[i].process;
					if(!process){
						colModels[i].process = function(tdDiv, pid){
								$(tdDiv).css('word-wrap','break-word');
							}
					}
				}
			// To break long string while wrapping the contents of cell - end
			
			// listens for events on viewmodel.
			this.viewModel.on('items:loaded', this.render, this);			
			this.viewModel.on('items:refreshed', this.refresh, this);
			// To set the pagination
			if(this.viewModel._getPagination()){
				this.setConfig('rp',this.viewModel._getPagination().pageSize);
				this.setConfig('usepager',true);
				this.viewModel.on('items:paginated', this.paginated, this);
				this.setConfig('onChangePage',function(pageNum){that.viewModel.gotoPage(pageNum-1);});
			}else{
				this.setConfig('usepager',false);
			}
			// To apply page size change in flexigrid
			if(!this.getConfig('onRpChange'))
				this.setConfig('onRpChange',function(pageSizeVal){
					if(!_.isNumber(pageSizeVal))
						pageSizeVal = Number(pageSizeVal);
					that.setConfig('rp',pageSizeVal);
					that.$el.flexOptions(that.getConfig());
					that.viewModel.setPageSize(pageSizeVal)
				});
			// To apply soring options to Flexigrid
			if(this.viewModel._getSorting()){
				var sorting = this.viewModel._getSorting();
				this.setConfig('sortname', sorting.fieldName);
				this.setConfig('sortorder', (sorting.asc)?'asc':'desc');
				if(!this.getConfig('onChangeSort'))
					this.setConfig('onChangeSort', function(name, order) { 
						that.viewModel._setSorting({ fieldName : name, asc : (order=='asc')? true : false});
					});
			}	
		},
		/**
		 * @methodOf Lightsaber.Web.TableView
		 * @name paginated
		 * @description This method is used to paginate the data.
		 * @param {Object} data: The data which is returned by viewModel.
		 */
		paginated : function(data) {
			data = this._getData(data);	
			this.$el.flexAddData(data);
		},
		/**
		 * @methodOf Lightsaber.Web.TableView
		 * @name render
		 * @description This method is used to render table and loads data in it.
		 * @param {Object} data: The data which is returned by viewModel.
		 */
		render : function(data) {
			var g = ((this.$el.flexigrid(this.getConfig()))[0]).grid;
			var that = this;
			/**
			 *  The below code is Flexigrid dependent. (Adopted version : 1.1)
			 *  The newer versions might affect the events which are modified. 
			 */
			// To change the event of Reload/Refresh in flexigrid.
			$('.pReload', g.pDiv).unbind();
			if(this.getConfig('onReload')){
				$('.pReload', g.pDiv).click(function () {
					that.getConfig('onReload')();
				});
			}else{
				$('.pReload', g.pDiv).click(function () {
					that.viewModel._resetData();
				});
			}
			
					
			/**
			 * Dependent code ends here.
			 */
			data = this._getData(data);	
			this.$el.flexAddData(data);
		},
		/**
		 * @methodOf Lightsaber.Web.TableView
		 * @name refresh
		 * @description Refreshes data present in table to reflect data as per sort criteria mentioned using field name on TableViewModel.
		 * @param {Object} data: The data which is returned by viewModel.
		 */
		refresh : function(data) {	
			data = this._getData(data);
			this.$el.flexAddData(data);
		},
		/**
		 * @methodOf Lightsaber.Web.TableView
		 * @name _getData
		 * @description This method invokes the function that converts the data in Flexigrid Compatible format.
		 * @param {Object} data: The data which is returned by viewModel.
		 */
		_getData : function(data) {
			return this.convertToFGFormat(data);
		},
		/**
		 * @methodOf Lightsaber.Web.TableView
		 * @name convertToFGFormat
		 * @description This method converts returned JSON data into FlexiGrid compatible format.
		 * 	The method only returns  rows in json format. The other required attributes of the object are placed at runtime as page number changes.
		 * @param {Object} data: The data which is returned by viewModel.
		 * @Format
		 * 		{rows : [{ id : <value>, cell : [ <values present in the row>] },
		 *	      	 		..
		 *	      	 		..
		 *	      	 		..
	     *        		],
		 *		page : <value>,
		 *		total : <value>
		 *		}      
		 *		e.g.
		 *		{"rows":[{"iso":"ZW","name":"Zimbabwe", "printable_name" : "Zimbabwe", "iso3" : "ZWE", "numcode" : "716"},
	  	 *				 {"iso":"AF","name":"Afghanistan", "printable_name" : "xyz", "iso3" : "AFG", "numcode" : "4"},
	  	 *				 ...
	  	 *				 ...
		 *		        ],
		 *		  "page":1,
		 *		  "total" : 2       
		 *		}
		 */
		 convertToFGFormat : function(data)
		 {
			var idIndx =1, row, rows, cell;
			rows = new Backbone.Collection;
			_.each(data.items, function(obj){
				cell = _.values(obj);
				row = {id : idIndx++, cell : cell};
				rows.add(row);
			});
			 
			if (data.paginationInfo) {
				return {rows :rows.toJSON() , page : data.paginationInfo.pageNum+1, total : data.paginationInfo.totalSize};
			} else {
				return {rows :rows.toJSON() , page : 0, total : rows.length};
			}
		 },

        destroy : function(clearVM) {
            this.binding.unbind();
            
            if (clearVM)
                Backbone.Events.off.call( this.viewModel, null, null, this);
            else
                this.viewModel.off(null, null, this);
            if(this.root && this.viewModel.observe) {
                KO.cleanNode(this.root);
            }
            
            this.remove();
            this.off();
            this.undelegateEvents();
            if(this.subViews) {
                for(var i in this.subViews) {
                    this.subViews[i].viewInstance && this.subViews[i].viewInstance.destroy();
                    delete this.subViews[i].viewInstance;
                    delete this.subViews[i];
                }
            }
            if(this._subViews) {
                for(var i in this._subViews) {
                    this._subViews[i].instance && this._subViews[i].instance.destroy();
                    delete this._subViews[i].instance;
                    delete this._subViews[i];
                }
            }

            if(this.___children) {
                for (var i = this.___children.length - 1; i >= 0; i--) {
                    if(this.___children[i]) {
                        this.___children[i].destroy();
                        delete this.___children[i];
                    }
                };

                delete(this.___children);
            }

            if(this.viewModels) {
                for (var i = this.viewModels.length - 1; i >= 0; i--) {
                    if(this.viewModels[i]) {
                        this.viewModels[i].off(null, null, this);
                        delete this.viewModels[i];
                    }
                };
            }
        }
});
return tableView;
});

define('text!src/components/progressbar/view/template/progressBar.html',[],function () { return '<div data-role="progressbar" class="uxf-progressbar clearfix" style="width: 100%; display: none;">\n\t<div data-uxf-point="progress" class="ui-widget-header" style="float: left; height: inherit; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box;">\n\t\t<div class="progress-text"><span class="uxf-pbSpan-value"><%=valueText%><%=units%></span></div>\n\t</div>\n\t<div data-uxf-point="remaining" class="ui-widget-content" style="float: left; height: inherit; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box;">\n\t\t<div class="progress-remaining-text"><span class="uxf-pbSpan-remaining"><%=remainingText%><%=units%></span></div>\n\t</div>\n</div>\n';});

/**
<em>ProgressBar</em> component.

## Main template

```html
<div data-role="progressbar" class="uxf-progressbar">
    <div data-uxf-point="progress" class="ui-widget-header">
        <div class="progress-text">
            <span class="uxf-pbSpan-value">
                <%=valueText%><%=units%>
            </span>
        </div>
    </div>
    <div data-uxf-point="remaining" class="ui-widget-content">
        <div class="progress-remaining-text">
            <span class="uxf-pbSpan-remaining">
                <%=remainingText%><%=units%>
            </span>
        </div>
    </div>
</div>
```

@class Lightsaber.Mobile.ProgressBarView
@namespace Lightsaber
@module Lightsaber.Mobile
@extends Lightsaber.Core.View

@since 9.0.0

@requires jQuery
@requires Underscore
@requires Lightsaber.Core  

@constructor
@param {Object} [options] constructor's only parameter
@param {Object} [options.config] main configuration parameter
@param {String} [options.config.template=progressBarTemplate] main <em>ProgressBar's</em> template  
@param {String} [options.config.autoRender=false] whether *ProgressBar* should render immediately or wait for data from *ViewModel* 
@param {String} [options.config.vmKeys={...}] mapping of expected name of <em>ViewModel</em> properties. 
By default the values are: `{'data.value' : 'value',    'data.maxValue' : 'maxValue'}`
@param {String} [options.config.vmKeysChangeEvents={...}] mapping of expected name of <em>ViewModel</em> events' handlers. 
By default the values are: `{'data.value' : '_handleValuesUpdate',  'data.maxValue' : '_handleValuesUpdate'}`. What that means is that,
when an event called `change:maxValue` is triggered by the *ViewModel* - this is its handler
@param {String} [options.config.precision=0] number, between 0 and 20, that defines the number of 
@param {String} [options.config.units='%'] defines the units to present
digits to appear after decimal point, when `config.units` are % and ignored otherwise
property to its actual name in the specific <em>ViewModel</em> that this <em>View</em> 
receives at runtime.
**/
define('src/components/progressbar/view/ProgressBarView',['jquery',
        'lightsaber.core',
        'underscore',
        'text!./template/progressBar.html'], 
function($, LightsaberCore, _,progressBarTemplate) {

    
    
    
	var ProgressBarView = LightsaberCore.View.extend({

	    
		publicMethods : ['animate'],
		template : progressBarTemplate,
		config : {
			autoRender : false,
			precision : 0
		},
		vmKeys : {
			"data.value" : "value",
			"data.maxValue" : "maxValue"
		},
		vmKeysChangeEvents: {
			"data.value" : "_handleValuesUpdate",
            "data.maxValue" : "_handleValuesUpdate"
        },

        defaultUnits : '%',
        defaultMax : 100,
        
        /**
        Main-entry method. The only function is to pre-compile *ProgressBar* template.

        Should be overriden if a different behaviour (aside from simple addition of `ui-state-active` CSS class) is needed.

        @method initialize
        @protected
        **/
        initialize : function(options){
            if (!_.isFunction(this.template)) {
                this.template = _.template(this.template);
            }
        },
        
        /**
        Handles data events from *ViewMode*.

        Should be overriden if a different behaviour is needed.

        @method _handleValuesUpdate
        @protected
        **/
        _handleValuesUpdate : function() {
            if((typeof this._getVMData('data.value') !== 'undefined') && (typeof this._getVMData('data.maxValue') !== 'undefined')) {
                this.render();
                this.$root.show();              
            }
        },
        
        /**
        Calls to `_calculate`.

        Should be overriden if a different behaviour is needed.

        @method _preRender
        @protected
        **/
        _preRender : function() {
            this._calculate();
        },
        
        /**
        Calculates the % value (if applicable - `units` are `%`).

        @method _calculate
        @protected
        **/
        _calculate : function() {
            this.data = {};
            
            var remainingValue = 0,
                valueText = this._getVMData('data.value'),
                value = Math.abs(valueText),
				maxValueText = this._getVMData('data.maxValue'),
				maxValue = Math.abs(maxValueText),
				configUnits = this.getConfig('units'),
				units = configUnits || this.defaultUnits;
			
			if(!maxValue || maxValue < value) {
				if(value < this.defaultMax) {
					maxValue = this.defaultMax;
					maxValueText = maxValue;
					remainingValue = maxValue - value;
					units = this.defaultUnits;
				}
				else {
					maxValue = value;
					maxValueText = maxValue;
				}
			}
			else {
				remainingValue = maxValue - value;
			}
			           
			this.data.value = value/maxValue * this.defaultMax;
			this.data.remaining = (remainingValue)/maxValue * this.defaultMax;
            
            if(this.getConfig('renderText') !== false) {
            	this.data.units = units;
            }
            else {
            	this.data.units = '';
            }
                        
            if(!configUnits || configUnits === this.defaultUnits){
            	this.data.valueText = this.data.value.toFixed(this.getConfig('precision'));
            	this.data.maxValueText = this.defaultMax;
            }
            else {
                this.data.valueText = value;
                this.data.maxValueText = maxValue;
            }
            
            if(!configUnits || configUnits === this.defaultUnits){
                this.data.remainingText = (this.data.maxValueText - this.data.valueText).toFixed(this.getConfig('precision'));
            }
            else {
                this.data.remainingText = (this.data.maxValueText - this.data.valueText)
            }
        },
        
        /**
        Animates the *ProgressBar*.

        Should be overriden if a different behaviour is needed.

        @method animate
        @protected
        **/
        animate : function() {
            if(this.data.value === 0){
                this.$root.find("[data-uxf-point='progress']").hide();
            }
            else{
                this.$root.find("[data-uxf-point='progress']").show().animate({ width : this.data.value + '%'}, 800);
            }
            this.$remaining = this.$root.find("[data-uxf-point='remaining']");
            if(this.data.remaining === 0){
                this.$remaining.hide();
            }
            else{
                this.$remaining.show().animate({ width : this.data.remaining + '%'}, 800);
            }
        },

        /**
        @protected
        **/        
        _applyTheme : function() {
            var theme = this.$root.attr('data-theme');
            if(theme) {
                this.$remaining.removeClass('ui-btn-down').addClass('ui-btn-down-' + theme);
            }
        },
        
        /**
        Animates the *ProgressBar*.

        Should be overriden if a different behaviour is needed.
        
        @method animate
        @protected
        **/
        _handleTemplate : function() {
            var template, data = this.data;
            if(this.getConfig('renderValues') === false) {
                data = {valueText : '&nbsp;', units : '', remainingText : '&nbsp;'};
            }
            template = this.template(data);
            this.$root && this.$root.remove();
            this.placeRoot(template);
        },
        
        /**
        injects the values calculated in `_calculate` into *ProgressBar* DOM and, in applicable, animates them.

        Should be overriden if a different behaviour is needed.

        @method _postRender
        @protected
        **/
        _postRender : function() {
            if ( !_.isUndefined(this.data.value) && !_.isUndefined(this.data.remaining) ) {
                this.$root.show();
            }

            if(this.getConfig('animate') !== false && this.getConfig('animate') !== 'false') {
				this.animate();
			}
			else {
				this.$root.find("[data-uxf-point='progress']").css('width', this.data.value + '%');
                this.$remaining = this.$root.find("[data-uxf-point='remaining']").css('width', this.data.remaining + '%');
            }
            
            this._applyTheme();     
        },
        
        /**
        @method _enhanceMarkup
        @protected
        **/
        _enhanceMarkup : function(){
            this.$root.trigger('create');
        }
    });

    return ProgressBarView;

});

define('text!src_web/components/accordion/view/template/AccordionTemplate.html',[],function () { return '<div class="uxf-accordion"></div>';});


define('text!src_web/components/accordion/view/template/AccordionCollapsibleTemplate.html',[],function () { return '<div data-uxf-point="collapsible" data-collapsed="true" data-id="<%=id%>">\n\t<div data-uxf-point="collapsible-title" class="ui-state-default" style="cursor: pointer; padding: 0.5em;"><span><%=name%></span></div>\n\t<div data-uxf-point="collapsible-content"><span>Some text for Collapsible #<%=id%></span></div>\n</div>\n';});

/**
<em>Accordion</em> component.  

*Accordion* widget provides vertically stacked list of panes, where each pane may have a header and a content and may be expanded and collapsed by clicking on the header. The *Accordion* may be configured to allow only one pane to be expanded at a time (where the currently expaned pane is closed, when a different one's header is clicked) or it may allow to expand any number of panes.

*Accordion* allows to dynamically define the collapsible panes (via *ViewModel* containing a corresponding array). 
Population of the panes of the *Accordion* is responsibility of the *Accordion's* creator and
is not performed automatically. *Accordion* is merely a layout
component with some presentation logic added in - hiding and showing corresponding pane when
a header is clicked.

A simple example below demonstrates the creation of an *Accordion* widget using static data stored in a *Collection* and passed to the Accordion through *CollectionViewModel*:

```javascript
var collection = new Lightsaber.Core.Collection([
    {id: '1', name: 'Title 1'},
    {id: '2', name: 'Title 2'},
    {id: '3', name: 'Title 3'},
    {id: '4', name: 'Title 4'}
]);

var collectionViewModel = new Lightsaber.CollectionViewModel({
    models: { data: collection }
});

var accordionView = new Lightsaber.AccordionView({
    el: $root,
    viewModel: collectionViewModel
});
```

Additional features include ability to "pre-expand" some of the panes using `expanded` config attribute:

```javascript  
var accordion = new Lightsaber.AccordionView({
    el: $root,
    config: {              
        expanded: ['1', '3']
    },
    viewModel: collectionViewModel
});
```

Also, `expandableAll` configuration property, which governs whether more than one collapsible pane may be opened at once, is provided. Note that, while `expandableAll` default value is `false`, when the value is not provided - the first fallback option is provided via *Accordion's* template through the `data-expandable-all` attribute, which can be `false` or `true`:

```javascript
var accordion = new Lightsaber.AccordionView({
    el: $root,
    config: {
        expandableAll: false
    },
    viewModel: collectionViewModel
});
```

## Main template

```html
<div class="uxf-accordion"></div>
```

## Collapsible template

```html
<div data-uxf-point="collapsible" data-collapsed="true" data-id="<%=id%>">
	<div data-uxf-point="collapsible-title" class="ui-state-default" style="cursor: pointer; padding: 0.5em;">
		<span><%=name%></span>
	</div>
	<div data-uxf-point="collapsible-content">
		<span>Some text for Collapsible #<%=id%></span>
	</div>
</div>
```

@class Lightsaber.Web.AccordionView
@namespace Lightsaber
@module Lightsaber.Web
@extends Lightsaber.Core.View

@since 9.0.0

@requires jQuery
@requires Underscore
@requires Lightsaber.Core

@constructor
@param {Object} [options] constructor's only parameter
@param {Object} [options.config] main configuration parameter
@param {String} [options.config.template=accordionTemplate] main <em>Accordion's</em> template  
@param {String} [options.config.collapsibleTemplate=collapsibleTemplate] <em>Accordion's</em> collapsible template  
@param {String} [options.config.autoRender=true] whether *Accordion* should render immediately or wait for data from *ViewModel* 
@param {String} [options.config.idAttribute='id'] name of the property (on the <em>ViewModel</em>), that uniquely identifies a collapsible pane
@param {String} [options.config.vmKeys={}] mapping of expected name of <em>ViewModel</em>
property to its actual name in the specific <em>ViewModel</em> that this <em>View</em> 
receives at runtime.
@param {String} [options.config.expandableAll=false] indicates that multiple collapsible panes are allowed to be expanded simultaneously
@param {String} [options.config.expanded=undefined] array of IDs of collapsible panes that should be expanded by default
**/
define('src_web/components/accordion/view/AccordionView',[
  'jquery',
  'underscore',
  'lightsaber.core',
  'text!./template/AccordionTemplate.html',
  'text!./template/AccordionCollapsibleTemplate.html'
], function($, _, LightsaberCore, accordionTemplate, collapsibleTemplate) {

	
	var AccordionView = LightsaberCore.View.extend({
				publicMethods: ['setExpandAll','createCollapsibles','addCollapsibles','addCollapsible','getPane','addToPane','select'],
		
		/**
		Main configuration property.

		@property {Object} config
		@param {String|Function} template *Accordion's* main template
		@param {String|Function} collapsibleTemplate *Accordion's* tab template
		@param {String} idAttribute name of the ID attribute that uniquely identifies tab data
		**/
		idAttribute: 'id',
		template: accordionTemplate, 
		collapsibleTemplate: collapsibleTemplate, 

		/**
		Configuration property that maps expected *ViewModel* properties to the actual ones.
		
		@property {Object} vmKeys
		@param {Object} [vmKeys.data.items='items'] default name of the propery of the *ViewModel*
		that *Accordion* expects to receive the data on
		@default `{'data.items': 'items'}`
		**/
		vmKeys: {
			'data.items': 'items'
		},
		
		/**
		Main-entry method.

		The main functional purpose is to bind handlers to two events that *ViewModel* triggers: `items:loaded` and `items:added` - {{#crossLink "Lightsaber.Web.AccordionView/_load"}}{{/crossLink}} for `items:loaded` and {{#crossLink "Lightsaber.AccordionView/_add"}}{{/crossLink}} for `items:added`.

		This is done to allow *Accordion* to response to data events in the *ViewModel*, for example, to refresh the tabs when they are changed via *ViewModel's* data.

		@method initialize
		@protected
		**/
		initialize: function(option) {
			this.$collapsibles = $();
			this.$collapsibleTitles = $();
			this.$collapsibleContents = $();
			
			this.template = this.getConfig('template') || this.template;
			this.collapsibleTemplate = _.template(this.getConfig('collapsibleTemplate')  || this.collapsibleTemplate);
			this.idAttribute = this.getConfig('idAttribute') || this.idAttribute;
			
			this.viewModel.on('items:loaded', this._createCollapsibles, this);
			this.viewModel.on('items:added', this._addCollapsibles, this);
		},
		
		/**
		Retrieves (if exists) initial data from *ViewModel's* `items` data property for the initial collapsible panes and renders them.

        @method postRender
        @protected
        **/
		_postRender: function() {
			var items;
			// if we have a collection viewmodel we will get the transformed data from the collection
			
            this._decideExpandAll();

            if (this.viewModel.viewModelType == "Collection")
                items = this.viewModel.getData().items;
            else
                items = this.viewModel && this._getVMData('data.items');
                
            if (items) {
                this._createCollapsibles({items: items});
            }
		},	
		
		/**
		Decides, based on template or `expandableAll` configuration parameter (which takes precendence over the template-based one) whether opening of multiple panes simultaneously should be allowed.
	
		@method _decideExpandAll
		@protected
		**/
		_decideExpandAll: function() {
			if(this.getConfig('expandableAll') === false) {
				this.setExpandAll(false);
			}
			else { // expandableAll is falsy, but not false
				if(this.$root.data('expandable-all') === 'false') {
					this.setExpandAll(false);
				}
				else {
					this.setExpandAll(true);
				}
			}
		},
		
		/**
		Allows/forbids simultaneous expanding of multiple collapsible panes.

		@method setExpandAll
		@param {Boolean} allow allow/forbid - `true`/`false` 
		**/
		setExpandAll: function(allow) {
			this.expandAll = allow;
		},
		
		/**
		Initializes the accordion with new data.

		@method createCollapsibles
		@param {Object|Array} data the data to use for the new accordion panes of structure similar to: 

		```json
		[
			{id: 'id1', name: 'Title 1'}, 
			{id: 'id2', name: 'Title 2'}
		]
		```
		**/
		createCollapsibles: function(data) {	
			this._createCollapsibles(data);		
		},
		
		/**
        Internal implementation of pane creation mechanism. Differs from {{#crossLink "Lightsaber.Web.AccordionView/createCollapsibles:method"}}{{/crossLink}} with the context in which called and some additional BWC concerns.

        @method _createCollapsibles
        @private
        **/
		_createCollapsibles: function(data) {
			if(data.items && data.items.length > 0) {
				if(!this.$root) {
					this.render();
				}

				this.$root.empty();
				this._addCollapsibles(data);
				this.trigger('accordion:added');
			}
		},
		
		/**
		Adds multiple collapsible panes to the *Accordion*.

		@method addCollapsibles
		@param {Object|Array} data the data to use for the new accordion panes of structure similar to: 

		```json
		[
			{id: 'id1', name: 'Title 1'}, 
			{id: 'id2', name: 'Title 2'}
		]
		```
		**/
		addCollapsibles: function(data) {
			this._addCollapsibles(data);
			this.trigger('accordion:added');
		},
		
		/**
        Internal implementation of pane addition mechanism. Differs from {{#crossLink "Lightsaber.Web.AccordionView/createCollapsibles:method"}}{{/crossLink}} with the context in which called and some additional BWC concerns.

        @method _addCollapsibles
        @private
        **/
		_addCollapsibles: function(data) {
			var collapsibles = data.items || [data.item], i = collapsibles.length;
			this.expanded = this.getConfig('expanded');
			
			while(i--) {
				this._addCollapsible(collapsibles[collapsibles.length - i - 1]);
			}

			if (this.expanded && this.expanded.length) {
				this.trigger('accordion:expanded', this.expandAll ? this.expanded: [this.expanded[this.expanded.length - 1]])	;
			}
		},
		
		/**
		Adds single collapsible pane to the *Accordion*.

		@method addCollapsible
		@param {Object} data the data to use for the new accordion pane of structure similar to: 

		```json
		{id: 'id1', name: 'Title 1'}
		```
		**/
		addCollapsible: function(data) {
			var $collapsible = this._addCollapsible(data);
			this.trigger('accordion:added');
			return $collapsible;
		},
		
		/**
        Internal implementation of pane addition mechanism. Differs from {{#crossLink "Lightsaber.Web.AccordionView/createCollapsibles:method"}}{{/crossLink}} with the context in which called and some additional BWC concerns.

        @method _addCollapsibles
        @private
        **/
		_addCollapsible: function(data) {
			data.id = data[this.idAttribute];
			var $collapsible = $(this.getPopulatedTemplate(this.collapsibleTemplate, data));
			var $collapsibleTitle = $collapsible.find('[data-uxf-point="collapsible-title"]');			
			var $collapsibleContent = $collapsible.find('[data-uxf-point="collapsible-content"]');
			
			this.$collapsibles = this.$collapsibles.add($collapsible);
			this.$collapsibleTitles = this.$collapsibleTitles.add($collapsibleTitle);
			this.$collapsibleContents = this.$collapsibleContents.add($collapsibleContent);
			
			var self = this;
			$collapsibleTitle.on('click', function() {
				self._toggleTitle($collapsibleTitle);
				self._toggleContent($collapsibleContent);
			});
			
			if(_.include(this.expanded, data[this.idAttribute])) {
				self._activateTitle($collapsibleTitle);
				self._showContent($collapsibleContent);
			}
			else {
				self._deactivateTitle($collapsibleTitle);
				self._hideContent($collapsibleContent);
			}

			this.$root.append($collapsible);
			return $collapsible;
		},
		
		/**
		Implements visual activation of a collapsible content pane. 

		Should be overriden if a different behaviour (aside from simple addition of `ui-state-active` CSS class) is needed.

		@method _activateTitle
		@protected
		**/
		_activateTitle: function($collapsibleTitle) {
			if(this.expandAll) {
				$collapsibleTitle.addClass('ui-state-active');
			}
			else {
				this.$collapsibleTitles.removeClass('ui-state-active');
				$collapsibleTitle.addClass('ui-state-active');
			}
		},
		
		/**
		Implements revealing of a collapsible content pane by calling *jQuery* `show` method
		on the *jQuery* object that represents (and can be retrieved by calling {{#crossLink "Lightsaber.Web.AccordionView/getPane:method"}}{{/crossLink}}) method.

		Should be overridden if a different (or additional) behaviour is required.


		@method _showContent
		@protected
		**/
		_showContent: function($collapsibleContent) {
			if(this.expandAll) {
				$collapsibleContent.show();
			}
			else {
				this.$collapsibleContents.hide();
				$collapsibleContent.show();
			}
		},
		
		/**
		Implements visual de-activation of a collapsible content pane. 

		Should be overriden if a different behaviour (aside from simple removal of `ui-state-active` CSS class) is needed.

		@method _deactivateTitle
		@protected
		**/
		_deactivateTitle: function($collapsibleTitle) {
			$collapsibleTitle.removeClass('ui-state-active');
		},
		
		/**
		Implements hiding of a collapsible content pane by calling *jQuery* `hide` method
		on the *jQuery* object that represents (and can be retrieved by calling {{#crossLink "Lightsaber.Web.AccordionView/getPane:method"}}{{/crossLink}}) method.

		Should be overridden if a different (or additional) behaviour is required.

		@method _hideContent
		@protected
		**/
		_hideContent: function($collapsibleContent) {
			$collapsibleContent.hide();
		},
		
		/**
		Implements visual toggling of a collapsible content pane's header. 

		Should be overriden if a different behaviour is required.

		@method _toggleTitle
		@protected
		**/
		_toggleTitle: function($collapsibleTitle) {
			
			var isActive = $collapsibleTitle.hasClass('ui-state-active');
			var dataId = $collapsibleTitle.parent().attr('data-id');

			if(this.expandAll) {
				$collapsibleTitle.toggleClass('ui-state-active');
				this.trigger('accordion:' + (isActive ? 'collapsed': 'expanded'), [dataId]);
			}
			else {
				var collapsed = [];
				if (!isActive) {
					$collapsibleTitle.toggleClass('ui-state-active');
					this.trigger('accordion:' + (isActive ? 'collapsed': 'expanded'), [dataId]);					
				}
				_.each(this.$collapsibleTitles.toArray(), function(_collapsibleTitle) {
					var $_collapsibleTitle = $(_collapsibleTitle);
					var _dataId = $_collapsibleTitle.parent().attr('data-id');
					if (_dataId != dataId && $_collapsibleTitle.hasClass('ui-state-active')) {
						$_collapsibleTitle.removeClass('ui-state-active');
						collapsed.push(_dataId);
					}
				});
				if (collapsed.length) {
					this.trigger('accordion:collapsed', collapsed);
				}
			}
		},

		/**
		Implements toggling (from visual standpoint) of a collapsible content pane by calling *jQuery* `hide`/`show` methods (or `toggle`, in simple cases) on the *jQuery* object that represents (and can be retrieved by calling {{#crossLink "Lightsaber.Web.AccordionView/getPane:method"}}{{/crossLink}}) method.

		Should be overridden if a different (or additional) behaviour is required.

		@method _toggleContent
		@protected
		**/		
		_toggleContent: function($collapsibleContent) {
			if(this.expandAll) {
				$collapsibleContent.toggle();
			}
			else {
				this.$collapsibleContents.hide();
				$collapsibleContent.show();
			}
		},

		/**
        Get pane (as *jQuery* object) by ID (for population of content, for example).

        @method getPane
        @param {String} id  ID of the tab the pane belongs to
        **/ 
		getPane: function(id) {
			var $pane = this.$collapsibles.filter('[data-id="' + id + '"]').find('[data-uxf-point="collapsible-content"]');
			return $pane;
		},

		/**
        Adds HTML as content to a pane with the given ID.

        @method addToPane
        @param {String} id ID of the tab the pane belongs to
        @param {String} html HTML that represents the content to add to the pane
        **/ 
		addToPane: function(id, html) {
			var $pane = this.$collapsibles.filter('[data-id="' + id + '"]').find('[data-uxf-point="collapsible-content"]');
			$pane.append(html);
		},
		
		/**
        Selects the collapsible pane by given ID.

        If tabs are disabled then no tab is selected.

        @method select
        @param {String} id ID of the tab
        **/
		select: function(id) {
			var $collapsible = this.$collapsibles.filter('[data-id="' + id + '"]');
			this._activateTitle($collapsible.find('[data-uxf-point="collapsible-title"]'));
			this._showContent($collapsible.find('[data-uxf-point="collapsible-content"]'));
		}
	});
	
	return AccordionView;
});


define('text!src/components/autoComplete/view/template/AutoCompleteTemplate.html',[],function () { return '<div data-uxf-point="autocomplete-container" class="uxf-autocomplete">\n\t<div data-uxf-point="autocomplete-header"></div>\n\t<div data-uxf-point="autocomplete-content">\n\t\t<div data-uxf-point="autocomplete-content-message"></div>\n\t\t<div data-uxf-point="autocomplete-content-data"></div>\n\t</div>\n\t<div data-uxf-point="autocomplete-footer"></div>\n</div>';});


define('text!src/components/autoComplete/view/template/MessageTemplate.html',[],function () { return '<a><%=text%></a>\n';});

/**
<em>AutoComplete</em> component.

*AutoComplete* component provides ability to filter connected data based on user input. *ViewModel* is *CollectionViewModel* and
to invoke the filtering - `change` event from the *ViewModel* should be fired.

A simple example:

```javascript
var collection = new Lightsaber.Core.Collection([
    {'id' : 'AD', 'name' : 'Andorra'},
    {'id' : 'AE', 'name' : 'United Arab Emirates'},
    {'id' : 'AF', 'name' : 'Afghanistan'},
    {'id' : 'AI', 'name' : 'Anguilla'},
    {'id' : 'AL', 'name' : 'Albania'},
    {'id' : 'AM', 'name' : 'Armenia'},
    {'id' : 'BV', 'name' : 'Bouvet Island'}
]);

var collectionViewModel = new Lightsaber.CollectionViewModel({
    models : { items : collection }
});

var searchInputView = new Lightsaber.SearchInputView({
    el: $root,
    viewModel: collectionViewModel,
    config : {
        placeholder: 'Filter...'
    }
});

searchInputView.on('search:input', function(data){
    autocomplete.updateCompletions(data);
});

var autocomplete = new Lightsaber.AutoCompleteView({
    el : $root,
    viewModel : collectionViewModel
});
```

## Main template

```html
<div data-uxf-point="autocomplete-container" class="uxf-autocomplete">
	<div data-uxf-point="autocomplete-header"></div>
	<div data-uxf-point="autocomplete-content">
		<div data-uxf-point="autocomplete-content-message"></div>
		<div data-uxf-point="autocomplete-content-data"></div>
	</div>
	<div data-uxf-point="autocomplete-footer"></div>
</div>
```

@class Lightsaber.Mobile.AutoCompleteView
@namespace Lightsaber
@module Lightsaber.Mobile
@extends Lightsaber.Core.View

@since 9.0.0

@requires jQuery
@requires Underscore
@requires Lightsaber.Core

@constructor
@param {Object} [options] constructor's only parameter
@param {Object} [options.config] main configuration parameter
@param {String} [options.config.template=template] main <em>AutoComplete's</em> template  
@param {String} [options.config.autoRender=true] whether *AutoComplete* should render immediately or wait for data from *ViewModel* 
@param {String} [options.config.vmKeys={}] mapping of expected name of <em>ViewModel</em>
property to its actual name in the specific <em>ViewModel</em> that this <em>View</em> 
receives at runtime.

@param {Number} [options.config.minChars=2] amount of letters needed to be typed to trigger autocompletion
@param {Number} [options.config.delay=0] delay upon receival of letters and before triggering autocompletion
@param {String} [options.config.messageText] empty result message result text
@param {String} [options.config.content] el of the view representing the autocompletion list (can be HTML string)
@param {String} [options.config.updateItemFunction=updateItemFunction] method/callback to manipulate each suggestion
**/
define('src/components/autoComplete/view/AutoCompleteView',[
    'jquery',
    'underscore',
    'lightsaber.core',
    'src/components/itemlist/view/ItemListView',
    'src/components/itemlist/view/GroupedItemListView',
    'text!./template/AutoCompleteTemplate.html',
    'text!./template/MessageTemplate.html'
], function($, _, LightsaberCore, ItemListView, GroupedItemListView, template, messageTemplate) {
	
	
	var autoCompleteView = LightsaberCore.View.extend({

				
		publicMethods : ['updateCompletions','hide','highlight'],

		/**
		Main configuration property.

		@property {Object} config
		@param {String} [options.config.template=template] main <em>AutoComplete's</em> template  
		@param {String} [options.config.autoRender=true] whether *AutoComplete* should render immediately or wait for data from *ViewModel* 
		@param {String} [options.config.vmKeys={}] mapping of expected name of <em>ViewModel</em>
		property to its actual name in the specific <em>ViewModel</em> that this <em>View</em> 
		receives at runtime.

		@param {Number} [options.config.minChars=2] amount of letters needed to be typed to trigger autocompletion
		@param {Number} [options.config.delay=0] delay upon receival of letters and before triggering autocompletion
		@param {String} [options.config.messageText] empty result message result text
		@param {String} [options.config.content] el of the view representing the autocompletion list (can be HTML string)
		@param {String} [options.config.updateItemFunction=updateItemFunction] method/callback to manipulate each suggestion
		**/
		config : {   
			minChars : 2,
			messageText : 'No results were found.',
			delay : 0
		},

		vmKeys : {
			"action.select" : "select"
		},

		/**
		Main-entry method.

		The main functional purpose is to bind handlers to two events that *ViewModel* triggers: `items:loaded` and `items:added` - {{#crossLink "Lightsaber.Mobile.AutoCompleteView/_load"}}{{/crossLink}} for `items:loaded` and {{#crossLink "Lightsaber.AccordionView/_add"}}{{/crossLink}} for `items:added`.

		This is done to allow *AutoComplete* to response to data events in the *ViewModel*, for example, to refresh the tabs when they are changed via *ViewModel's* data.

		@method initialize
		@protected
		**/
		initialize : function() {
			this.updateItemFunction = this.getConfig('updateItemFunction') || this.highlight;		
			this.actionViewModel = this.options.actionViewModel;		
			

			this.viewModel.on('items:loaded', this._ensureItems, this);
			this.viewModel.on('items:selected', this._handleSelection, this);
		},
		
		/**
		@private
		**/
		_ensureItems : function(event) {
			var $message = $('[data-uxf-point="autocomplete-content-message"]',this.root);
			if(event.items.length) {
				$message.hide();
			}
			else {
				$message.show();
			}
		},
		
		/**
		@private
		**/
		_createMessage : function (){
			var themeStr, theme = $(messageTemplate).attr('data-theme');
			if(theme) {
				themeStr = ' data-theme="' + theme + '"';
			}else if(this.theme){
				themeStr = ' data-theme="' + this.theme + '"';
			}
			else {
				themeStr = '';
			}
			
			this.message = _.template(messageTemplate)({text:this.getConfig('messageText'), themeStr : themeStr});
		},
		
		/**
		@private
		**/
		_handleSelection : function(event) {
			this.actionViewModel&&this.actionViewModel.handleAction(this.vmKeys["action.select"], event);
			this.hide();
		},
		
		/**
		@private
		**/
		_initContent : function() {
			var listView;
			this.content = this.getConfig("content");
			var data = $('[data-uxf-point="autocomplete-content-data"]',this.root);
			if(!this.content) {
				var isGrouped = this.viewModel.isGroupedCollection();
				if(isGrouped)	{	
					listView = new GroupedItemListView({
						viewModel : this.viewModel,
						el : data,
						config : {
							itemUpdateHTMLFunction : _.bind(this.updateItemFunction, this)
						},
						attributes : {
							theme : this.theme
						}
					});
				}
				else
				{
					listView = new ItemListView({
						viewModel : this.viewModel,
						el : data,
						config:{
							itemUpdateHTMLFunction : _.bind(this.updateItemFunction, this)
						},
						attributes : {
							theme : this.theme
						}
					});
				}
			} else {
				data.append(this.content);
			}
		},
		
		/**
		Initializes (pre-compiles) *AutoComplete* template.

        @method preRender
        @protected
        **/
		_preRender : function() {
			var templateStr = (this.options.config && this.options.config.template) || template;
			this.template = _.template(templateStr);
		},

		/**
		Renders additional elements: message (and hides it) etc.

        @method postRender
        @protected
        **/
		_postRender : function() {
			this.theme = this.$root.attr('data-theme');
			this._createMessage();
			this._initContent();
			var content = $('[data-uxf-point="autocomplete-content"]',this.root);
			var message = $('[data-uxf-point="autocomplete-content-message"]',this.root);
			message.hide();
			message.append(this.message);
			content.trigger('create');
			this.$root.hide();
		},
		
		/**
		Updates the *AutoComplete* with the content.
		**/
		updateCompletions : function(text)
		{
			var that = this;
			clearTimeout(this.myVar);
			this.myVar=setTimeout(function(){that._updateData(text);},that.getConfig('delay'));
		},
		
		/**
		@private
		**/
		_updateData : function (text)
		{
			this.currentText = text;
			if(text.length >= this.getConfig('minChars')) {
				this.$root.show();
				this.viewModel.currentModel.setFiltering({criteria:text});
			}
			else
			{
				this.$root.hide();
			}
		},
		
		/**
		Hides the *AutoComplete*
		@method hide
		**/
		hide : function (){
			this.$root.hide();
		},
		
		/** 
		Highlights the *AutoComplete* items
		@method hide
		**/
		highlight : function(data, elem, isGroup) {
			if(!this.currentText)
			{
				return;
			}
			var workingElem;
			if (isGroup) {
				return;
				workingElem = elem;				
			} else {
				workingElem = $(elem.children()[0]);							
			}
			
			var termTemplate = '<mark>%s</mark>';
			var regex = new RegExp(this.currentText, "gi");
			workingElem.html( workingElem.text().replace(regex, function (matched) {
                return termTemplate.replace('%s', matched);
            }) );
		}
		
	});
	
	return autoCompleteView;
});

define('text!src_web/components/picker/view/template/RangeSliderTemplate.html',[],function () { return '<div data-role="uxf-rangeslider" class="clearfix">\n\t<button type="button" style="float: left;" data-uxf-point="control-prev" style="margin-bottom: 0.5em;" class="ui-button ui-state-default ui-corner-all ui-button-icon-only">&lt;&lt;</button>\n\t<div data-uxf-point="slider" class="ui-widget-header" style="position: absolute; width: 5em; height: 2em; display: none; margin-left: 0.25em;"></div>\n\t<ul style="float: left;" data-uxf-point="rangeslideritems"></ul>\n\t<button type="button" style="float: left;" data-uxf-point="control-next" class="ui-button ui-state-default ui-corner-all ui-button-icon-only">&gt;&gt;</button>\n</div>';});


define('text!src_web/components/picker/view/template/RangeItemTemplate.html',[],function () { return '<li style="float: left; padding: 0 0.25em; cursor: pointer;" data-uxf-id="<%=id%>">\n\t<div class="">\n\t\t<div class="ui-widget-content" style="width: 5em; height: 2em;"></div>\n\t\t<div style="margin-left: 0.5em;"><span><%=date%></span></div>\n\t</div>\n</li>';});

/**
 * @memberOf Lightsaber.Web
 * @name PickerView
 * @class PickerView
 * @type View
 * 
 * @description
 * Provides visual representation for a picker that connects to tabular data on server (through Collection/CollectionViewModel)
 * and presents it in a slider, while allowing to pick one of the items.
 * @image ../demo_metadata/images/picker.png 409 66
 * @constructor
 * @memberOf Lightsaber.Web.PickerView
 * @param {Object} config configuration options that contains:
 * @param {String|jQueryObject} [el=undefined] selector or jQuery object to attach the <code>View</code> to
 * @param {String} idAttribute the name of the attribute (on the data object) that identifies the item
 * @param {String} [selected=1] id of the item to be selected
 * @param {ViewModel} viewModel an instance of <code>CollectionViewModel</code>
 * @example
 * // Where data (in Collection) is of form : 
 * // [
 * //   { "code" : "1", "date" : "Feb 2012" },
 * //   { "code" : "2", "date" : "Mar 2012" }
 * // ]
 *    
 * var model = new Lightsaber.Core.Collection();
 * model.url = 'rangedata';
 * 
 * var viewModel = new Lightsaber.CollectionViewModel({
 * 		models : {
 *			tabs : model
 *		}
 *	});
 *	
 *	new Lightsaber.PickerView({
 *		viewModel : viewModel,
 *		config : {
 *			idAttribute : 'code',
 *			el : '#rangeslider1',
 *			selected : '2'
 *		}
 *	});
 */
define('src_web/components/picker/view/PickerView',[
  'jquery',
  'underscore',
  'lightsaber.core',
  'text!./template/RangeSliderTemplate.html',
  'text!./template/RangeItemTemplate.html'
], function($, _, LightsaberCore, rangeSliderTemplate, rangeItemTemplate) {

	var RangeSliderView = LightsaberCore.View.extend({
		
		idAttr : 'id',
		
		initialize : function() {
	
			_.bindAll(this,"prev","next","_onResize");
			
			this.template = _.template(rangeSliderTemplate);
			this.itemTemplate = _.template(rangeItemTemplate);
			
			this.idAttr = this.getConfig('idAttribute') || this.idAttr;
			
			this.viewModel.on('items:loaded', this.createItems, this);
		},
		
		_postRender : function() {
			this.$items = this.$root.find('> ul[data-uxf-point="rangeslideritems"]');
			this.$prev = this.$root.find('> [data-uxf-point="control-prev"]');
			this.$next = this.$root.find('> [data-uxf-point="control-next"]');
			this.$prev.on('click', this.prev);
			this.$next.on('click', this.next);
			this.$root.resize(this._onResize);
			$(window).resize(this._onResize);
		},
		
		/**
		 * Handles resize event
		 */
		_onResize : function() {
			if(this.$slider && this.$currentItem) {
				this.select(this.$currentItem, true);
			}
		},
		
		/**
		 * Creates (replaces existing items) new items in the picker.
		 * @methodOf Lightsaber.Web.PickerView
		 * @name createItems
		 * @param {Array} data array of items to be presented in the picker in <code>{items:[{...}, {...}, ...]}</code> structure.
		 * The items replace existing ones (if exist).
		 */
		createItems : function(data) {
			this.$items.empty();
			this.addItems(data);
			if(!this.$slider) {
				this.$slider = this.$('div[data-uxf-point="slider"]');
				this.$slider.css("z-index", 100);
			}
			this.select(this.getConfig('selected') || '1', true);			
		},
		
		/**
		 * Adds several items (in a specific structure) to the picker.
		 * @methodOf Lightsaber.Web.PickerView
		 * @name addItems
		 * @param {Array} data array of items to be presented in the picker in <code>{items:[{...}, {...}, ...]}</code> structure. 
		 * The items are added to the existing items. 
		 */
		addItems : function(data) {
			var rangeItems = data.items || [data.item], i = rangeItems.length;
			
			while(i--) {
				this.addItem(rangeItems[rangeItems.length - i - 1]);
			}
		},
		
		/**
		 * Adds a new item to the picker.
		 * Adds an item to the picker.
		 * @methodOf Lightsaber.Web.PickerView
		 * @name addItem
		 * @param {Object} item object containing data to be associated with the item
		 */
		addItem : function(item) {
			item.id = item[this.idAttr];
			var $rangeItem = $(this.itemTemplate(item));
			$rangeItem.data(item);
			$rangeItem.on('click', _.bind(this.__select, this));
			this.$items.append($rangeItem);
		},
		
		__select : function(event) {
			this.select($(event.currentTarget));
		},
		
		/**
		 * Selects an item in the picker by its ID.
		 * @methodOf Lightsaber.Web.PickerView
		 * @name select
		 * @param {String} element ID (according to <code>idAttribute</code> configuration) of item to be selected
		 * @param {Boolean} skipAnimation whether to skip the animation of selection of an item
		 */
		select : function(element, skipAnimation) {			
			if(typeof element === 'string') { //ID of the range item				
				this.$currentItem = this.$items.find('[data-uxf-id="' + element + '"]');				
			}
			else {
				this.$currentItem = element;
				
			}
			var position = this.$currentItem.position();
			this.$slider.css('top', position.top);
			if(skipAnimation) {
				this.$slider.css('left', position.left);
				this.$slider.show();
				
				/**
			 		* Event that is triggered upon item selection.
			 		* @methodOf Lightsaber.Web.PickerView
			 		* @event
			 		* @param data The data that was associated with the item upon its creation.
			 		* @name item:selected
			 	*/
				this.trigger('item:selected', this.$currentItem.data());
			}
			else {
				var self = this;
				this.$slider.animate({
					left : position.left
				}, 600, function(){
					$(this).show();
					self.trigger('item:selected', self.$currentItem.data());
				});
			}
			
		},
		
		next : function() {
			var next = this.$currentItem.next();
			next && next.length && this.select(next);
		},
		
		prev : function() {
			var prev = this.$currentItem.prev();
			prev && prev.length && this.select(prev);
		}
	});
	
	return RangeSliderView;
});


define('text!src_web/components/breadcrumbs/view/template/BreadcrumbsTemplate.html',[],function () { return '<ul style="list-style: none; -webkit-padding-start: 10px;" class="uxf-breadcrumbs clearfix"></ul>';});


define('text!src_web/components/breadcrumbs/view/template/BCItemTemplate.html',[],function () { return '<li style="float: left;">\n\t<a data-uxf-point="anchor_<%=route%>" style="text-decoration: underline;"><%=name%></a>\n\t<span>&gt;</span>\n</li>';});


define('text!src_web/components/breadcrumbs/view/template/BCLastItemTemplate.html',[],function () { return '<li style="float: left;">\n\t<%=name%>\n</li>';});

/**
@class Lightsaber.Web.BreadcrumbsView
@namespace Lightsaber
@module Lightsaber.Web
@extends Lightsaber.Core.View

@private

@since 9.0.0
@deprecated 9.1.0
**/
define('src_web/components/breadcrumbs/view/BreadcrumbsView',[
    'jquery',
	'underscore',
	'backbone',
	'lightsaber.core',
	'text!./template/BreadcrumbsTemplate.html',
	'text!./template/BCItemTemplate.html',
	'text!./template/BCLastItemTemplate.html'
], function($, _, Backbone, LightsaberCore, breadcrumbsTemplate, itemTemplate, lastItemTemplate) {
	
	var pageModule = LightsaberCore.View.extend({
		publicMethods : ['add','remove'],
		template : breadcrumbsTemplate,
		itemTemplate : itemTemplate,
		lastItemTemplate : lastItemTemplate,
		
		initialize : function() {
			this.routes = [];
			this.routePos = {};
			this.template = _.template(this.template);	
			this.itemTemplate = _.template(this.itemTemplate);
			this.lastItemTemplate = _.template(this.lastItemTemplate);	
		},
		
		add : function(config) {
			if(this.routePos[config.route] === undefined) {
				this.routes.push(config);
				this.routePos[config.route] = this.routes.length - 1;
				this._update();
			}	
			else {
				this.remove(config.route);
				this.add(config);
			}
		},
		
		remove : function(route) {
			if(this.routePos[route] !== undefined) {
				var position = this.routePos[route];
				for(var i = position, length = this.routes.length - 1; i <= length; i++) {
					delete this.routePos[this.routes[i].route];
				}
				this.routes = this.routes.slice(0, position);
				this._update();					
			}
		},
		
		_update : function() {
			var $root = this.$root.detach();
			$root.empty();
			$root.find('[data-uxf-point]').each(function(index, element) {
				$(element).off();
			});
			
			for(var i = 0, length = this.routes.length - 1; i <= length; i++) {
				if(i === length) {
					$root.append(this.lastItemTemplate(this.routes[i]));
				}
				else {
					$root.append(this.itemTemplate(this.routes[i]));
				}
				this._attachSelectHandler($root, this.routes[i]);
			}		
			this.$el.append($root);
		},
		
		_attachSelectHandler : function($root, config) {
			$root.find('[data-uxf-point="anchor_' + config.route + '"]').on('click', _.bind(function() {
				this._handleSelect(config);
			}, this));
		},
		
		_handleSelect : function(config) {
			this.remove(config.route);
			this.add(config);
			config.handler.apply(this);
		}
	});
	
	return pageModule;
});
/**
CollectionView generates multiple subviews that are from same type(View or a template).
The data for the subView received from view model. 

@class CollectionView
@namespace Lightsaber
@module Lightsaber.Mobile
@extends Lightsaber.Core.View

@requires jQuery
@requires Underscore
@requires Lightsaber.Core

@since 9.0.0

@constructor
@param {Object} options configuration options
@param {String} [options.config.template=undefined] Template for the entire CollectionView widget, its layout and structure
@param {String} [options.config.viewType=View] Type of subViews
@param {String} [options.config.viewEl=$root] Indicates the root html element of the subviews
@param {String} [options.config.viewModel=undefined] CollectionViewModel of the CollectionView, actions are copied to subVMS
@param {Object} [options.config.viewOptions=undefined] View options to pass for subViews
@runexample ../examples/apps/AllMobileViewsTestApp/index.html?module=creation&example=0&style=frame#collectionViewPage
@example 
A simple example below demonstrates the creation of an CollectionView widget using static data stored in a Model 
and passed to the CollectioView through CollectionViewModel:
	

		// Prepare static example data.
		var collectionViewData = [
		   {'input' : 'date1'},
		   {'input' : 'date2'},
		   {'input' : 'date3'}
		];
		// Create fixture to intercept any "collectionView/data" REST calls.
		$.fixture('collectionView/data', function() { return [ collectionViewData ]; });
		var collection = new Lightsaber.Core.Collection(null, {
				url : 'collectionView/data'
		});
		// Create CollectionViewModel to abstract over the data.
		var collectionViewModel = new Lightsaber.CollectionViewModel({
				models : { data : collection }
		});
		// Create a new collectionView instance, connecting it with the CollectionViewModel
		// and providing the target place (by using jQuery object or selector string) to be appended to.    		
		var collectionView = new Lightsaber.CollectionView({
				el : $placeholder
				viewModel : collectionViewModel
				config : {
				   viewType : Lightsaber.InputTextView,
				   viewOptions : {
				     vmKeys : {'data.fieldValue' : 'input'}
				   }
				}
		});
		// Make REST call to "collectionView/data" to bring the data to present in CollectionView.
		collection.fetch();

CollectionView widget expects a <code>CollectionViewModel</code> as its ViewModel. The expected data structure may be
approximately described as the following:
	
		[
		   { 'id' : '1', 'name' : 'Title 1' },
		   { 'id' : '2', 'name' : 'Title 2' },
		   { 'id' : '3', 'name' : 'Title 3' },
		   { 'id' : '4', 'name' : 'Title 4' }
		]

**/
 define('src/components/collectionView/view/CollectionView',[
	'jquery',
	'underscore', 
	'lightsaber.core'
], function($, _, LightsaberCore) {

  
  
  var collView = LightsaberCore.View.extend({

  		
		/**
		binds the change events for collection view model items, including - loaded, emptied, refreshed, added, changed, removed and paginated

		@method initialize
		@protected
		**/
		initialize :	function(options) {
			_.bindAll(this,'_added', '_removed', '_changed', '_subViewsRefresh','_cleared','_handlePage');
			// binding to the viewmodel events /*need to add implementation*/
			this.viewModel.on('items:loaded', this._subViewsRefresh,this);
			this.viewModel.on('items:emptied', this._cleared,this);
			this.viewModel.on('items:refreshed', this._subViewsRefresh,this);
			this.viewModel.on('items:added', this._added,this);
			this.viewModel.on('items:changed', this._changed,this);
			this.viewModel.on('items:removed', this._removed,this);
			this.viewModel.on('items:paginated', this._handlePage,this);
		},

		/**
		A "hook" method that generates the sub views based on the configuration options and the collection view model data.

		It then places the subviews into the subViews property and calls the super() which continues handling based on the subViews property. 
		
		@method _handleSubViews
		@protected
		**/
		_handleSubViews : function() {
			//create sub views based on collection view model
			this._prepareSubViews();
			this._super();
		},

		/**
		gets the data from the collection view model
		
		@method _getCollectionViewData
		@private
		@return {object} the data from the collection view model to be displayed in the sub views.
		**/
		_getCollectionViewData : function() {
			var collection = this.viewModel.currentModel;
			var sortFunction = this.viewModel._getSortFunction();
			var filterFunction = this.viewModel.getConfig('filterFunction');

			var pageNum = this.getConfig('pageNum');
			var pageModels = collection.getPage(pageNum);


			pageModels.data = 
			    _.isFunction(filterFunction) ? _.filter(pageModels.data, filterFunction) : pageModels.data;
			pageModels.data = 
			    _.isFunction(sortFunction) ? _.sortBy(pageModels.data, sortFunction) : pageModels.data;
			    
			return pageModels.data;			
		},
		
		/**
		Prepares the subviews. For each row of data in the collection view model, it creates a new view model and a new view and pushes the view instance into the subViews property
		
		@method _prepareSubViews
		@private
		**/
		_prepareSubViews : function() {
			this.subViews = [];
			this.sortedViewList = [];

			var collection = this._getCollectionViewData();

			for ( var i = 0; i < collection.length; ++i) {
			  	var model = collection[i];
			  	var viewModel = this._createViewModel(model,i);
			  	var instanceDetails = this._createView(viewModel);
			  	var view = instanceDetails.viewInstance;
			  	this.subViews.push(instanceDetails);
			  	this.sortedViewList.push(view);
			 }
			 if(this.sortedViewList.length > 0) {
			  	this.sortedViewList[this.sortedViewList.length-1].$root.addClass('uxf-collection-lastItem');
			  	this.sortedViewList[0].$root.addClass('uxf-collection-firstItem');
			 }
	  	},
	  
	  /**
	  creates a view model per the model passed into it, including relevant actions and bindings
	  
	  @method _createViewModel
	  @private
	  @param {object} model the data model received from the collection view model 
	  @param {number} i the index of the model in the original collection view model
	  @return {Object} the view model
	  **/
		_createViewModel : function (model,i) {
			var actionFactory = function(action) {
				return function() {
					var params = [].slice.call(arguments);
		  		params.splice(0,0,action, this);
		  		this.parentVM.handleAction.apply(this.parentVM,params);
				};
			}
			var modelObj = model.toJSON();
			var binding = [];
			
			for(var attr in modelObj) {
			    var bindingObj = {};
			    var modelAttr = 'models.model.' + attr;
			  	bindingObj[attr] = modelAttr;
			  	bindingObj.options = {
			  		setOnBind: true,
			  		twoWay : true};
			  	binding.push(bindingObj);
			}
		  
			var actions = {};

			//Would prefer the line below to be: 
			//   parentActions = this.viewModel.actions or this.viewModel.getActions()
			var parentActions = this.viewModel.getConfig('actions');
			for(var action in parentActions) {
				// use factory function to avoid colsure with the loop iterator
				//Closure in here would have all actions reference the last value of var action
				actions[action] = actionFactory(action);
			}

			var viewModel = new LightsaberCore.ViewModel({
				models : { model : model},
				dataBindings : binding,
				config : {
				  actions : actions
				}
			});

			viewModel.parentVM = this.viewModel;
			viewModel.parentVMIndex = i;
			return viewModel;
		},
	  
	  	/**
	  	Creates a view with the received view model
	  	
	  	@method _createView
	  	@private
	  	@param {Object} viewModel the view model to create the view with
	  	@return {Object} the view
	  	@example
	  	
	  	**/
		_createView : function(viewModel) {
			var viewType = this.getConfig('viewType') || LightsaberCore.View;
			var viewOptions = this.getConfig('viewOptions') || {};

			viewOptions = _.defaults({},viewOptions, {viewModel : viewModel});
			var el;
			if(viewOptions.el) {	  		
				//we don't allow setting el for each view
				el = viewOptions.el;
				delete viewOptions.el;
			} else {
				el = this.getConfig('viewEl');
			}
			var viewInstance = new viewType(viewOptions);
			viewInstance.$root.attr('data-uxf-point','uxf-collection-item');

			var instanceDetails = {viewInstance : viewInstance};
			if(el) {
				instanceDetails.el = el;
			}
			return instanceDetails;
		},
	  
	  	/**
	  	Defines the behaviour upon change events. Empty template method.
	  	
	  	@method _changed
	  	@protected
	  	**/
		_changed : function() {},
		
		/**
		Defines the behaviour upon 'items:cleared' event of the collection view model. Destroys the subviews upon this event
		
		@method _cleared
		@private
		**/	
		_cleared : function() {
				// would like to use this._refresh(); but that doesn't cover the all render cycle
				this._destroySubViews();
		},
		
		/**
		This method is called upon items:loaded event and items:refreshed event from the collection view model. 
		It destroys any existing subviews, and then creates a new set of subviews based on the currect collection view model status
		
		@method _subViewsRefresh
		@private
		**/
		_subViewsRefresh : function() {
			this._destroySubViews();
			this._handleSubViews(); //view render method
		},
		
		/**
		Refreshes the subviews according to requested page number
		
		@method _handlePage
		@private
		@param {Object} page the page object that comes from the collection view model. It must include a page number (page.paginationInfo.pageNum)
		**/
		_handlePage : function(page) {
			var pageNum = page && page.paginationInfo && page.paginationInfo.pageNum;

			if(_.isNumber(pageNum)) {
				this.setConfig('pageNum',pageNum);
			}
			this._subViewsRefresh();
		},
		
		/**
		Adds a new subview upon the addition of data into the collection view model (items:added)
		
		@method _added
		@private
		@param {Object} data the data model that was added to the collection
		**/
		_added : function(data) {
			var sortedIndex = _.isUndefined(data.sortedIndex) ? this.viewModel.currentModel.models.length-1 : data.sortedIndex;
			var model = this.viewModel.currentModel.models[sortedIndex];
			var viewModel = this._createViewModel(model,sortedIndex);
			var viewDetails = this._createView(viewModel);
			var view = viewDetails.viewInstance;
			//add to subview
			this.addSubView(viewDetails);
			
			//fix indexes
			for(var i = sortedIndex ; i < this.sortedViewList.length ; ++i) {
				this.sortedViewList[sortedIndex].viewModel.parentVMIndex += 1;
			}
			//add to sorted view list
			this.sortedViewList.splice(sortedIndex,0,view);
			if(sortedIndex == 0) {
				this.sortedViewList[0].$root.addClass('uxf-collection-firstItem');
				if(this.sortedViewList.length > 1) {
					this.sortedViewList[1].$root.removeClass('uxf-collection-firstItem');
				}
			}
			
			//move to proper location if needed
			if(sortedIndex < this.sortedViewList.length-1) {
				this.sortedViewList[sortedIndex+1].before(this.sortedViewList[sortedIndex]);
			} else {
				//added as last item
				this.sortedViewList[sortedIndex].$root.addClass('uxf-collection-lastItem');
				if(sortedIndex > 0) {
					this.sortedViewList[sortedIndex-1].$root.removeClass('uxf-collection-lastItem');
				}
			}
		},
		
		/**
		removes a subview upon the removal of its data from the CVM (items:removed)	
		
		@method _removed
		@private
		@param {object} data the data model that we removed from the CVM
		**/
		_removed : function(data) {
			var sortedIndex = data.sortedIndex || -1;

			if(sortedIndex < 0) {
				for(var i = 0 ; i < this.sortedViewList.length ; ++i) {
					var model = this.sortedViewList[i].viewModel.models.model;
					if(model.cid == data.modelData.cid) {
						sortedIndex = i;
						break;
					}
				}
			}
			if(sortedIndex >= 0 && sortedIndex <this.sortedViewList.length) {
				var viewToRemove = this.sortedViewList[sortedIndex];
				
				viewToRemove.destroy();
				//remove from the sorted list
				this.sortedViewList.splice(sortedIndex,1);
				if(sortedIndex == 0 && this.sortedViewList.length > 0) {
					//first item was removed
						this.sortedViewList[0].addClass('uxf-collection-firstItem');
				}
				
				if(sortedIndex == this.sortedViewList.length && this.sortedViewList.length > 0) {
					//last item was removed
					var lastIndex = sortedIndex > 0 ? sortedIndex-1 : 0;
					this.sortedViewList[lastIndex].addClass('uxf-collection-lastItem');
				}
				//fix indexes
				for(var i = sortedIndex ; i < this.sortedViewList.length ; ++i) {
				  this.sortedViewList[sortedIndex].viewModel.parentVMIndex -= 1;
			  }
			}
		},
		
		/**
		destory the subviews that were created in this view and that are not handled by View.destroy()
		
		@method _destroySubViews
		@private
		**/
		_destroySubViews : function() {
			for(var cid in this._subViews) {
			  this._subViews[cid].instance && this._subViews[cid].instance.destroy();

			}
			this._subViews = {};
		  	this.subViews = [];
		  	this.sortedViewList = [];
		},

		/**
		destory the view. Overrides the original View's destroy(). It destroys anything the View.destory() is not aware of and then calls super()
		
		@method destory
		@public
		@callable
		**/
		destroy : function() {
			this._destroySubViews();
			this._super();
		}
		
	});
	return collView;
});


define('text!src/components/wizard/view/template/template.html',[],function () { return '<div data-uxf-point="wizard">\n\t<ul data-uxf-point="stepContainer"></ul>\n</div>\n';});


define('text!src/components/wizard/view/template/stepTemplate.html',[],function () { return '<!--&nbsp; here is to support inline-block usage for wizard placement in IE < 8. Do not remove! -->\n<li data-uxf-point="step" data-id="<%=id%>"><%=id%></li>&nbsp;';});

/**
Mobile Wizard component - provides visual presetntation, that generally can be used with any component, but comes
pre-integrated with {{#crossLink "Lightsaber.Core.FlowManager"}}{{/crossLink}} 

@namespace Lightsaber
@class WizardView
@module Lightsaber
@extends Lightsaber.Core.View
@requires jquery, underscore, Lightsaber.Core
@constructor
@param {Object} [options] *Wizard's* configuration object
**/
define('src/components/wizard/view/WizardView',[
  'jquery',
  'underscore',
  'lightsaber.core',
  'text!src/components/wizard/view/template/template.html',
  'text!src/components/wizard/view/template/stepTemplate.html'
], function($, _, LightsaberCore, template, stepTemplate) {
    
    

    var WizardView = LightsaberCore.View.extend({

        /**
        Name of the size mapping configuration parameter.

        @property SIZE_MAPPING_CONFIG
        @type {String} 
        @default 'sizeMapping'
        **/
        SIZE_MAPPING_CONFIG: 'sizeMapping',

        /**
        Name of the resource bundle configuration parameter *on the Wizard's ViewModel*.

        @property RESOURCE_BUNDLE_CONFIG
        @type {String} 
        @default 'resourceBundle'
        **/
        RESOURCE_BUNDLE_CONFIG: 'resourceBundle',

        /**
        Wizard's template.
        
        Default is:

            <div data-uxf-point="wizard">
                <ul data-uxf-point="stepContainer"></ul>
            </div>

        @property template
        @type {String} 
        **/
        template: template,

        /**
        Wizard step's template.

        Default is:

            <li data-uxf-point="step" data-id="<%=id%>"><%=id%></li>&nbsp;

        @property stepTemplate
        @type {String} 
        **/
        stepTemplate: stepTemplate,

        config: {
            sizeMapping: [
                {range: [1, 2], className: 'short'},
                {range: [3, 5], className: 'medium'},
                {range: [6, 8], className: 'long'}
            ]
        },

        initialize: function() {
            this.initTemplate('template');
            this.initTemplate('stepTemplate');

            this._processSizeMapping();

            this.viewModel.on('all', _.bind(this._handleSteps, this));
        },

        /**
        Processes the provided `sizeMapping` configuraiton parameter and creates CSS classes list
        that may be applied to the root of the Wizard.

        The result of the processing is stored on `sizeClasses` property and is used to easily *remove* any of the 
        classes from the DOM element.

        @method _processSizeMapping
        @protected
        **/
        _processSizeMapping: function() {
            var mapping = this.getConfig(this.SIZE_MAPPING_CONFIG);
            this.sizeClasses = '';

            for (var i = 0; i < mapping.length; i++) {
                this.sizeClasses += ' ' + mapping[i].className;
            }

            this.sizeClasses = $.trim(this.sizeClasses);
        },

        /**
        Calculates size-related class(es) to be applied to the root of the Wizard.

        @example

            new Lightsaber.WizardView({
                el: this.$root.find('[data-uxf-point="wizard"]'),
                viewModel: viewModel,
                config: {
                    flow: flow,
                    sizeMapping: [
                        {range: [1, 5], className: 'normal'},
                        {list: [3], className: 'notnormal'}
                    ]
                }
            }); 

        and the expect CSS classes list in case of the above configuration and a Wizard of size 3 would be `normal notnormal`, while
        for a Wizard of size 4 it would be `normal`.

        > Only visible steps are included when calculating Wizard's size.

        For more information of various configuration options see {{#crossLink "Lightsaber.WizardView"}}{{/crossLink}}.

        @method _getMapping
        @protected
        @param {Number} size size of the Wizard (amount of steps)
        @return {String} list of classes to apply
        **/
        _getMapping: function(size) {
            var result = '', 
                mapping = this.getConfig(this.SIZE_MAPPING_CONFIG);

            for (var i = 0; i < mapping.length; i++) {
                if(mapping[i].range) {
                    if(size >= mapping[i].range[0] && size <= mapping[i].range[1]) {
                        result += ' ' + mapping[i].className;
                    }

                } else if(mapping[i].list) {
                    if(_.indexOf(mapping[i].list, size) >= 0) {
                        if(mapping[i].override) { // if the intention is to find exact value and disregard range checks
                            result = mapping[i].className;
                            break;
                        } else { // otherwise adds class to the classes list (perhaps having classes added by range checks)
                            result += ' ' + mapping[i].className;
                        }                       
                    }
                }               
            }

            return result;
        },

        /**
        Applies list of clases, based on `sizeMapping` configuration parameter, to the root of the Wizard (while removing
        the previous list of size-related classes).

        @method _applySizeMapping
        @protected
        @param {Number} size size of the Wizard (amount of steps)
        **/
        _applySizeMapping: function(size) {
            var className = this._getMapping(size);
            if(className) {
                this.$root.removeClass(this.sizeClasses);
                this.$root.addClass(className);
            }           
        },

        /**
        Retrieves data from ResourceBundle.

        @method _getLocaleString
        @protected
        @param {String} key ResourceBundle key
        @param {String} args additional arguments to be passed to ResourceBundle `getString` method, see 
        {{#crossLink "Lightsaber.Core.ResourceBundle/getString"}}{{/crossLink}}
        @return {String} String value that corresponds to the provided `key` parameter in the current ResourceBundle
        **/
        _getLocaleString: function(key, args) {
            var rb = this.viewModel.getConfig(this.RESOURCE_BUNDLE_CONFIG);
            if (!rb) {
                throw new Error("resourceBundle is missing for i18n template parsing");
            }
            return rb.getString(key, args);
        },

        /**
        Decides on the step to activate or insert based on current action and step configuration.

        @method _handleSteps
        @protected
        @param {String} event {{#crossLink "Lightsaber.Core.FlowManager"}}{{/crossLink}} step event
        @param {Object} actionConfig {{#crossLink "Lightsaber.Core.FlowManager"}}{{/crossLink}} step configuration
        @param {Object} additionalConfig {{#crossLink "Lightsaber.Core.FlowManager"}}{{/crossLink}} additional configuration
        **/
        _handleSteps: function(event, actionConfig, additionalConfig) {
            if(this.getConfig('flow') === actionConfig.flowID) {
                switch(event) {
                    case 'flow:start':      
                        this._handleStartFlow(actionConfig, additionalConfig);                
                        break;
                    case 'flow:cancel':  
                        this._handleCancelFlow();
                        break;
                    case 'flow:finish':  
                        this._handleFinishFlow();
                        break;
                    case 'flow:load:step':
                        this._handleFlowAction(actionConfig, additionalConfig);
                        break;
                    case 'flow:step:mark': 
                        this._handleMark(actionConfig, additionalConfig);
                        break;
                    case 'flow:step:unmark': 
                        this._handleUnmark(actionConfig, additionalConfig);
                        break;
                }
            }
        },

        _handleEndFlow: function() {
            this.started = false;
            this.$root.addClass('hidden');
        },

        _handleCancelFlow: function() {
            this._handleEndFlow();
        },

        _handleFinishFlow: function() {
            this._handleEndFlow();
        },

        _augmentStep: function(actionConfig, additionalConfig) {
            if(additionalConfig[actionConfig.flowID].steps) {
                this.stepsAmount = this._calculateStepsAmount(additionalConfig[actionConfig.flowID].steps);
            }
            
            this.$root.find('[data-uxf-point="stepContainer"]').empty();
            _.each(additionalConfig[actionConfig.flowID].steps, _.bind(function(singleConfig) {
                if(!singleConfig.invisible) {
                    singleConfig.i18n = this._getLocaleString;
                    this.$root.find('[data-uxf-point="stepContainer"]').append(this.stepTemplate(singleConfig));
                }
            }, this));
        },

        _handleStepSize: function() {
            this.$root.removeClass('hidden');
            this.$root.attr('data-count', this.stepsAmount);                            
            this._applySizeMapping(this.stepsAmount);
            this.started = true;
        },

        _handleFlowAction: function(actionConfig, additionalConfig) {
            if(this.started) {
                if(!actionConfig.invisible) {
                    this._activate(actionConfig);
                }                           
            } else {
                this._augmentStep(actionConfig, additionalConfig);

                if(!actionConfig.invisible) {
                    this._activate(actionConfig);   
                }
                else {
                    this.$root.find('[data-uxf-point="step"][data-id="' + actionConfig.actions.prev + '"]').addClass('active');
                }
                
                this._handleStepSize();
            }
        },

        _handleStartFlow: function(actionConfig, additionalConfig) {
            if(!this.started) {
                this._augmentStep(actionConfig, additionalConfig);

                if(!actionConfig.invisible) {
                    this.$root.find('[data-uxf-point="step"]').eq(0).addClass('active');
                }
                
                this._handleStepSize();
            }
        },

        _handleMark: function(actionConfig, additionalConfig) {
            this.$root.find('[data-uxf-point="step"][data-id="' + actionConfig.originalStepID + '"]').addClass(additionalConfig);
        },

        _handleUnmark: function(actionConfig, additionalConfig) {
            this.$root.find('[data-uxf-point="step"][data-id="' + actionConfig.originalStepID + '"]').removeClass(additionalConfig);
        },

        /**
        Calculates the size (amount of *visible* steps in the Wizard).

        @method _calculateStepsAmount
        @protected
        @param {Object} steps flow configuration
        **/
        _calculateStepsAmount: function(steps) {
            var count = 0;
            for (var i = 0; i < steps.length; i++) {
                if(!steps[i].invisible) {
                    count++;
                }
            }

            return count;
        },

        /**
        Activates a step.

        @method _activate
        @protected
        @param {Object} actionConfig step configuration
        **/
        _activate: function(actionConfig) {
            var $current = this.$root.find('[data-uxf-point="step"].active'),
                size, 
                $existing;

            if($current.data('id') !== actionConfig.id) {
                $current.removeClass('active');
                $existing = this.$root.find('[data-uxf-point="step"][data-id="' + actionConfig.originalStepID + '"]');
                if($existing.length === 0) {
                    this._insertStep(actionConfig);
                } else {
                    $existing.addClass('active');
                }
                size = this.$root.find('[data-uxf-point="step"]').length;
                this._applySizeMapping(size);
            }
        },

        /**
        Inserts step dynamically.

        @method _insertStep
        @protected
        @param {Object} actionConfig step configuration
        **/
        _insertStep: function(actionConfig) {
            var clonedConfig = $.extend('true', {}, actionConfig),
                $newelement;

            clonedConfig.id = clonedConfig.originalStepID;
            clonedConfig.i18n = this._getLocaleString;
            $newelement = $(this.stepTemplate(clonedConfig));
            $newelement.addClass('active');
            this.$root.find('[data-uxf-point="stepContainer"]').append($newelement);
            this.stepsAmount++;
            this.$root.attr('data-count', this.stepsAmount);
        },

        destroy: function(clearVM) {
            this.started = false;
            this.sizeClasses = '';
            this._super(clearVM);
        }
    });

    return WizardView;

});
define('src_web/lightsaber.components',[
    'lightsaber.core',
    'src/components/collection/viewmodel/CollectionViewModel',
    'src/components/button/view/BaseButtonView',
    'src/components/button/view/ButtonView',
    'src/components/header/view/HeaderView',
    'src/components/forminput/view/BaseFormElementView',
    'src/components/forminput/view/FormElementTouchpointBaseView',
    'src/components/forminput/view/InputTextView',
    'src/components/forminput/view/InputTextAreaView',
    'src/components/forminput/view/CheckboxView',
    'src/components/forminput/view/RadioView',
    'src_web/components/forminput/view/SelectView',
    'src_web/components/forminput/view/WebSliderView',
    'src/components/forminput/view/BaseSelectView',
    'src/components/forminput/view/FlipSwitchView',
    'src/components/forminput/view/BooleanView',
    'src/components/forminput/view/FileLoaderView',
    'src/components/searchinput/view/SearchInputViewBase',
    'src/components/searchinput/view/SearchInputView',
    'src/components/itemlist/view/BaseItemListView',
    'src/components/itemlist/view/ItemListView',
    'src/components/itemlist/view/GroupedItemListView',
    'src/components/navbar/viewmodel/NavBarViewModel',
    'src_web/components/navbar/view/NavBarView',
    'src/components/navbar/viewmodel/SubNavBarViewModel',
    'src_web/components/navbar/view/SubNavBarView',

    'src/components/chart/view/ChartView',
	'src_web/components/tabpanel/view/TabPanelView',
	'src/components/proxy/viewmodel/ProxyViewModel',
	'src/components/form/view/FormView',
	'src/components/popup/view/PopupView',
	'src/components/carousel/view/BaseCarouselView',
    'src/components/carousel/view/CarouselView',
	'src_web/components/application/view/Application',
	'src_web/components/application/view/Module',
    'src_web/components/application/view/Navigation',
	'src_web/components/application/view/PopupModule',
	'src/components/pagination/view/BasePaginationView',
	'src/components/pagination/view/PaginationView',
	'src_web/components/ftable/view/TableView',
	'src/components/progressbar/view/ProgressBarView',
	'src_web/components/accordion/view/AccordionView',
	'src/components/autoComplete/view/AutoCompleteView',
	'src_web/components/picker/view/PickerView',
	'src_web/components/breadcrumbs/view/BreadcrumbsView',
	'src/components/application/view/LoadingView',
    'src/components/collectionView/view/CollectionView',
    'src/components/wizard/view/WizardView'
	],
    function (LightsaberCore,
    	CollectionViewModel,BaseButtonView,
        ButtonView,HeaderView,BaseFormElView,
        BaseFormElementView, InputTextView, InputTextAreaView, CheckboxView, 
        RadioView, SelectView, SliderView, BaseSelectView, FlipSwitchView, BooleanInputView,
        FileLoaderView,
        SearchInputViewBase, SearchInputView,BaseItemListView,
        ItemListView,GroupedItemListView,
        NavBarViewModel, NavBarView,
        SubNavBarViewModel, SubNavBarView,

        ChartView,
        TabPanelView,
        ProxyViewModel , FormView,
        PopupView,
        BaseCarouselView, CarouselView,
        Application, Module, Navigation, PopupModule,
        BasePaginationView,PaginationView,
        TableView, 
        ProgressBarView,
        AccordionView,
        AutoCompleteView,
        PickerView,
        BreadcrumbsView,
        LoadingView, CollectionView, WizardView
        ) {
        return {
            Core : LightsaberCore,
            
            // START BWC
            ActionViewModel : LightsaberCore.ViewModel,
            GroupedCollectionViewModel : CollectionViewModel,
            FormElementViewModel: LightsaberCore.ViewModel,
            ItemListViewModel : CollectionViewModel,
            TabPanelViewModel : CollectionViewModel,
            CarouselViewModel : CollectionViewModel,
            FragmentModule : Module, 
            PageModule : Module, 
            BarChartViewModel: LightsaberCore.ViewModel,
            ChartViewModel: LightsaberCore.ViewModel,
            SearchInputViewModel: LightsaberCore.ViewModel,
            ButtonViewModel : LightsaberCore.ViewModel,
            HeaderViewModel : LightsaberCore.ViewModel,
             PageViewModel : LightsaberCore.ViewModel,
            ContainerViewModel: LightsaberCore.ViewModel,
            PopupViewModel : LightsaberCore.ViewModel, 
            // END BWC
            

            CollectionViewModel : CollectionViewModel,
            BaseButtonView : BaseButtonView,
            ButtonView : ButtonView,
            HeaderView : HeaderView,
            BaseFormElView: BaseFormElView,
           BaseFormElementView: BaseFormElementView,
            InputTextView: InputTextView,
            InputTextAreaView: InputTextAreaView,
            CheckboxView : CheckboxView,
            RadioView : RadioView,
            SelectView : SelectView,
            SliderView : SliderView,
            BaseSelectView : BaseSelectView,
            FlipSwitchView : FlipSwitchView,
            BooleanInputView : BooleanInputView,
            FileLoaderView : FileLoaderView,
            SearchInputViewBase: SearchInputViewBase,
            SearchInputView: SearchInputView,
            BaseItemListView: BaseItemListView,
            ItemListView : ItemListView,
            GroupedItemListView : GroupedItemListView,
            NavBarViewModel : NavBarViewModel,
            NavBarView : NavBarView,
            SubNavBarView: SubNavBarView,
            SubNavBarViewModel: SubNavBarViewModel,
            ChartView : ChartView,
            BarChartView : ChartView,
            TabPanelView : TabPanelView,
            ProxyViewModel : ProxyViewModel,
            FormView : FormView,
            PopupView : PopupView,
            BaseCarouselView: BaseCarouselView,
            CarouselView : CarouselView,
            Application : Application,
            Module : Module,
            Navigation : Navigation,
            PopupModule : PopupModule,
            BasePaginationView:BasePaginationView,
            PaginationView:PaginationView,
            TableView:TableView,
            ProgressBarView : ProgressBarView,
            AccordionView : AccordionView,
            AutoCompleteView : AutoCompleteView,
            PickerView : PickerView,
            BreadcrumbsView : BreadcrumbsView,
            LoadingView : LoadingView,
            CollectionView: CollectionView,
            WizardView: WizardView
        }; 
    });

/**
Base <em>DynamicConfigurator</em> component. Provides and API, common for all <em>Dynamic UI Configurators</em>.

@class Lightsaber.UI.BaseConfigurator
@namespace Lightsaber
@module Lightsaber.UI
@extends Object

@since 9.2.0

@requires Lightsaber.Core

@constructor
@param {Object} [options] constructor's only parameter
@param {Object} [options.config] main configuration parameter

@examples none
**/
define('src/ui/dynamic/BaseDynamicConfigurator',[
    'underscore',
    'knockout',
    'knockout.mapping',
    'knockout.validation',
    'lightsaber.core'
], function(_, KO, KOMapping, KOValidation, Core) {
    
    

    var BaseConfigurator = function(options) {
        this.initialize(options);
    };

    _.extend(BaseConfigurator.prototype, {
        /**
        Default PATH separator character.

        @property PATH_SEP
        @protected
        @type {String}
        @default `'.'`
        **/
        PATH_SEP: '.',

        /**
        Default builder configuration property name.

        Defines the name of the property that describes which *Builder* should be used for which
        type.

        @property BUILDER_PROP
        @protected
        @type {String}
        @default `'builders.default'`
        **/
        BUILDER_PROP: 'builders.default',

        /**
        Default validator configuration property name.

        Defines the name of the property that describes which *Validator* should be used for which
        type.

        @property VALIDATOR_PROP
        @protected
        @type {String}
        @default `'validators.default'`
        **/
        VALIDATOR_PROP: 'validators.default',

        /**
        Default resolver configuration property name.

        Defines the name of the property that describes which *Resolver* should be used for which
        type.

        @property RESOLVER_PROP
        @protected
        @type {String}
        @default `'resolvers.default'`
        **/
        RESOLVER_PROP: 'resolvers.default',

        /**
        Main configuration property.

        @property {Object} config
        @protected
        @type {Object}
        @default `{}`
        **/
        config: {},

        /**
        Defines a hash of builders that were already requested (and as a result - instantiated), to
        serve as builders' cache.

        @property
        @private
        @type {Object}
        @default `{}`
        **/

        /**
        Defines a hash of validators that were already requested (and as a result - instantiated), to
        serve as validators' cache.

        @property
        @private
        @type {Object}
        @default `{}`
        **/

        /**
        Defines a hash of resolvers that were already requested (and as a result - instantiated), to
        serve as resolvers' cache.

        @property
        @private
        @type {Object}
        @default `{}`
        **/

        /**
        Merges configuration (if any) that is passed on `config` configuration parameter to the
        constructor.

        @method initialize
        @protected
        @param {Object} [options={}] constructor parameter
        @param {Object} [options.config={}] main configuration parameter
        **/
        initialize: function(options) {
            this.builders = {};
            this.validators = {};
            this.resolvers = {};

            options = options || {};
            this.config = $.extend(true, {}, this.config, options.config);

            var validationConfig = this.getConfig('validation');
            KOValidation.init(validationConfig, true);
        },

        /**
        Retrieves a confiruation item by its path, so for configuration that has:

        ```javascript
        {
            a: {
                b: {
                    c: 10
                }
            }
        }
        ```

        calling:

        ```javascript
        configurator.getConfig('a.b.c')
        ```

        retrieves `10`.
        
        @method getConfig
        @param {String} path path (or in simpler case - name) of the property to be retrieved
        @return {...} confifuration item that corresponds to the provided `path` parameter
        **/
        getConfig: function(path) {
            var result = Core.Utils.getValueByPath(this.config, path);
            return result;
        },

        /**
        Retrieves *Builder* that corresponds to the provided type. If no *Builder* is defined for the provided
        `type` parameter - the **default** *Builder* is retrieved instead.

        @method getBuilder
        @param {String} type type of the component for which the *Builder* should be retrieved
        @return {Lightsaber.UI.Builder} builder that corresponds to the provided `type` **or default builder**
        **/
        getBuilder: function(type) {
            var Builder, path;

            if(_.isUndefined(type)) {
                Builder = this._getDefaultBuilder();
            } else {
                path = this._constructBuilderPath(type);
                
                if(_.isUndefined(this.builders[path])) {
                    Builder = this.getConfig(path);

                    if(_.isUndefined(Builder)) {
                        Builder = this._getDefaultBuilder();
                    } else {
                        Builder = this.builders[path] = new Builder({
                            configurator: this
                        });
                    }
                } else {
                    Builder = this.builders[path];
                }
            }

            return Builder;
        },

        /**
        Retrieves *Validator* that corresponds to the provided type. If no *Validator* is defined for the provided
        `type` parameter - the **default** *Validator* is retrieved instead.

        @method getValidator
        @param {String} type type of the component for which the *Validator* should be retrieved
        @return {Lightsaber.UI.Validator} builder that corresponds to the provided `type` **or default builder**
        **/
        getValidator: function(type) {
            var Validator, path;

            if(_.isUndefined(type)) {
                Validator = this._getDefaultValidator();
            } else {
                path = this._constructValidatorPath(type);
                
                if(_.isUndefined(this.validators[path])) {
                    Validator = this.getConfig(path);

                    if(_.isUndefined(Validator)) {
                        Validator = this._getDefaultValidator();
                    } else {
                        Validator = this.validators[path] = new Validator({
                            config: {
                                resourceBundle: this.getConfig('resourceBundle')                            
                            }
                        });
                    }
                } else {
                    Validator = this.validators[path];
                }
            }

            return Validator;
        },

        /**
        Retrieves *Resolver* that corresponds to the provided type. If no *Resolver* is defined for the provided
        `type` parameter - the **default** *Resolver* is retrieved instead.

        @method getResolver
        @param {String} type type of the component for which the *Resolver* should be retrieved
        @return {Lightsaber.UI.Resolver} builder that corresponds to the provided `type` **or default builder**
        **/
        getResolver: function() {
            var defaultResolverPath = this._constructDefaultResolverPath();
            var DefaultResolver;

            if(_.isUndefined(this.resolvers[defaultResolverPath])) {
                DefaultResolver = this.getConfig(defaultResolverPath);

                if(_.isUndefined(DefaultResolver)) {
                    throw new Error('Default resolver must be defined at root level!');
                } else {
                    DefaultResolver = this.resolvers[defaultResolverPath] = new DefaultResolver();
                }
            } else {
                DefaultResolver = this.resolvers[defaultResolverPath];
            }

            return DefaultResolver;
        },

        /**
        Retrieves default *Builder*.

        @method _getDefaultBuilder
        @protected
        @return {Lightsaber.UI.Builder} default *Builder*
        **/
        _getDefaultBuilder: function() {
            var defaultBuilderPath = this._constructDefaultBuilderPath();
            var DefaultBuilder;

            if(_.isUndefined(this.builders[defaultBuilderPath])) {
                DefaultBuilder = this.getConfig(defaultBuilderPath);

                if(_.isUndefined(DefaultBuilder)) {
                    throw new Error('Default builder must be defined at root level!');
                } else {
                    DefaultBuilder = this.builders[defaultBuilderPath] = new DefaultBuilder({
                        configurator: this
                    });
                }
            } else {
                DefaultBuilder = this.builders[defaultBuilderPath];
            }

            return DefaultBuilder;
        },

        /**
        Retrieves default *Validator*.

        @method _getDefaultValidator
        @protected
        @return {Lightsaber.UI.Validator} default *Validator*
        **/
        _getDefaultValidator: function() {
            var defaultValidatorPath = this._constructDefaultValidatorPath();
            var DefaultValidator;

            if(_.isUndefined(this.validators[defaultValidatorPath])) {
                DefaultValidator = this.getConfig(defaultValidatorPath);

                if(_.isUndefined(DefaultValidator)) {
                    throw new Error('Default validator must be defined at root level!');
                } else {
                    DefaultValidator = this.validators[defaultValidatorPath] = new DefaultValidator({
                        config: {
                            resourceBundle: this.getConfig('resourceBundle')                            
                        }
                    });
                }
            } else {
                DefaultValidator = this.validators[defaultValidatorPath];
            }

            return DefaultValidator;
        },

        /**
        Constructs the path to the default *Builder* configuration property.

        @method _constructDefaultBuilderPath
        @protected
        @return {String} path
        **/
        _constructDefaultBuilderPath: function() {
            return this.BUILDER_PROP;
        },

        /**
        Constructs the path to the *Builder* configuration property, based on the provided type.

        @method _constructBuilderPath
        @protected
        @return {String} path
        **/
        _constructBuilderPath: function(type) {
            return type + this.PATH_SEP + this.BUILDER_PROP;
        },

        /**
        Constructs the path to the default *Validator* configuration property.

        @method _constructDefaultValidatorPath
        @protected
        @return {String} path
        **/
        _constructDefaultValidatorPath: function() {
            return this.VALIDATOR_PROP;
        },

        /**
        Constructs the path to the default *Resolver* configuration property.

        @method _constructDefaultResolverPath
        @protected
        @return {String} path
        **/
        _constructDefaultResolverPath: function() {
            return this.RESOLVER_PROP;
        },

        /**
        Constructs the path to the *Validator* configuration property, based on the provided type.

        @method _constructValidatorPath
        @protected
        @return {String} path
        **/
        _constructValidatorPath: function(type) {
            return type + this.PATH_SEP + this.VALIDATOR_PROP;
        },

        /**
        Clean the instance
        @method destroy
        **/
        destroy: function(){
            this.builders = null;
            this.validators = null;
            this.resolvers = null;
            this.config = null;
        }

    });

    _.extend(BaseConfigurator, {
        extend: Core.Utils.extend,
        mergeProperties: {
            config: 'merge'
        }
    });

    return BaseConfigurator;

});
/**
Default <em>Builder</em> component. Responsible for proper metadata - data - HTML mapping.

@class Lightsaber.UI.Builder
@namespace Lightsaber
@module Lightsaber.UI
@extends Object

@since 9.2.0

@requires Lightsaber.Core

@constructor
@param {Object} [options] constructor's only parameter
@param {Object} [options.config] main configuration parameter
@examples none
**/
define('src/ui/dynamic/builders/Builder',[
    'underscore',
    'knockout',
    'knockout.mapping',
    'knockout.validation',
    'lightsaber.core'
], function(_, KO, KOMapping, KOValidation, Core) {
    
    

    var Builder = function(options) {
        this.initialize(options);
    };

    _.extend(Builder.prototype, {
        /**
        Default properties.

        Used to augment metadata with required default properties that are missing from it.

        @property DEFAULT_PROPS
        @protected
        @type {Object}
        @default `{name: 'components', value: KO.observableArray()}`
        **/
        DEFAULT_PROPS: [
            // {name: 'components', value: KO.observableArray()}
        ],

        /**
        Default PATH separator character.

        @property PATH_SEP
        @protected
        @type {String}
        @default `'.'`
        **/
        PATH_SEP: '.',

        /**
        Default value to be given to a `value` property of a component, when there is none - neither in
        metadata nor in data.

        @property DEFAULT_VALUE
        @protected
        @type {String}
        @default `''`
        **/
        DEFAULT_VALUE: '',

        /**
        Stores `configurator` that was received via the constructor on the instance.

        @method initialize
        @protected
        @param {Object} [options={}] main configuration parameter as it was passed to the constructor
        **/
        initialize: function(options) {
            this.preInitialize(options);
            this.configurator = options.configurator;
            this.postInitialize(options);
        },

        preInitialize: function() {
            
        },

        postInitialize: function() {
            
        },
        /**
        Sets `configurator` to be used by the *Builder*.

        For more information see {{#crossLink "Lightsaber.UI.DynamicConfigurator"}}DynamicConfigurator{{/crossLink}}.

        @method setConfigurator
        @param {Lightsaber.UI.DynamicConfigurator} configurator main configuration
        **/
        setConfigurator: function(configurator) {
            this.configurator = configurator;
        },

        /**
        Sets `ViewModel` to be used by the *Builder*.
        For more information see {{#crossLink "Lightsaber.UI.DynamicViewModel"}}DynamicViewModel{{/crossLink}}.
        @method setViewModel
        @param {Lightsaber.UI.DynamicViewModel} viewModel *ViewModel* to be used
        **/
        setViewModel: function(viewModel) {
            this.viewModel = viewModel;
        },
        /**
        Retrieves `ViewModel` that is used by the *Builder*.
        For more information see {{#crossLink "Lightsaber.UI.DynamicViewModel"}}DynamicViewModel{{/crossLink}}.
        @method setViewModel
        @return {Lightsaber.UI.DynamicViewModel} viewModel *ViewModel*
        **/
        getViewModel: function() {
            return this.viewModel;
        },
        /**
        Maps the metadata, while getting "real" values from the data.

        @method buildMapping
        @param {ObservableObject} data observable (mapped) object that represents the data for 
        the current place in the data JSON.
        **/
        buildMapping: function(data, metadata, parentPath) {
            var viewModel = this.getViewModel();
            var mapping = {components: {}, value: {}};
            var observe, copy;

            metadata = metadata || {};
            data = data || {};
            parentPath = parentPath || '';

            var configMapping = viewModel.getConfig('mapping');

            if(configMapping) {
                observe = configMapping.observe;
                copy = configMapping.copy;
            }

            mapping.observe = _.extend([], ['value', 'visible', 'enabled', 'components', 'components.value']);
            mapping.copy = _.extend([[], 'validations', 'mapping', 'options', 'cardinality']);

            mapping.observe = mapping.observe.concat(observe);
            mapping.copy = mapping.copy.concat(copy);

            mapping.components.key = this._createKeyMethod(data);
            mapping.components.create = this._createCreateMethod(data, metadata, parentPath);

            mapping.value.create = function(options) { 
                var result;
                if(_.isObject(options.data)) {
                    result = KOMapping.fromJS(options.data);
                } else {
                    result = KO.observable(options.data);
                    result = result.extend({backup: true});
                }

                return result;
            };

            return mapping; 
        },

        _createKeyMethod: function(data) {
            var builder = this;
            return function(options) {
                return builder.key(options, data);
            };
        },

        _createCreateMethod: function(data, metadata, parentPath) {
            var builder = this;
            return function(options) {
                return builder.create(options, data, metadata, parentPath);
            };
        },

        /**
        Method responsible for `key` configuration for mapping plugin: [Knockout Mapping Plugin](http://knockoutjs.com/documentation/plugins-mapping.html).
        
        @method key
        @param {ObservableObject} contextData observable (mapped) object that represents the data for 
        the current place in the data JSON.
        **/
        key: function(data) {
            return KO.unwrap(data.id);
        },

        /**
        Method responsible for `create` configuration for mapping plugin: [Knockout Mapping Plugin](http://knockoutjs.com/documentation/plugins-mapping.html).
        
        @method create
        @param {Object} options current data to be mapped
        @param {ObservableObject} data observable (mapped) object that represents the data for 
        the current place in the data JSON. 
        @param {ObservableObject} path current path in the metadata
        **/
        create: function(options, data, metadata, parentPath) {      
            var viewModel = this.getViewModel();
            var createUniqueId = viewModel.getConfig('createUniqueId');
            var path, builder, contextMapping, mappedData, item;

            options.data.template = options.data.template || 'default';

            if(!options.data.metadataPath && options.parent && options.parent.metadataPath && options.parent.components) {
                options.data.metadataPath = options.parent.metadataPath + '.components.' + options.parent.components.peek().length;
            }

            if(_.isArray(options.data.components)) {
                for (var i = 0, length = options.data.components.length; i < length; i++) {
                    item = options.data.components[i];
                     
                    if(options.data.metadataPath) {
                        item.metadataPath = options.data.metadataPath + '.components.' + i;
                    } else {
                        item.metadataPath = 'metadata.components.' + i;
                    }  

                    if(_.isUndefined(item.uniqueId) && createUniqueId) {
                        item.uniqueId = options.data.uniqueId + '.' + i;                       
                    }

                    item.index = i;
                }
            }

            path = this._getDataPath(options.data, parentPath);

            this._mapProperties(options.data);
            this._syncValues(options.data, data, path);

            builder = this.configurator.getBuilder(options.data.type);
            contextMapping = builder.buildMapping(data, metadata, path);
            
            mappedData = KOMapping.fromJS(options.data, contextMapping);

            if(mappedData.mask) {
                if(KO.observable(mappedData.value)) {
                    mappedData.value = mappedData.value.extend({mask: mappedData.mask});                    
                }
            }

            this._addValidations(mappedData);
            this._subscribe(mappedData, data, parentPath);
            this._mapReferenceData(mappedData, metadata);            
            this._addDependencies(mappedData);

            viewModel.addPath(path, mappedData);

            return mappedData;
        },

        _getDataPath: function(componentMetadata, parentPath) {            
            var path;

            if(componentMetadata && componentMetadata.path) {
                if(componentMetadata.path.indexOf('/') === 0) {
                    path = componentMetadata.path;                                        
                } else {
                    if(parentPath) {
                        path = parentPath + this.PATH_SEP + componentMetadata.path;    
                    } else {
                        path = componentMetadata.path;
                    }                
                }
            } else {
                if(!parentPath) {
                    path = componentMetadata.id;
                } else {
                    if(typeof componentMetadata.id === 'undefined') {
                        path = parentPath;
                    } else {
                        path = parentPath + this.PATH_SEP + componentMetadata.id;
                    }
                }
            }

            if(path && path.indexOf('/') === 0) {
                path = path.slice(1);
            }

            return path;
        },

        _syncValues: function(mappedData, data, path) {
            var value;

            if(!mappedData.components) {
                if(_.isUndefined(mappedData.value)) {
                    value = Core.Utils.getValueByPath(data, path, true);

                    if(_.isUndefined(value)) {
                        mappedData.value = '';
                    }
                } else {
                    value = Core.Utils.setOrInitValueByPath(data, path, KO.unwrap(mappedData.value), true);                
                }

                if(!_.isUndefined(value)) {
                    if(_.isObject(value)) {
                        mappedData.value = _.extend({}, mappedData.value, value); 
                    } else {
                        mappedData.value = value;  
                    }
                }
            }
        },

        _subscribe: function(mappedData, data, parentPath) {
            var builder = this;
            var viewModel = builder.getViewModel();
            var path, dataComponents;
            var initial = true;

            if(mappedData && mappedData.value) {           
                if(mappedData.value.isValidating) {
                    mappedData.value.isValidating.subscribe(function() {     
                        initial = false;                                        
                        if(!mappedData.value.isValidating()){
                            if(mappedData.value.isValid()) {
                                builder._updateValueAfterSuccessfullValidation(mappedData, data, parentPath);
                            } else {
                                viewModel.validate(false);
                            }
                        }
                    });
                
                    mappedData.value.isValid.subscribe(function() {
                        if(!mappedData.value.isValidating()){
                            if(mappedData.value.isValid()) {
                                builder._updateValueAfterSuccessfullValidation(mappedData, data, parentPath);
                            } else {
                                viewModel.validate(false);
                            }
                        }
                    });
                }

                if(_.isFunction(mappedData.value)) {
                    mappedData.value.subscribe(function() {
                        initial = false;  
                        viewModel.markDirty();

                        if(mappedData.value.isValidating && mappedData.value.isValid) {
                            if(!mappedData.value.isValidating()) {
                                if(mappedData.value.isValid()) {
                                    builder._updateValueAfterSuccessfullValidation(mappedData, data, parentPath);
                                } else {
                                    viewModel.markInvalid();
                                }
                            }
                        } else if(!mappedData.value.isValidating) {
                            if(mappedData.value.isValid && mappedData.value.isValid()) {
                                builder._updateValueAfterSuccessfullValidation(mappedData, data, parentPath);
                            }
                        }
                    });                    
                } else if(_.isObject(mappedData.value)) {
                    this._subscribeComplex(mappedData);
                }
            } else {
                path = this._getDataPath(mappedData, parentPath);
                dataComponents = mappedData.components;

                dataComponents.subscribe(function(components) {
                    var dataPath = 'data.' + path;
                    var dataObj = viewModel.getValueByPath(dataPath, true);

                    if(!_.isUndefined(dataObj)) {
                        _.each(dataObj, function(value, key) {
                            var item = _.find(components, function(component) {
                                return component.id === key;
                            });        

                            if(_.isUndefined(item)) {
                                delete dataObj[key];
                            }
                        });                   
                    }

                    var parentPath = dataPath.split('.').slice(0, -1).join('.');
                    var name = dataPath.split('.').slice(-1);
                    var parent = viewModel.getValueByPath(parentPath, true);

                    if(!_.isUndefined(parent)) {
                        if(_.isEmpty(parent[name])) {
                            delete parent[name];
                        }                        
                    }
                });
            }
        },

        _subscribeComplex: function(mappedData) {
            var viewModel = this.getViewModel();
            var first = true;
            var changedValue;

            KO.computed(function() {
                if(first) {
                    first = false;
                    KOMapping.toJS(mappedData.value);   
                } else {
                    changedValue = KOMapping.toJS(mappedData.value);
                    KOMapping.fromJS(changedValue, mappedData.value);

                    viewModel.markDirty();
                    mappedData.value.isValid.valueHasMutated();
                }
            });
        },

        // If finished validating and the value is valid
        // allow value update and revalidate the ViewModel.
        // If finished validating and the value is invalid,
        // set ViewModel state to invalid.
        // If not finished validating - skip.
        _updateValueAfterSuccessfullValidation: function(mappedData, data, parentPath, skipValidation) {
            var viewModel = this.getViewModel();
            var path = this._getDataPath(mappedData, parentPath);
            var value;

            if('__ko_mapping__' in mappedData.value) {
                value  = KOMapping.toJS(mappedData.value);
            } else {
                value = KO.unwrap(mappedData.value);
            }
            
            Core.Utils.setOrInitValueByPath(data, path, value);
            viewModel.notifyPath(path, value);

            if(!skipValidation) {
                viewModel.validate(false);                
            }
        },

        _mapProperties: function(mappedData) {
            if(mappedData && mappedData.mapping) {
                _.each(mappedData.mapping, function(value, key) {
                    mappedData[key] = mappedData[value];
                    if(_.isObject(mappedData[value])) {
                        delete mappedData[value];
                    }
                });                
            }
        },

        _mapReferenceData: function(mappedData, metadata) {
            var validValues;

            if(mappedData && mappedData.validValues && _.isString(mappedData.validValues)) {
                validValues = Core.Utils.getValueByPath(metadata, mappedData.validValues);
                mappedData.validValues = validValues;
            }
        }, 

        _addValidations: function(mappedData) {
            var validations;

            if(mappedData && mappedData.value) {
                validations = mappedData.validations;

                if(validations && validations.length > 0) {
                    for (var i = 0, length = validations.length; i < length; i++) {
                        this._augmentValidation(mappedData, validations[i]);
                    }
                } else {
                    this._augmentPlaceholderValidations(mappedData.value);
                }
            }
        },

        _augmentValidation: function(mappedData, rule) {
            var customRule = this._buildRule(mappedData, rule);
            this._attachValidation(mappedData, customRule);
        },

        _buildRule: function(mappedData, rule) {
            var ruleName = _.keys(rule)[0];
            var validator = this.configurator.getValidator(mappedData.type);
            var customRule = validator.getRule(ruleName);
            var viewModel = this.getViewModel();
            var resourceBundle = viewModel.getConfig('resourceBundle');
            var i18nMessage, onlyIf;

            customRule.validation.params = rule[ruleName];
            customRule.validation.context = mappedData;

            if(!_.isUndefined(rule.message)) {
                if(resourceBundle) {
                    i18nMessage = resourceBundle.getString(rule.message);                        
                }

                if(_.isUndefined(i18nMessage)) {
                    customRule.validation.message = rule.message;                                            
                } else {
                    customRule.validation.message = i18nMessage;
                }
            }

            if(customRule.validation.onlyIf) {
                onlyIf = customRule.validation.onlyIf;

                customRule.validation.onlyIf = function() {
                    return onlyIf(mappedData);
                };
            }

            if(_.has(rule, 'target')) {
                customRule.target = rule.target;
            }

            return customRule;
        },

        _attachValidation: function(mappedData, rule) {
            var viewModel = this.getViewModel();
            var targetObservable;

            if(KO.isObservable(mappedData.value)) {
                mappedData.value.extend(rule);
            } else if(_.isObject(mappedData.value)) {
                this._augmentPlaceholderValidations(mappedData.value); 

                if(_.has(rule, 'target')) {
                    targetObservable = Core.Utils.getValueByPath(mappedData, rule.target, true);
                    
                    targetObservable.extend(rule);

                    targetObservable.isValid.subscribe(function() {
                        if(!targetObservable.isValidating()){
                            if(targetObservable.isValid()) {
                                viewModel.validate(false);
                            } else {
                                viewModel.markInvalid();
                            }
                        }
                    });
                } else {                        
                    var createMappedValueSubscription = _.once(function() {
                        KOMapping.toJS(mappedData.value);
                    });

                    var dummyObservable = KO.observable(mappedData.value).extend(rule);

                    KO.computed(function() {
                        createMappedValueSubscription();
                        dummyObservable.valueHasMutated();
                    });
                }
            }
        },

        /**
        Augments `value` observable with "empty" validation properties to prevent
        KO Validation plugin from trying to validate it even if it doesn't have
        any validations attached to it (since those may be dynamic, even for the 
        same property).

        @method _augmentPlaceholderValidations
        @protected
        @param {Observbale Object} observable observable object (current context) 
        that should be "faked" into valid state
        **/
        _augmentPlaceholderValidations: function(observable) {
            observable.isValid = KO.observable(true);
            observable.isValidating = KO.observable(false);
            observable.isModified = KO.observable(false);
        },

        _addDependencies: function(mappedData) {
            var resolveOnLoad = this.configurator.getConfig('deps.resolveOnLoad');
            var depConfig = {};
            var state;
            var dep, rule, method;

            mappedData.visible = mappedData.visible || KO.observable(true);
            mappedData.enabled = mappedData.enabled || KO.observable(true);                    

            if(!_.isUndefined(mappedData.deps)) {
                for (var i = 0; i < mappedData.deps.length; i++) {
                    state = {};
                    dep = mappedData.deps[i];

                    rule = dep.rule;
                    method = this._getResolverMethod(rule);

                    if(method) {                        
                        depConfig = this._getDepConfig(mappedData, dep);

                        state.visible = depConfig.target.visible;
                        state.enabled = depConfig.target.enabled;
                        
                        this._subscribeToChangeForDeps(method, mappedData, depConfig.source, depConfig.target, state, dep);

                        if(!_.isUndefined(dep.resolveOnLoad)) {
                            resolveOnLoad = dep.resolveOnLoad;
                        }

                        if(resolveOnLoad) {
                            if(depConfig.source.isArray && depConfig.source.isArray()) {
                                method.call(mappedData, depConfig.source, depConfig.target, state, dep);
                            } else if(KO.isObservable(depConfig.source)) {
                                method.call(mappedData, depConfig.source, depConfig.target.value, state, dep);
                            } else {
                                method.call(mappedData, depConfig.source.value, depConfig.target.value, state, dep);
                            }
                        }          
                    }

                }
            }
        },

        _getDepConfig: function(mappedData, dep) {
            var depConfig = {};

            if(_.has(dep, 'sourcePath')) {
                depConfig.source = Core.Utils.getValueByPath(mappedData, dep.sourcePath, true);
            } else if(_.has(dep, 'sourceIdPath')) {
                depConfig.source = Core.Utils._getValueByPropPath(mappedData, dep.sourceIdPath, 'id', true);
            } else {
                throw new Error('No path is defined for dependency source: ', mappedData.id);                
            }

            if(_.has(dep, 'targetPath')) {
                depConfig.target = Core.Utils.getValueByPath(mappedData, dep.targetPath, true);
            } else if(_.has(dep, 'targetIdPath')) {
                depConfig.target = Core.Utils._getValueByPropPath(mappedData, dep.targetIdPath, 'id', true);
            } else {
                throw new Error('No path is defined for dependency target: ', mappedData.id);                
            }
            return depConfig;
        },

        _subscribeToChangeForDeps: function(method, mappedData, source, target, state, dep) {
            if(source.isArray && source.isArray()) {
                source.subscribe(function() {
                    method.call(mappedData, source, target, state, dep);
                });
            } else if(KO.isObservable(source)) {
                source.subscribe(function() {
                    method.call(mappedData, source.value, target.value, state, dep);
                }); 
            } else {
                if(KO.isObservable(source.value)) {
                    source.value.subscribe(function() {
                        method.call(mappedData, source.value, target.value, state, dep);
                    });
                }
            }
        },

        _getResolverMethod: function(rule) {
            var method = this.viewModel[rule];
            var resolver;

            if(_.isUndefined(method)) {
                resolver = this.configurator.getResolver();
                method = resolver[rule];
            }

            return method;
        }
    });

    _.extend(Builder, {
        extend: Core.Utils.extend
    });

    return Builder;

});
/**
Base <em>Validator</em> component. 

@class Lightsaber.UI.BaseValidator
@namespace Lightsaber
@module Lightsaber.UI
@extends Object

@since 9.2.0

@requires Lightsaber.Core

@constructor
@param {Object} [options] constructor's only parameter
@param {Object} [options.config] main configuration parameter

@examples none
**/
define('src/ui/dynamic/validators/BaseValidator',[
    'underscore',
    'knockout',
    'knockout.mapping',
    'knockout.validation',
    'lightsaber.core'
], function(_, KO, KOMapping, KOValidation, Core) {
    
    

    var BaseValidator = function(options) {
        this.initialize(options);
    };

    _.extend(BaseValidator.prototype, {
        /**
        Default PATH separator character.

        @property PATH_SEP
        @protected
        @type {String}
        @default `'.'`
        **/
        PATH_SEP: '.',

        /**
        Default rules configuration property name.

        Defines the name of the property that describes all rules available on the validator.

        @property RULES_PROP
        @protected
        @type {String}
        @default `'rules'`
        **/
        RULES_PROP: 'rules',

        initialize: function(options) {
            options = options || {};
            this.config = $.extend(true, {}, this.config, options.config);
        },

        /**
        Retrieves a confiruation item by its path, so for configuration that has:
        ```javascript
        {
            a: {
                b: {
                    c: 10
                }
            }
        }
        ```
        calling:
        ```javascript
        configurator.getConfig('a.b.c')
        ```
        retrieves `10`.
        @method getConfig
        @param {String} path path (or in simpler case - name) of the property to be retrieved
        @return {...} confifuration item that corresponds to the provided `path` parameter
        **/
        getConfig: function(path) {
            var result = Core.Utils.getValueByPath(this.config, path);
            return result;
        },
        
        getRule: function(name) {
            var resourceBundle = this.getConfig('resourceBundle');
            var customRule = this.getConfig(this.RULES_PROP + this.PATH_SEP + name);
            var mergedRule, augmentedRule;

            if(customRule) {
                mergedRule = _.extend({}, KOValidation.rules[name], customRule);

                if(mergedRule && mergedRule.validator && _.isString(mergedRule.validator)) {
                    mergedRule.validator = _.bind(this[mergedRule.validator], this);
                }

                if(mergedRule && mergedRule.onlyIf && _.isString(mergedRule.onlyIf)) {
                    mergedRule.onlyIf = _.bind(this[mergedRule.onlyIf], this);
                }

                augmentedRule = {validation: mergedRule};
            } else {
                augmentedRule = {validation: _.extend({}, KOValidation.rules[name])};
            }

            if(resourceBundle) {
                augmentedRule.validation.message = resourceBundle.getString(augmentedRule.validation.message) || augmentedRule.validation.message;                
            }
            return augmentedRule;
        },

        remoteValidator: function(value, url, callback) {
            var model = new Core.RESTModel(null, {
                rest : {
                    create: {
                        url: url
                    }
                }
            });

            model.set('value', value);
            
            model.on('sync', function(model, data) {
                if(data && !_.isUndefined(data.isValid) && !_.isUndefined(data.message)) {
                    callback(data);                                
                } else if(_.isObject(data)) {
                    callback(data.isValid); 
                }
            });

            model.save();
        }
    });

    _.extend(BaseValidator, {
        extend: Core.Utils.extend,
        mergeProperties: {
            config: 'merge'
        }
    });

    return BaseValidator;

});
/**
Default <em>Validator</em> component. 

@class Lightsaber.UI.Validator
@namespace Lightsaber
@module Lightsaber.UI
@extends Lightsaber.UI.BaseValidator

@since 9.2.0

@requires Lightsaber.Core

@constructor
@param {Object} [options] constructor's only parameter
@param {Object} [options.config] main configuration parameter

@examples none
**/
define('src/ui/dynamic/validators/Validator',[
    'underscore',
    'knockout',
    'knockout.mapping',
    'knockout.validation',
    'lightsaber.core',
    'src/ui/dynamic/validators/BaseValidator'
], function(_, KO, KOMapping, KOValidation, Core, BaseValidator) {
    
    

    var Validator = BaseValidator.extend({
        config: {
            rules: {
                remote: {
                    async: true,
                    validator: 'remoteValidator',
                    message: 'The value is invalid.'
                }
            }
        }
    });

    _.extend(Validator, {
        extend: Core.Utils.extend,
        mergeProperties: {
            config: 'merge'
        }
    });

    return Validator;

});
/**
Base <em>Resolver</em> component. 

@class Lightsaber.UI.BaseResolver
@namespace Lightsaber
@module Lightsaber.UI
@extends Object

@since 9.2.0

@requires Lightsaber.Core

@constructor
@param {Object} [options] constructor's only parameter
@param {Object} [options.config] main configuration parameter

@examples none
**/
define('src/ui/dynamic/resolvers/BaseResolver',[
    'underscore',
    'knockout',
    'knockout.mapping',
    'knockout.validation',
    'lightsaber.core'
], function(_, KO, KOMapping, KOValidation, Core) {
    
    

    var BaseResolver = function(options) {
        this.initialize(options);
    };

    _.extend(BaseResolver.prototype, {
        initialize: function(options) {
            options = options || {};
            this.config = $.extend(true, {}, this.config, options.config);
        }
    });

    _.extend(BaseResolver, {
        extend: Core.Utils.extend,
        mergeProperties: {
            config: 'merge'
        }
    });

    return BaseResolver;

});
/**
Default <em>Resolver</em> component. 

@class Lightsaber.UI.Resolver
@namespace Lightsaber
@module Lightsaber.UI
@extends Lightsaber.UI.BaseResolver

@since 9.2.0

@requires Lightsaber.Core

@constructor
@param {Object} [options] constructor's only parameter
@param {Object} [options.config] main configuration parameter

@examples none
**/
define('src/ui/dynamic/resolvers/Resolver',[
    'underscore',
    'knockout',
    'knockout.mapping',
    'knockout.validation',
    'lightsaber.core',
    'src/ui/dynamic/resolvers/BaseResolver'
], function(_, KO, KOMapping, KOValidation, Core, BaseResolver) {
    
    

    var Resolver = BaseResolver.extend({
        disableWhenEmpty: function(source, target, state) {
            var value = KO.unwrap(source);

            if(value === '' || _.isUndefined(value)) {
                state.enabled(false);
            } else {
                state.enabled(true);
            }
        },

        hideWhenEmpty: function(source, target, state) {
            var value = KO.unwrap(source);

            if(value === '' || _.isUndefined(value)) {
                state.visible(false);
            } else {
                state.visible(true);
            }
        },
        
        disableAndHideWhenEmpty: function(source, target, state) {
            var value = KO.unwrap(source);

            if(value === '' || _.isUndefined(value)) {
                state.enabled(false);
                state.visible(false);
            } else {
                state.enabled(true);
                state.visible(true);
            }
        }
    });

    return Resolver;

});

define('tpl!src/ui/dynamic/templates/containerTemplate.html', function() {return function(obj) { var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<div class="form-element-container">    <label class="form-element--label" data-bind="text: $data.label"></label>    <!-- ko foreach: $data.components -->        <!-- ko template: {type: $data.template, data: $data} --><!-- /ko -->     <!-- /ko --></div>');}return __p.join('');}});


define('tpl!src/ui/dynamic/templates/textTemplate.html', function() {return function(obj) { var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<div class="form-element" data-bind="visible: $data.visible, css: {\'is-mandatory\': $data.mandatory}">    <label class="form-element--label" data-bind="text: $data.label"></label>    <input type="text" class="form-element--control" data-bind="value: $data.value, enable: $data.enabled">    <span class="form-element--error-message" data-bind="validationMessage: $data.value"></span></div>');}return __p.join('');}});


define('tpl!src/ui/dynamic/templates/numberTemplate.html', function() {return function(obj) { var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<div class="form-element" data-bind="visible: $data.visible, css: {\'is-mandatory\': $data.mandatory}">    <label class="form-element--label" data-bind="text: $data.label"></label>    <input type="number" class="form-element--control" data-bind="value: $data.value, attr: {step: $data.step, min: $data.min, max: $data.max}">    <span class="form-element--error-message" data-bind="validationMessage: $data.value"></span></div>');}return __p.join('');}});


define('tpl!src/ui/dynamic/templates/textareaTemplate.html', function() {return function(obj) { var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<div class="form-element" data-bind="visible: $data.visible, css: {\'is-mandatory\': $data.mandatory}">    <label class="form-element--label" data-bind="text: $data.label"></label>    <textarea class="form-element--control" data-bind="value: $data.value, enable: $data.enabled"></textarea>    <span class="form-element--error-message" data-bind="validationMessage: $data.value"></span></div>');}return __p.join('');}});


define('tpl!src/ui/dynamic/templates/selectTemplate.html', function() {return function(obj) { var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<div class="form-element" data-bind="visible: $data.visible, css: {\'is-mandatory\': $data.mandatory}">    <label class="form-element--label" data-bind="text: $data.label"></label>    <select class="form-element--control"        data-bind="            options: $data.validValues,            optionsText: \'label\',            optionsValue: \'id\',            value: $data.value,             enable: $data.enabled">    </select>    <span class="form-element--error-message" data-bind="validationMessage: $data.value"></span></div>');}return __p.join('');}});


define('tpl!src/ui/dynamic/templates/checkboxTemplate.html', function() {return function(obj) { var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<div class="form-element" data-bind="visible: $data.visible, css: {\'is-mandatory\': $data.mandatory}">    <label class="form-element--label" data-bind="text: $data.label, attr: {for: $data.uniqueId}"></label>    <!-- ko if: $data.validValues -->        <input type="checkbox" class="form-element--control"             data-bind="checked: $data.validValues, attr: {value: $data.value, id: $data.uniqueId}, enable: $data.enabled">    <!-- /ko -->    <!-- ko ifnot: $data.validValues -->        <input type="checkbox" class="form-element--control"             data-bind="checked: $data.value, enable: $data.enabled, attr: {id: $data.uniqueId}">    <!-- /ko -->    <span class="form-element--error-message" data-bind="validationMessage: $data.value"></span></div>');}return __p.join('');}});


define('tpl!src/ui/dynamic/templates/radioTemplate.html', function() {return function(obj) { var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<div class="form-element" data-bind="visible: $data.visible, css: {\'is-mandatory\': $data.mandatory}">    <label class="form-element--label" data-bind="text: $data.label"></label>    <div class="form-element--control-group" data-bind="foreach: $data.validValues">        <span class="form-element--control-container">            <label class="form-element--label"                 data-bind="text: $data.label, attr: {for: $index.apply($parent)}"></label>            <input type="radio" class="form-element--control"                 data-bind="checked: $parent.value, attr: {value: $data.id, name: $parent.name, id: $index.apply($parent)}, enable: $parent.enabled">        </span>    </div>    <span class="form-element--error-message" data-bind="validationMessage: $data.value"></span></div>');}return __p.join('');}});


define('tpl!src/ui/dynamic/templates/dateTemplate.html', function() {return function(obj) { var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<div class="form-line">    <label class="form-line-label" data-bind="text: $data.label"></label>    <input type="date" class="form-control" data-bind="value: $data.value"></div>');}return __p.join('');}});


define('tpl!src/ui/dynamic/templates/genericWidgetTemplate.html', function() {return function(obj) { var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<div data-bind="view: id"></div>');}return __p.join('');}});

/**
Generic <em>DynamicConfigurator</em> component. Provides main, and easily extendible, configuration point.

@class Lightsaber.UI.DynamicConfigurator
@namespace Lightsaber
@module Lightsaber.UI
@extends Object

@since 9.2.0

@requires Lightsaber.Core

@constructor
@param {Object} [options] constructor's only parameter
@param {Object} [options.config] main configuration parameter

@examples none
**/
define('src/ui/dynamic/DynamicConfigurator',[
    'underscore',
    'knockout',
    'knockout.mapping',
    'knockout.validation',
    'lightsaber.core',
    'src/ui/dynamic/BaseDynamicConfigurator',
    'src/ui/dynamic/builders/Builder',
    'src/ui/dynamic/validators/Validator',
    'src/ui/dynamic/resolvers/Resolver',
    'tpl!src/ui/dynamic/templates/containerTemplate.html',
    'tpl!src/ui/dynamic/templates/textTemplate.html',
    'tpl!src/ui/dynamic/templates/numberTemplate.html',
    'tpl!src/ui/dynamic/templates/textareaTemplate.html',
    'tpl!src/ui/dynamic/templates/selectTemplate.html',
    'tpl!src/ui/dynamic/templates/checkboxTemplate.html',
    'tpl!src/ui/dynamic/templates/radioTemplate.html',
    'tpl!src/ui/dynamic/templates/dateTemplate.html',
    'tpl!src/ui/dynamic/templates/genericWidgetTemplate.html',
], function(_, KO, KOMapping, KOValidation, Core, BaseDynamicConfigurator,

    Builder,
    Validator,
    Resolver,

    containerTemplate,
    textTemplate,
    numberTemplate,
    textareaTemplate,
    selectTemplate,
    checkboxTemplate,
    radioTemplate,
    dateTemplate,
    genericWidgetTemplate
) {
    
    

    var DynamicConfigurator = BaseDynamicConfigurator.extend({
        /**
        Main configuration property.

        ###### Default:
        
        ```javascript
        {
            builders: {
                'default': Builder
            },
            validators: {
                'default': Validator
            },
            resolvers: {
                'default': Resolver
            },
            dependecies: {

            },
            validation: {
                insertMessages: false,
                decorateInputElement: true,
                errorsAsTitle: false,
                errorElementClass: 'is-invalid',
                grouping: {
                    deep: true
                }
            }, 
            templates: {
                'default': containerTemplate,
                container: containerTemplate,
                text: textTemplate,
                number: numberTemplate,
                textarea: textareaTemplate,
                select: selectTemplate,
                checkbox: checkboxTemplate,
                radio: radioTemplate,
                date: dateTemplate,
                widget: genericWidgetTemplate
            }
        }
        ```

        @property {Object} config
        @protected
        @type {Object}
        **/
        config : {
            builders: {
                'default': Builder
            },
            validators: {
                'default': Validator
            },
            resolvers: {
                'default': Resolver
            },
            deps: {
                resolveOnLoad: true
            },
            validation: {
                insertMessages: false,
                decorateInputElement: true,
                errorsAsTitle: false,
                errorElementClass: 'is-invalid',
                grouping: {
                    deep: true
                }
            },  
            templates: {
                'default': containerTemplate,
                container: containerTemplate,
                text: textTemplate,
                number: numberTemplate,
                textarea: textareaTemplate,
                select: selectTemplate,
                checkbox: checkboxTemplate,
                radio: radioTemplate,
                date: dateTemplate,
                widget: genericWidgetTemplate
            }
        }
    });

    return DynamicConfigurator;

});

define('tpl!src/ui/dynamic/templates/mainTemplate.html', function() {return function(obj) { var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<div class="form-container" data-bind="foreach: $data.metadata.components">    <div data-bind="template: {type: $data.template, data: $data}"></div>        </div>');}return __p.join('');}});

/**
Generic <em>DynamicView</em> component.

## Template

```html
<section data-bind="foreach: components">
    <div data-bind="template: {module: subtemplates[type()], data: $data}"></div>         
</section>
```

@class Lightsaber.UI.DynamicView
@namespace Lightsaber
@module Lightsaber.UI
@extends Lightsaber.Core.View

@since 9.2.0

@requires Lightsaber.Core

@constructor
@param {Object} [options] constructor's only parameter
@param {Object} [options.config] main configuration parameter
@param {String} [options.config.template] main <em>DynamicView</em> template  
@param {String} [options.config.autoRender=true] whether <em>DynamicView</em> should render immediately or wait for data from <em>ViewModel</em>
@param {String} [options.config.vmKeys] mapping of expected name of <em>ViewModel</em> properties
property to its actual name in the specific <em>ViewModel</em> that this <em>DynamicView</em> 
receives at runtime.

@examples none
**/
define('src/ui/dynamic/DynamicView',[
    'underscore',
    'knockout',
    'lightsaber.core',
    'src/ui/dynamic/DynamicConfigurator',
    'tpl!src/ui/dynamic/templates/mainTemplate.html'
], function(_, KO, Core, DynamicConfigurator, mainTemplate) {
    
    

        
    var DynamicView = Core.View.extend({
        
        config: {
            template: mainTemplate
        },

        preRender: function() {
            this._initConfigurator();
            this.viewModel.on('reload', this._reload, this);
        },

        _initConfigurator: function() {
            var configuratorConfig = this.getConfig('configurator');
            var ConfiguratorClass = DynamicConfigurator;
            var configuratorInstance;

            if(!_.isUndefined(configuratorConfig)) {
                if(typeof configuratorConfig === 'function') {
                    ConfiguratorClass = configuratorConfig; 
                    configuratorConfig = {};
                }
                
                configuratorInstance = new ConfiguratorClass({
                    config: configuratorConfig
                });                    

                this.viewModel.setDynamicConfigurator(configuratorInstance);
            }
        },

        _reload: function() {
            KO.cleanNode(this.root);
            this.$root.empty();

            this._handleTemplate(); // includes template handling
            this._applyDataBindings();
        },

        _handleInlineView: function(element, viewProps, context) {
            var scope = this.getConfig('scope') || this.scope;
            var Component = Core.Utils.getValueByPath(scope, viewProps.name);

            var newContext = _.extend({}, context);
            delete newContext.options;

            _.each(newContext.mapping, function(value, key) {
                newContext[key] = Core.Utils.getValueByPath(newContext, value, true);
            });

            var viewModel = new Core.ObservableViewModel({
                data: newContext,
                bindingContext: newContext
            });

            var options = _.extend({}, {
                el: element,
                viewModel: viewModel,
                config: {
                    parentViewModel: this.viewModel
                }
            }, context.options);

            this.create(viewProps.uniqueId, Component, options);
        },

        _createContext: function(observable) {
            var Context = this._getKnockoutContext(observable);
            var handler = _.bind(this._handleInlineView, this);
            handler.view = this;

            var vmPath = this.getConfig('vmPath');
            if(_.isUndefined(observable)) {
                observable = this.viewModel.get(true);

                if(!_.isUndefined(vmPath)) {
                    observable.metadata = this.viewModel.getValueByPath(vmPath, true);
                }
            }

            Context.prototype = observable;
            var context = new Context(this.vmKeys, handler);
            return context;
        }
    });

    return DynamicView;

});

define('tpl!src/ui/dynamic/templates/mainLazyTemplate.html', function() {return function(obj) { var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<div class="form--container">                   <div class="form" data-point="form">                       <div class="form--content" data-bind="foreach: $data.metadata.components" data-point="formContent">            <div data-bind="template: {type: $data.template, data: $data}"></div>        </div>    </div></div>');}return __p.join('');}});


define('tpl!src/ui/dynamic/templates/innerLazyTemplate.html', function() {return function(obj) { var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<div class="form--inner-container">    <div class="form-container" data-bind="foreach: $data.metadata.components">        <div data-bind="template: {type: $data.template, data: $data}"></div>    </div></div>');}return __p.join('');}});

/**
"Lazy" <em>DynamicView</em> component. The idea is that the templates **may choose** to **not**
render immediately, rather to show only partial view (i.e. a title) and render the rest on demand.

## Template

```html
<section data-bind="foreach: components">
    <div data-bind="template: {module: subtemplates[type()], data: $data}"></div>         
</section>
```

## Possible (example) CSS for sliding into the next level of the nested lazy DynamicView

```css
.form--container {
    position: relative;
    margin: 0 auto;
    overflow: hidden;
    width: 400px;
    height: 500px;
}

.form {
    position: absolute;
    left: 0;    
}

.form--content, .form--inner-container {
    width: 400px;
}

.form > div {
    position: relative;
    float: left;
}
```

@class Lightsaber.UI.DynamicView
@namespace Lightsaber
@module Lightsaber.UI
@extends Lightsaber.Core.View

@since 9.2.0

@requires Lightsaber.Core

@constructor
@param {Object} [options] constructor's only parameter
@param {Object} [options.config] main configuration parameter
@param {String} [options.config.template] main <em>DynamicView</em> template  
@param {String} [options.config.autoRender=true] whether <em>DynamicView</em> should render immediately or wait for data from <em>ViewModel</em>
@param {String} [options.config.vmKeys] mapping of expected name of <em>ViewModel</em> properties
property to its actual name in the specific <em>ViewModel</em> that this <em>DynamicView</em> 
receives at runtime.

@examples none
**/
define('src/ui/dynamic/LazyDynamicView',[
    'underscore',
    'knockout',
    'lightsaber.core',
    'src/ui/dynamic/DynamicView',
    'tpl!src/ui/dynamic/templates/mainLazyTemplate.html',
    'tpl!src/ui/dynamic/templates/innerLazyTemplate.html'
], function(_, KO, Core, DynamicView, mainLazyTemplate, innerLazyTemplate) {
    
    

        
    var LazyDynamicView = DynamicView.extend({
                
        ANIMATION_CONFIG_PROP: 'animationDuration',
        PX_UNIT: 'px',
        TARGET_PROP: 'target',
        FORM_SELECTOR: '[data-point="form"]',
        INNER_TEMPLATE_PROP: 'innerTemplate',
        IS_ROOT_PROP: 'isRoot',

        NAVIGATE_ACTION: 'navigate',
        BACK_ACTION: 'back',

        config: {
            template: mainLazyTemplate,
            innerTemplate: innerLazyTemplate
        },

        postRender: function() {
            this.$target = this.getConfig(this.TARGET_PROP) || this.$el.find(this.FORM_SELECTOR);
        },

        navigate: function($element, data, context) {  
            if(!this.guard) {
                this.guard = true;
                this._increaseWidth();
                this._createInnerDynamicView(context);
                this._slideForward();
                this.viewModel.handleAction(this.NAVIGATE_ACTION);
            }
        },

        _slideForward: function() {
            var itemWidth = this.$target.width()/this.$target.children().length;
            var left = this.$target.position().left - itemWidth;

            this.$target.animate({left: left + this.PX_UNIT}, this.getConfig(this.ANIMATION_CONFIG_PROP), _.bind(this._handleNavigate, this));
        },

        back: function() {
            this._slideBack();
        },

        _handleNavigate: function() {
            this.guard = false;
        },
        
        _slideBack: function() {
            var itemWidth = this.$target.width()/this.$target.children().length;
            var left = this.$target.position().left + itemWidth;

            if(this.$target.position().left < 0) {
                this.$target.animate({left: left + this.PX_UNIT}, this.getConfig(this.ANIMATION_CONFIG_PROP), 
                    _.bind(this._handleSlideEnd, this));                
            }
        },

        _handleSlideEnd: function() {
            this.destroy();
            this._reduceWidth();
        },

        _increaseWidth: function() {
            var itemWidth = this.$target.width()/this.$target.children().length;
            var newSliderWidth = itemWidth * (this.$target.children().length + 1); 

            this.$target.css({
                width: newSliderWidth
            });
        },

        _reduceWidth: function() {
            var itemWidth = this.$target.width()/(this.$target.children().length + 1);
            var newSliderWidth = itemWidth * this.$target.children().length; 

            this.$target.css({
                width: newSliderWidth
            });
        },

        _createInnerDynamicView: function() {
            this.create('innerDynamicView', LazyDynamicView, {
                el: this.$target,
                viewModel: this.viewModel,
                config: {
                    target: this.$target,
                    template: this.getConfig(this.INNER_TEMPLATE_PROP),
                    innerTemplate: this.getConfig(this.INNER_TEMPLATE_PROP)
                }
            });
        },

        destroy: function() {
            if(this.getConfig(this.IS_ROOT_PROP)) {
                this.$target.remove();
                this.$target = null;
            }
            
            this.selfDestroy();                                            
        },

        remove: function() {
            this.$el.children().slice(-1).remove();
            this.stopListening();
            return this;
        }
    });

    return LazyDynamicView;
});
/**
Generic <em>DynamicViewModel</em> component. Provides main data manipulation logic.

@class Lightsaber.UI.DynamicViewModel
@namespace Lightsaber
@module Lightsaber.UI
@extends Lightsaber.Core.ViewModel

@since 9.2.0

@requires Lightsaber.Core

@constructor
@param {Object} [options] constructor's only parameter
@param {Object} [options.config] main configuration parameter
@param {Object} [options.config.configurator] alternative (to the default {{#crossLink "Lightsaber.UI.DynamicConfigurator"}}{{/crossLink}}) configurator
@param {Object} [options.config.validation] KO Validation plugin configuration that overrides the one provided by the 
base configuration that is provided by either default *DynamicConfiguration* or by the one that overrides
it and is provided by `config.configurator` configuration property

@examples none
**/
define('src/ui/dynamic/DynamicViewModel',[
    'underscore',
    'knockout',
    'knockout.mapping',
    'knockout.validation',
    'lightsaber.core',
    'src/ui/dynamic/DynamicConfigurator'
], function(_, KO, KOMapping, KOValidation, Core, DynamicConfigurator) {
    
    

        
    var DynamicViewModel = Core.ObservableViewModel.extend({
        /**
        Main data property. 

        Defines expected data structure (on the top level) to allow proper binding when the data 
        is retrieved or updated asynchronously. *KO* requires to have the root structure in place, 
        even if empty, to be able to bind to it and "wait" for the "real" data to arrive - at which 
        point *KO* re-binds the data and injects it into the DOM.

        @property {Object} data
        @protected
        @type {Object}
        @default `{isValid: true, isDirty: false}`
        @param {Boolean} [isValid=true] whether the *ViewModel* is in valid state
        @param {Boolean} [isDirty=false] whether the *ViewModel* is in dirty state (after edit before save)
        **/

        
        defaults: {
            metadata: {
                isDirty: KO.observable(false),
                isValid: KO.observable(true),
                components: []
            }
        },

        config: {
            createUniqueId: true,
            validateOnLoad: false,
            showErrorsOnLoad: false
        },

        /**
        Main-entry method that creates and binds *ViewModel* to the provided data and metadata *Models*.

        Creates the default *Configurator* and waits for the data.

        @method initialize
        @param {Object} [options={}] main configuration property as it is passed to the constructor
        **/
        initialize: function(configurationOptions) {
            var options = configurationOptions || {};
            var config = options.config || {};

            this._pathsMap = this._pathsMap || {};

            this.markValid();
            this.initDirtyState();
            
            this.setConfig('initial', true);
            this.setConfig('loaded', false);

            this._createConfigurator(config.configurator);
        },

        init: function() {
            throw new Error('Method `init` has been removed! Please use `load` instead');
        },

        /**
        Starts the binding/mapping process.

        @method load
        @param {Object} metadata metadata to use
        @param {Object} data data to use
        **/
        load: function(metadata, data) {
            var loaded = this.getConfig('loaded');

            if(loaded) {
                this._pathsMap = {};
                this.reset();
                this.set('isDirty', false);
                this.set('isValid', true);
                this._load(metadata, data);
                this.trigger('reload');
            } else {
                this._load(metadata, data);                
            }

            this.initDirtyState();
            this.setConfig('loaded', true); 
        },

        clear: function() {
            if(this.data) {
                if(this.data.__ko_mapping__) {
                    this.data.__ko_mapping__.components = null;                
                }

                this.data.data = {};
                this.data.metadata = {};                
            }
        },

        getConfigurator: function() {
            return this.configurator;
        },

        _initValidation: function() { 
            // NO-OP by design
        },

        _load: function(metadata, data) {
            this._preLoad();
            var processedData = this._initData(data);
            this._store(processedData);
            this._build(metadata);

            this.augmentMetadata();
        },

        _preLoad: function() {
            
        },
        
        augmentMetadata: function() {
            
        },

        resetDirtyState: function() {
            this.setConfig('initial', true);
            this.initDirtyState();   
        },

        /**
        Initializes (in case it is empty) the data object.

        @method _initData
        @param {Object} data data to use
        @return {Object} the initialized data object
        **/
        _initData: function(data) {
            return data || {};
        },

        /**
        Creates the default *Configurator* and stores it on `configurator` property.

        @method _createConfigurator
        @protected
        @param {Lightsaber.UI.BaseDynamicConfigurator} [configurator] cofigurator (if any) that was passed via the constructor
        **/
        _createConfigurator: function(configurator) {           
            if(configurator) {
                this.configurator = configurator;
                this.configurator.config.viewModel = this;
            } else {
                this.configurator = new DynamicConfigurator({
                    config: {
                        resourceBundle: this.getConfig('resourceBundle'),
                        viewModel: this
                    }
                });
            }
        },

        setDynamicConfigurator: function (configurator) {
            this.configurator = configurator;
        },

        /**
        Stores the data.

        @method _store
        @protected
        @param {Object} data the data for the *Dynamic UI*
        **/
        _store: function(data) {
            this.set('data', data, true);
        },

        /**
        Builds the *ViewModel's* data to be bound to the HTML by:

        1. retrieving the default *Builder*
        2. call {{#crossLink "Lightsaber.UI.Builder/buildMapping:method"}}buildMapping{{/crossLink}} to build mapping
        3. augment the data by calling {{#crossLink "Lightsaber.UI.DynamicViewModel/_augment:method"}}_augment{{/crossLink}}
        4. set the data onto the *ViewModel*

        @method _build
        @protected
        @param {Object} metadata the metadata for the *Dynamic UI*
        @param {Object} data the data for the *Dynamic UI*
        **/
        _build: function(metadata) {            
            var builder = this.configurator.getBuilder();
            var mappedData = this.get('data', true); // in order to not receive copy
            var createUniqueId = this.getConfig('createUniqueId');

            var item;

            builder.setViewModel(this);

            if(_.isUndefined(metadata.uniqueId) && createUniqueId) {
                metadata.uniqueId = _.uniqueId('id.');                        
            }

            for (var i = 0, length = metadata.components.length; i < length; i++) {
                item = metadata.components[i];
                item.metadataPath = 'metadata.components.' + i;

                if(_.isUndefined(item.uniqueId) && createUniqueId) {
                    item.uniqueId = metadata.uniqueId + '.' + i;                        
                }
            }

            var mapping = builder.buildMapping(mappedData, metadata);

            mapping.observe.push('metadata');
            mapping.observe.push('metadata.reference');

            this._augment();

            this.set('metadata', metadata, mapping); 

            if(this.getConfig('validateOnLoad')) {
                this._validate(null, true);
            }

            this.setConfig('initial', false);                       
        },

        set: function() {
            this._setGuard_ = true;
            this._super.apply(this, arguments);
            this._setGuard_ = false;
            this.validateIfNeeded(this._validationNeeded_showErrors_);
        },

        validateIfNeeded: function(showErrors) {
            if (this._validationNeeded_) {
                this._validationNeeded_ = false;
                this.validate(showErrors);
            }
        },

        validate: function(showErrors) {
            var initial = this.getConfig('initial');

            if (this._setGuard_) {
                this._validationNeeded_ = true;
                this._validationNeeded_showErrors_ = this._validationNeeded_showErrors_ || (showErrors !== false);
                return;
            }

            if(!initial) {
                this._validate(showErrors, initial);
            }
        },

        _validate: function(showErrors, initial) {
            var meta = this.get('metadata', true);
            var errors = KOValidation.group(meta); 

            if(meta.isValid()) {
                this.markValid();
            } else {
                this.markInvalid();
            }
            
            if(errors) {
                if(!initial && (showErrors !== false)) {
                    errors.showAllMessages();                    
                } else {
                    if(this.getConfig('showErrorsOnLoad')) {
                        errors.showAllMessages();                    
                    }
                }          
            }
        },

        isValid: function() {
            return this.get('isValid') === true;
        },

        markValid: function() {
            this.set('isValid', true);        
        },

        markInvalid: function() {
            this.set('isValid', false);        
        },

        initDirtyState: function() {            
            this.set('isDirty',false);
        },

        markDirty: function() {
            this.set('isDirty', true);
        },

        showErrors: function() {
            var meta = this.get('metadata', true);
            var errors = KOValidation.group(meta);    

            errors.showAllMessages();
        },

        filterComponents: function(context, conditionFunction) {
            var result = KO.utils.arrayFilter(context.components, conditionFunction);
            return result;
        },

        getParent: function(context) {
            var parentPath = context.metadataPath.split('.').slice(0, -2).join('.');
            var parent = this.getValueByPath(parentPath, true);

            return parent;
        },
        
        duplicateInParent: function(context, augmentation, reduction) {
            var parent = this.getParent(context);

            var parentArray = parent.components;
            var newData = KOMapping.toJS(context);
            var createUniqueId = this.getConfig('createUniqueId');
            var newContext, index;

            newData = _.omit(newData, reduction);
            newData = _.extend(newData, augmentation);

            if(createUniqueId) {
                // index of to be added item is length of the array.
                newData.uniqueId = parent.uniqueId + '.' + parentArray.peek().length;                        
            }

            index = parentArray.mappedIndexOf({id: context.id});
                        
            parentArray.mappedCreate(newData);

            newContext = parentArray.peek()[parentArray.peek().length - 1];
            
            var newArray = parentArray.peek();

            newArray.splice(index, 0, newContext);
            newArray.pop();

            this._adjustAllMetadataPaths(newArray, parent.metadataPath);           

            parentArray(newArray);

            this.enableForValidation(newContext);

            return newContext;
        },

        removeFromValidation: function(context) {
            context.__kv_traversed = true;
        },

        enableForValidation: function(context) {
            if(!_.isUndefined(context.__kv_traversed)) {
                delete context.__kv_traversed;
            }
        },

        replaceInParent: function(context, augmentation, reduction) {            
            var parentArrayPath = context.metadataPath.split('.').slice(0, -1).join('.');
            var parentMetadataPath = context.metadataPath.split('.').slice(0, -2).join('.');
            var parentArray = this.getValueByPath(parentArrayPath, true);

            var newData = KOMapping.toJS(context);
            var newContext, index;

            newData = _.omit(newData, reduction);
            newData = _.extend(newData, augmentation);
            
            newContext = KOMapping.fromJS(newData, context.__ko_mapping__);            
            
            index = parentArray.mappedIndexOf({id: context.id});

            parentArray()[index] = newContext;
            this._adjustAllMetadataPaths(parentArray, parentMetadataPath);

            parentArray.valueHasMutated();
        },

        removeInParent: function(context) {            
            var parentArrayPath = context.metadataPath.split('.').slice(0, -1).join('.');
            var parentMetadataPath = context.metadataPath.split('.').slice(0, -2).join('.');
            var parentArray = this.getValueByPath(parentArrayPath, true);

            var componentsArray = parentArray.peek();
            var filteredComponentsArray = _.reject(componentsArray, function(component) {
                return component.id === context.id;    
            });

            this._adjustAllMetadataPaths(filteredComponentsArray, parentMetadataPath);

            parentArray(filteredComponentsArray);
        },

        _adjustAllMetadataPaths: function(parentArray, parentMetadataPath) {
            var array = KO.unwrap(parentArray);

            for (var i = 0; i < array.length; i++) {
                this._adjustMetadataPath(array[i], i, parentMetadataPath);
            }
        },

        _adjustMetadataPath: function(context, index, parentMetadataPath) {
            context.metadataPath = parentMetadataPath + '.components.' + index;
            context.index = index;

            if(context.components) {
                this._adjustAllMetadataPaths(context.components, context.metadataPath);
            }
        },

        /**
        Augments the *ViewModel's* data to be bound to the HTML by templates types hash.

        @method _augment
        @protected
        **/
        _augment: function() {
            this._attachHelpers();
            this.set('templates', this.configurator.getConfig('templates'), true);
        },

        _attachHelpers: function() {
            var helpers = this.getConfig('helpers');

            if(!_.isUndefined(helpers)) {                
                _.each(helpers, _.bind(this._attachSingleHelper, this));

                this.set('helpers', helpers, true); 
            }
        },

        _attachSingleHelper: function(helper, name, helpers) {
            if(_.isString(helper)) {
                helpers[name] = _.bind(this[name], this);
            } else if(_.isFunction(helper)) {
                helpers[name] = _.bind(helper, this);
            } else {
                throw new Error('Incorrect helper ' + name);
            }
        },

        addPath: function(path, mappedData) {
            var unmappedValue;

            if(!_.isUndefined(mappedData) && !_.has(mappedData, 'components')) {
                if(KO.isObservable(mappedData.value)) {
                    this._pathsMap[path] = this._pathsMap[path] || [];
                    this._pathsMap[path].push(mappedData.value);
                } else if(_.isObject(mappedData.value)) {
                    unmappedValue = KOMapping.toJS(mappedData.value);

                    _.each(unmappedValue, function(innerValue, key) {
                        this._addInnerPath(path + '.' + key, mappedData.value[key]);
                    }, this);                                      
                }
            }
        },

        _addInnerPath: function(path, value) {
            var unmappedValue;

            if(KO.isObservable(value)) {
                this._pathsMap[path] = this._pathsMap[path] || [];
                this._pathsMap[path].push(value);
            } else if(!_.isArray(value) && _.isObject(value)) {
                unmappedValue = KOMapping.toJS(value);

                _.each(unmappedValue, function(innerValue, key) {
                    this._addInnerPath(path + '.' + key, innerValue);
                }, this);                   
            } else if(_.isArray(value)) {

            }
        },  

        notifyPath: function(path, value) {
            var paths;

            paths = this._pathsMap[path];

            if(!_.isUndefined(paths)) {
                for (var i = 0; i < paths.length; i++) {
                    paths[i](value);
                }                
            } else if(!_.isArray(value) && _.isObject(value)) {
                _.each(value, function(innerValue, key) {
                    this.notifyPath(path + '.' + key, innerValue);
                }, this);
            }
        }
    });

    return DynamicViewModel;

});

define('tpl!src/ui/modal/templates/modalTemplate.html', function() {return function(obj) { var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<div class="uxf-modal">    <div class="uxf-modal-header" data-uxf-point="modalHeader">        <button class="uxf-control-button" data-bind="click: \'close\'">Close</button>    </div>    <div class="uxf-modal-content" data-uxf-point="modalContent"></div>    <div class="uxf-modal-footer" data-uxf-point="modalFooter"></div></div>');}return __p.join('');}});

define('src/ui/modal/ModalView',[
    'underscore',
    'lightsaber.core',
    'tpl!src/ui/modal/templates/modalTemplate.html'
], function(_, Core, modalTemplate) {
    
    

    var ModalView = Core.View.extend({
        config: {
            template: modalTemplate
        },

        NO_OP: function() {},

        initialize: function(options) {
            this.openCallback = options.open || this.NO_OP;  
            this.closeCallback = options.close || this.NO_OP;  
        },

        postRender: function() {
            var closeOnBlur = this.getConfig('closeOnBlur');

            this.$screen =  $('<div class="uxf-modal-screen"></div>');
            this.$screen.insertBefore(this.$root);

            if(closeOnBlur) {
                this.$screen.on('click.modalview', _.bind(this.close, this));                
            }

            this.open();
        },

        open: function() {
            this.openCallback(this.$root);
        },

        close: function($element) {
            var abort = this.closeCallback(this.$root, $element);

            if(!abort) {
                this.destroy();         
            }
        },

        destroy: function() {
            var closeOnBlur = this.getConfig('closeOnBlur');

            if(this.$screen) {
                if(closeOnBlur) {
                    this.$screen.off('click.modalview');                    
                }

                this.$screen.remove();                            
            }

            this._super();
        }
    });

    return ModalView;

});
define('src/lightsaber.ui',[
    'src/ui/dynamic/DynamicView',
    'src/ui/dynamic/LazyDynamicView',
    'src/ui/dynamic/DynamicViewModel',
    'src/ui/dynamic/DynamicConfigurator',
    'src/ui/dynamic/builders/Builder',
    'src/ui/dynamic/validators/Validator',
    'src/ui/dynamic/resolvers/Resolver',
    'src/ui/modal/ModalView'
], function (
    DynamicView,
    LazyDynamicView,
    DynamicViewModel,
    DynamicConfigurator,
    Builder,
    Validator,
    Resolver,
    ModalView
) {
    return {
        DynamicView: DynamicView,
        LazyDynamicView: LazyDynamicView,
        DynamicViewModel: DynamicViewModel,
        DynamicConfigurator: DynamicConfigurator,
        Builder: Builder,
        Validator: Validator,
        Resolver: Resolver,
        ModalView: ModalView
    }; 
});

define('lightsaber_UXFLibMetaData',[],
    function () {
            });

define("src_web/lightsaber.library", function(){});

define('lightsaber',[
    'src_web/lightsaber.components',
    'src/lightsaber.ui',
    'src_web/lightsaber.library'
], function (Lightsaber, LightsaberUI) {
    Lightsaber.UI = LightsaberUI;
        return Lightsaber; 
});

